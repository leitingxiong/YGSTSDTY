<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GoRogue</name>
    </assembly>
    <members>
        <member name="T:GoRogue.Components.ComponentCollection">
             <summary>
             A class implementing a flexible, type-based system for keeping track of components that are added to objects.
             A ComponentCollection can simply be added as a member of an object that needs components attached to it, then
             used by a list.
             </summary>
             <remarks>
             This collection allows you to add arbitrary objects to it, optionally associated with a string tag.  It then
             allows you to very efficiently query whether or not an object has a component of a given type and tag, and
             retrieve that object, in a type-safe way.  It handles cases where multiple objects of a single type are added,
             as well as cases where inheritance and/or interfaces are involved.
            
             While components may be of any type, thanks to value-type defensive copying it is highly recommended that you
             refrain from using value types as components.
            
             You may also control the order/priority with which components are retrieved.  Components are retrieved in the
             order they were added by default.  If you would like more control than this, you may have your components
             implement <see cref="T:GoRogue.Components.ISortedComponent"/>.  Although implementing this interface is not required, any components
             that do implement it are returned before any components that do not.  Similarly, components with a lower sort
             order are returned before those with higher sort orders.
            
             It is worthy of note that, when given as a tag parameter, "null" is used to mean "no particular tag", rather
             than "no tag whatsoever"; a call to a function that retrieves components that is given a tag of "null" can
             retrieve any component meeting the type restrictions, regardless of whether it is associated with a tag.
            
             Finally, if components implementing <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/> are added/removed, their parent field
             will be automatically updated as needed.
             </remarks>
        </member>
        <member name="P:GoRogue.Components.ComponentCollection.Count">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.Components.ComponentCollection.ParentForAddedComponents">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.#ctor(System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="parentForAddedComponents">
            Parent value to use for any <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/> instances
            added to the collection.  If null is specified, nothing is set to the Parent field.
            </param>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.#ctor(System.Collections.Generic.IEnumerable{System.Object},System.Object)">
            <summary>
            Constructor taking a set of starting components.
            </summary>
            <param name="objects">Components to initially add.</param>
            <param name="parentForAddedComponents">
            Parent value to use for any <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/> instances
            added to the collection.  If null is specified, nothing is set to the Parent field.
            </param>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.#ctor(System.Collections.Generic.IEnumerable{GoRogue.Components.ComponentTagPair})">
            <summary>
            Constructor taking a set of starting components and their associated tags.
            </summary>
            <param name="objectsAndTags">Components to initially add and their corresponding tags.</param>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.#ctor(System.Collections.Generic.IEnumerable{GoRogue.Components.ComponentTagPair},System.Object)">
            <summary>
            Constructor taking a set of starting components and their associated tags.
            </summary>
            <param name="objectsAndTags">Components to initially add and their corresponding tags.</param>
            <param name="parentForAddedComponents">
            Parent value to use for any <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/> instances
            added to the collection.  If null is specified, nothing is set to the Parent field.
            </param>
        </member>
        <member name="E:GoRogue.Components.ComponentCollection.ComponentAdded">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.Components.ComponentCollection.ComponentRemoved">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Add``1(``0,System.String)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Clear">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Remove(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Remove(System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Remove(System.String)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Remove(System.String[])">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Contains(System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Contains(GoRogue.Components.ComponentTypeTagPair[])">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Contains(System.Type,System.String)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.Contains``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.GetFirstOrDefault``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.GetFirst``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.GetAll``1">
            <summary>
            Gets all components of type T that have been added, with components having a lower
            <see cref="P:GoRogue.Components.ISortedComponent.SortOrder"/> being returned first.  Components that do not implement
            <see cref="T:GoRogue.Components.ISortedComponent"/> are returned after any that do.  Among components with equal sort orders
            or components that do not implement <see cref="T:GoRogue.Components.ISortedComponent"/>, components are returned in the order
            they were added.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <typeparam name="T">Type of components to retrieve.</typeparam>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.GoRogue#Components#IComponentCollection#GetAll``1">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.GetEnumerator">
            <summary>
            Returns all components paired with their tags.  Ordered with respect to sorted components.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns components paired with their tags.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.Components.ComponentTagPair">
            <summary>
            A component from a <see cref="T:GoRogue.Components.IComponentCollection"/> and its associated tag.
            </summary>
        </member>
        <member name="F:GoRogue.Components.ComponentTagPair.Component">
            <summary>
            The component.
            </summary>
        </member>
        <member name="F:GoRogue.Components.ComponentTagPair.Tag">
            <summary>
            The tag associated with its component.
            </summary>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.#ctor(System.Object,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="component"/>
            <param name="tag"/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.ToString">
            <summary>
            Returns a string representing the component and its tag
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.Deconstruct(System.Object@,System.String@)">
            <summary>
            Supports C# Deconstruction syntax.
            </summary>
            <param name="component"/>
            <param name="tag"/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.op_Implicit(GoRogue.Components.ComponentTagPair)~System.ValueTuple{System.Object,System.String}">
            <summary>
            Implicitly converts a ComponentTagPair to an equivalent tuple.
            </summary>
            <param name="pair"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.op_Implicit(System.ValueTuple{System.Object,System.String})~GoRogue.Components.ComponentTagPair">
            <summary>
            Implicitly converts a tuple to its equivalent ComponentTagPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.ToTuple">
            <summary>
            Converts the pair to an equivalent tuple.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.FromTuple(System.ValueTuple{System.Object,System.String})">
            <summary>
            Converts the tuple to an equivalent ComponentTagPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.Equals(GoRogue.Components.ComponentTagPair)">
            <summary>
            True if the given pair has the same component and tag; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.Matches(GoRogue.Components.ComponentTagPair)">
            <summary>
            True if the given pair has the same component and tag; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.Equals(System.Object)">
            <summary>
            True if the given object is a ComponentTagPair and has the same component and tag; false otherwise.
            </summary>
            <param name="obj"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.GetHashCode">
            <summary>
            Returns a hash code based on all of the pair's field's.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.op_Equality(GoRogue.Components.ComponentTagPair,GoRogue.Components.ComponentTagPair)">
            <summary>
            True if the given pairs have the same component and tag; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTagPair.op_Inequality(GoRogue.Components.ComponentTagPair,GoRogue.Components.ComponentTagPair)">
            <summary>
            True if the given pairs have different components and/or tags; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="T:GoRogue.Components.ComponentTypeTagPair">
            <summary>
            A type of a component and the tag expected to be associated with a component of that type in a
            <see cref="T:GoRogue.Components.IComponentCollection"/> or map generation step.
            </summary>
        </member>
        <member name="F:GoRogue.Components.ComponentTypeTagPair.ComponentType">
            <summary>
            The type of component expected.
            </summary>
        </member>
        <member name="F:GoRogue.Components.ComponentTypeTagPair.Tag">
            <summary>
            The tag expected to be associated with a component of the specified type.
            </summary>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.#ctor(System.Type,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="componentType"/>
            <param name="tag"/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.ToString">
            <summary>
            Returns a string representing the component type and its tag.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.Deconstruct(System.Type@,System.String@)">
            <summary>
            Supports C# Deconstruction syntax.
            </summary>
            <param name="componentType"/>
            <param name="tag"/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.op_Implicit(GoRogue.Components.ComponentTypeTagPair)~System.ValueTuple{System.Type,System.String}">
            <summary>
            Implicitly converts a ComponentTypeTagPair to an equivalent tuple.
            </summary>
            <param name="pair"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.op_Implicit(System.ValueTuple{System.Type,System.String})~GoRogue.Components.ComponentTypeTagPair">
            <summary>
            Implicitly converts a tuple to its equivalent ComponentTypeTagPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.ToTuple">
            <summary>
            Converts the pair to an equivalent tuple.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.FromTuple(System.ValueTuple{System.Type,System.String})">
            <summary>
            Converts the tuple to an equivalent ComponentTypeTagPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.Equals(GoRogue.Components.ComponentTypeTagPair)">
            <summary>
            True if the given pair has the same component type and tag; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.Matches(GoRogue.Components.ComponentTypeTagPair)">
            <summary>
            True if the given pair has the same component type and tag; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.Equals(System.Object)">
            <summary>
            True if the given object is a ComponentTypeTagPair and has the same component type and tag; false otherwise.
            </summary>
            <param name="obj"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.GetHashCode">
            <summary>
            Returns a hash code based on all of the pair's field's.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.op_Equality(GoRogue.Components.ComponentTypeTagPair,GoRogue.Components.ComponentTypeTagPair)">
            <summary>
            True if the given pairs have the same component type and tag; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.ComponentTypeTagPair.op_Inequality(GoRogue.Components.ComponentTypeTagPair,GoRogue.Components.ComponentTypeTagPair)">
            <summary>
            True if the given pairs have different component types and/or tags; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="T:GoRogue.Components.ComponentChangedEventArgs">
            <summary>
            Arguments for events fired when components are added/removed from a component collection.
            </summary>
        </member>
        <member name="M:GoRogue.Components.ComponentChangedEventArgs.#ctor(System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="component">The component that was added/removed.</param>
        </member>
        <member name="F:GoRogue.Components.ComponentChangedEventArgs.Component">
            <summary>
            The component that was added or removed.
            </summary>
        </member>
        <member name="T:GoRogue.Components.IComponentCollection">
             <summary>
             Interface for a collection of components, of arbitrary types, that can optionally be associated with an arbitrary,
             unique tag string.  A concrete implementation is provided; see <see cref="T:GoRogue.Components.ComponentCollection"/>.
             </summary>
             <remarks>
             Typically, you will not need to implement this yourself, as <see cref="T:GoRogue.Components.ComponentCollection"/> should be suffice
             for most use cases.  Nonetheless, the interface is provided for completeness, or if you have a need to
             re-implement it for a corner case of performance.
            
             It is worthy of note that "null" is used to mean "no particular tag", rather than "no tag whatsoever";
             a call to a function that retrieves components that is given a tag of "null" can retrieve any component meeting
             the type restrictions, regardless of whether it is associated with a tag.
             </remarks>
        </member>
        <member name="E:GoRogue.Components.IComponentCollection.ComponentAdded">
            <summary>
            Fired when a component is added to the collection.
            </summary>
        </member>
        <member name="E:GoRogue.Components.IComponentCollection.ComponentRemoved">
            <summary>
            Fired when a component is removed from the collection.
            </summary>
        </member>
        <member name="P:GoRogue.Components.IComponentCollection.Count">
            <summary>
            Number of components attached.
            </summary>
        </member>
        <member name="P:GoRogue.Components.IComponentCollection.ParentForAddedComponents">
            <summary>
            Object automatically set as the parent for any <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/> added to the collection.
            Useful if you have components associated with an object.  This defaults to null, and if its value is null,
            no parent is set when components are added.
            </summary>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Clear">
            <summary>
            Removes all components from the collection.
            </summary>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Add``1(``0,System.String)">
            <summary>
            Adds the given object as a component, optionally giving it a tag.  Throws ArgumentException if the given
            object is already in this collection.
            </summary>
            <param name="component">Component to add.</param>
            <param name="tag">An optional tag to give the component.  Defaults to no tag.</param>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Remove(System.String)">
            <summary>
            Removes the component with the given tag.  Throws ArgumentException if a component with the specified tag
            does not exist.
            </summary>
            <param name="tag">Tag for component to remove.</param>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Remove(System.String[])">
            <summary>
            Removes the component(s) with the given tags.  Throws ArgumentException if a tag is encountered that does
            not have an object associated with it.
            </summary>
            <param name="tags">Tag(s) of components to remove.</param>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Remove(System.Object)">
            <summary>
            Removes the given component from the collection.  Throws ArgumentException if the component isn't
            in the collection.
            </summary>
            <param name="component">Component to remove.</param>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Remove(System.Object[])">
            <summary>
            Removes the given component(s) from the collection.  Throws ArgumentException if a component given
            isn't in the collection.
            </summary>
            <param name="components">One or more components to remove.</param>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Contains(System.Type[])">
            <summary>
            True if at least one component of each type specified has been added; false otherwise.
            </summary>
            <param name="componentTypes">One or more component types to check for.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Contains(GoRogue.Components.ComponentTypeTagPair[])">
            <summary>
            True if, for each pair specified, there exists a component of the given type with the given tag in the
            collection.
            </summary>
            <remarks>
            If "null" is specified as a tag, it indicates no particular tag; eg. any object of the given type will meet
            the requirement, regardless of whether or not it has a tag.
            </remarks>
            <param name="componentTypesAndTags">One or more component types and corresponding tags to check for.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Contains(System.Type,System.String)">
            <summary>
            True if a component of the specified type, and associated with the specified tag if one is specified,
            has been added; false otherwise.
            </summary>
            <remarks>
            If "null" is specified for <paramref name="tag"/>, it indicates no particular tag; eg. any object of the
            given type will meet the requirement, regardless of whether or not it has a tag.
            </remarks>
            <param name="componentType">The type of component to check for.</param>
            <param name="tag">The tag to check for.  If null is specified, no particular tag is checked for.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.Contains``1(System.String)">
            <summary>
            True if a component of the specified type, and associated with the specified tag if one is specified, has
            been added; false otherwise.
            </summary>
            <remarks>
            If "null" is specified for <paramref name="tag"/>, it indicates no particular tag; eg. ANY object of the
            given type will meet the requirement, whether that object has a tag or not.
            </remarks>
            <typeparam name="T">Type of component to check for.</typeparam>
            <param name="tag">The tag to check for.  If null is specified, no particular tag is checked for.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.GetFirst``1(System.String)">
             <summary>
             Gets the component of type T in the collection that has been associated with the given tag, or the
             component of type T with the lowest <see cref="P:GoRogue.Components.ISortedComponent.SortOrder"/> if no tag is specified.
             </summary>
             <remarks>
             Among components with equal sort orders or components that do not implement <see cref="T:GoRogue.Components.ISortedComponent"/>,
             the first component of the given type that was added is returned.
            
             Throws ArgumentException if no component of the given type associated with the given tag has been added.
            
             If "null" is specified for <paramref name="tag"/>, it indicates no particular tag; eg. ANY object of the
             given type will meet the requirement, whether that object has a tag or not.
             </remarks>
             <typeparam name="T">Type of component to retrieve.</typeparam>
             <param name="tag">Tag for component to retrieve.  If null is specified, no particular tag is checked for.</param>
             <returns/>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.GetFirstOrDefault``1(System.String)">
             <summary>
             Gets the component of type T in the collection that has been associated with the given tag, or the
             component of type T with the lowest <see cref="P:GoRogue.Components.ISortedComponent.SortOrder"/> if no tag is specified.
             </summary>
             <remarks>
             Among components with equal sort orders or components that do not implement <see cref="T:GoRogue.Components.ISortedComponent"/>,
             the first component of the given type that was added is returned.
            
             Returns default(T) if no component of the given type/associated with the given tag has been added.
             If you would instead like to throw an exception if a component of the given type is not found, see
             <see cref="M:GoRogue.Components.IComponentCollection.GetFirst``1(System.String)"/>.
            
             If "null" is specified for <paramref name="tag"/>, it indicates no particular tag; eg. ANY object of the
             given type will meet the requirement, whether that object has a tag or not.
             </remarks>
             <typeparam name="T">Type of component to retrieve.</typeparam>
             <param name="tag">Tag for component to retrieve.  If null is specified, no particular tag is checked for.</param>
             <returns/>
        </member>
        <member name="M:GoRogue.Components.IComponentCollection.GetAll``1">
            <summary>
            Gets all components of type T that have been added, with components having a lower
            <see cref="P:GoRogue.Components.ISortedComponent.SortOrder"/> being returned first.  Components that do not implement
            <see cref="T:GoRogue.Components.ISortedComponent"/> are returned after any that do.  Among components with equal sort orders
            or components that do not implement <see cref="T:GoRogue.Components.ISortedComponent"/>, components are returned in the order
            they were added.
            </summary>
            <typeparam name="T">Type of components to retrieve.</typeparam>
            <returns/>
        </member>
        <member name="T:GoRogue.Components.ISortedComponent">
             <summary>
             Interface that you may optionally implement on objects added to a <see cref="T:GoRogue.Components.IComponentCollection"/>
             (for example, <see cref="T:GoRogue.Components.ComponentCollection"/>) that enforces an order in which components are returned from
             functions that retrieve components.
             </summary>
             <remarks>
             When functions that return components are called on <see cref="T:GoRogue.Components.ComponentCollection"/> or some other
             <see cref="T:GoRogue.Components.IComponentCollection"/>, components with a lower <see cref="P:GoRogue.Components.ISortedComponent.SortOrder"/> are returned before
             components with a higher one.  Components that do not implement <see cref="T:GoRogue.Components.ISortedComponent"/> are returned
             after any that do.
            
             This can be useful to enforce that certain types of or instances of components are processed before some other
             type of or instance of components.
             </remarks>
        </member>
        <member name="P:GoRogue.Components.ISortedComponent.SortOrder">
            <summary>
            Value indicating the relative ordering of this component.  A lower value cause a component to be retrieved
            before any components of the same type with a higher value.
            </summary>
        </member>
        <member name="T:GoRogue.Components.ParentAware.IObjectWithComponents">
            <summary>
            Interface providing a convention for objects that use component collections to store components associated
            with themselves.
            </summary>
        </member>
        <member name="P:GoRogue.Components.ParentAware.IObjectWithComponents.GoRogueComponents">
            <summary>
            Collection holding components that GoRogue has recorded as being attached to the implementing object.
            </summary>
        </member>
        <member name="T:GoRogue.Components.ParentAware.IParentAwareComponent">
            <summary>
            Optional interface for components that are attached to something via a components field.
            </summary>
            <remarks>
            While the implementation of this interface is not required for GoRogue components, when it is used with something
            implementing <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>, the <see cref="P:GoRogue.Components.ParentAware.IParentAwareComponent.Parent" /> field is automatically updated when
            you add or remove this component from a component collection. A component implementing this interface cannot be
            added to multiple objects at the same time.
            </remarks>
        </member>
        <member name="P:GoRogue.Components.ParentAware.IParentAwareComponent.Parent">
            <summary>
            The object to which this component is attached, or null if it is not attached.
            </summary>
            <remarks>
            Should not be assigned to manually, outside of a custom implementation of
            <see cref="T:GoRogue.Components.IComponentCollection"/>.  It is set automatically when added/removed from an object's
            component collection.
            </remarks>
        </member>
        <member name="T:GoRogue.Components.ParentAware.ParentAwareComponentRemovedEventArgs`1">
            <summary>
             EventArguments used for the <see cref="E:GoRogue.Components.ParentAware.ParentAwareComponentBase.Removed"/> event.
            </summary>
            <typeparam name="T">The type of the parent being passed.</typeparam>
        </member>
        <member name="F:GoRogue.Components.ParentAware.ParentAwareComponentRemovedEventArgs`1.OldParent">
            <summary>
            The parent from which the object was detached.
            </summary>
        </member>
        <member name="M:GoRogue.Components.ParentAware.ParentAwareComponentRemovedEventArgs`1.#ctor(`0)">
            <summary>
            Constructor.
            </summary>
            <param name="oldParent">The parent from which the object was detached.</param>
        </member>
        <member name="T:GoRogue.Components.ParentAware.ParentAwareComponentBase">
             <summary>
             Simple (and optional) base class for components attached to a class implementing
             <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>.  Adds useful events and some helper functions to allow performing
             type-checking of parent, or requiring that the object it's attached to has or does not have certain types of
             components.
             </summary>
             <remarks>
             This class may be added as a component to any class that implements <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>, however components
             inheriting from this class will not implicitly fail in any way if it is used with a class that does not implement that interface.
             Certain functions such as <see cref="M:GoRogue.Components.ParentAware.ParentAwareComponentBase.IncompatibleWith``1(System.Object,System.EventArgs)"/> do require that their parent implement IObjectWithComponents,
             and in general there is no guarantee that the Parent field gets updated if the parent doesn't implement that interface; however
             you can sync the parent field manually as applicable.
            
             In most cases, the intended usage is to add this as a component to a class that implements <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>;
             however the option of not doing so and manually syncing the Parent field instead allows this functionality to be tied into other
             component systems as well.
             </remarks>
        </member>
        <member name="E:GoRogue.Components.ParentAware.ParentAwareComponentBase.Added">
            <summary>
            Fires when the component is attached to an object.
            </summary>
        </member>
        <member name="E:GoRogue.Components.ParentAware.ParentAwareComponentBase.Removed">
            <summary>
            Fires when the component is unattached from an object
            </summary>
        </member>
        <member name="P:GoRogue.Components.ParentAware.ParentAwareComponentBase.Parent">
            <summary>
            The object the component is attached to.
            </summary>
        </member>
        <member name="M:GoRogue.Components.ParentAware.ParentAwareComponentBase.ParentTypeCheck``1(System.Object,System.EventArgs)">
            <summary>
            Add as a handler to <see cref="E:GoRogue.Components.ParentAware.ParentAwareComponentBase.Added"/> to enforce that this component must be parented to an object that
            inherits from/implements <typeparamref name="TParent"/>.
            </summary>
            <typeparam name="TParent">Type of object that must be this component's parent.</typeparam>
            <param name="s" />
            <param name="e" />
        </member>
        <member name="M:GoRogue.Components.ParentAware.ParentAwareComponentBase.IncompatibleWith``1(System.Object,System.EventArgs)">
            <summary>
            Add as a handler to <see cref="E:GoRogue.Components.ParentAware.ParentAwareComponentBase.Added"/> to enforce that this component may not be added to an object that
            has a component of type <typeparamref name="TComponent"/>.  May also be used to enforce that the component
            can't have multiple instances of itself attached to the same object by using
            Added += IncompatibleWith&lt;MyOwnType&gt;.
            </summary>
            <remarks>
            This function only works if the parent is of type IObjectWithComponents.  If the parent is not of that
            type, this function will throw an exception.
            </remarks>
            <typeparam name="TComponent">Type of the component this one is incompatible with.</typeparam>
            <param name="s"/>
            <param name="e"/>
        </member>
        <member name="T:GoRogue.Components.ParentAware.ParentAwareComponentBase`1">
             <summary>
             Optional base class for components attached to a class implementing <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>.
             Adds all functionality of <see cref="T:GoRogue.Components.ParentAware.ParentAwareComponentBase"/>, and additionally type-checks the object it's
             attached to to make sure it is of the given type.  It also exposes its <see cref="P:GoRogue.Components.ParentAware.ParentAwareComponentBase`1.Parent"/> property as that type
             instead of object.
             </summary>
             <remarks>
             Like <see cref="T:GoRogue.Components.ParentAware.ParentAwareComponentBase"/>, subclasses of this class may be added as a component to any class that implements
             <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>, however components inheriting from this class will not implicitly fail in any way if it is
             used with a class that does not implement that interface.  Certain functions such as
             <see cref="M:GoRogue.Components.ParentAware.ParentAwareComponentBase.IncompatibleWith``1(System.Object,System.EventArgs)"/> do require that their parent implement IObjectWithComponents,
             and in general there is no guarantee that the Parent field gets updated if the parent doesn't implement that interface; however
             you can sync the parent field manually as applicable.
            
             In most cases, the intended usage is to add this as a component to a class that implements <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/>;
             however the option of not doing so and manually syncing the Parent field instead allows this functionality to be tied into other
             component systems as well.
             </remarks>
             <typeparam name="TParent">Type of the component's parent.</typeparam>
        </member>
        <member name="P:GoRogue.Components.ParentAware.ParentAwareComponentBase`1.Parent">
            <summary>
            The object the component is attached to.
            </summary>
        </member>
        <member name="E:GoRogue.Components.ParentAware.ParentAwareComponentBase`1.Removed">
            <summary>
            Fires when the component is unattached from an object
            </summary>
        </member>
        <member name="M:GoRogue.Components.ParentAware.ParentAwareComponentBase`1.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:GoRogue.DiceNotation.Dice">
            <summary>
            The most important <see cref="N:GoRogue.DiceNotation" /> class -- contains functions to roll dice, and to retrieve an
            <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance representing a given expression.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Dice.DiceParser">
            <summary>
            The parser that will be used to parse dice expressions given to the <see cref="M:GoRogue.DiceNotation.Dice.Parse(System.String)" /> and
            <see cref="M:GoRogue.DiceNotation.Dice.Roll(System.String,ShaiRandom.Generators.IEnhancedRandom)" />
            functions. If you want to use a custom parser, you can assign an instance to this field.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Dice.Parse(System.String)">
            <summary>
            Uses the <see cref="T:GoRogue.DiceNotation.IParser" /> specified in the <see cref="F:GoRogue.DiceNotation.Dice.DiceParser" /> variable to produce an
            <see cref="T:GoRogue.DiceNotation.DiceExpression" />
            instance representing the given dice expression.
            </summary>
            <remarks>
            Generally speaking, dice-parsing via the standard <see cref="M:GoRogue.DiceNotation.Dice.Roll(System.String,ShaiRandom.Generators.IEnhancedRandom)" /> method is extremely fast.
            However, if
            you are repeating a dice roll many times, in a case where maximum performance is absolutely necessary, there is some
            benefit to
            retrieving a <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance instead
            of using the Roll function, and calling that expression's <see cref="M:GoRogue.DiceNotation.DiceExpression.Roll(ShaiRandom.Generators.IEnhancedRandom)" /> method
            whenever a result
            is required.
            </remarks>
            <param name="expression">The string dice expression to parse.</param>
            <returns>A <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance representing the parsed string.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Dice.Roll(System.String,ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Uses the <see cref="T:GoRogue.DiceNotation.IParser" /> specified in the <see cref="F:GoRogue.DiceNotation.Dice.DiceParser" /> variable to parse the given dice expression,
            roll it, and return the result.  This is the standard method for rolling dice.
            </summary>
            <remarks>
            This method is convenient and typically very fast, however technically, parsing is computationally
            more expensive than evaluation. If a dice expression will be rolled many times in a situation where
            maximum performance is required, it is more efficient to use the <see cref="M:GoRogue.DiceNotation.Dice.Parse(System.String)" /> method
            once, and use the resulting <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance to roll the expression each time it
            is needed.
            </remarks>
            <param name="expression">The string dice expression to parse.</param>
            <param name="random">
            RNG to use to perform the roll. If null is specified, the default RNG is used.
            </param>
            <returns>The result of evaluating the dice expression given.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.DiceExpression">
            <summary>
            The default class for representing a parsed dice expression.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.DiceExpression.RootTerm">
            <summary>
            The root term in this expression tree.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.#ctor(GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the last term in the dice expression (the root of the expression tree).
            </summary>
            <param name="rootTerm">
            The root of the expression tree -- by evaluating this term, all others will be evaluated recursively.
            </param>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.MaxRoll">
            <summary>
            Returns the maximum possible result of the dice expression.
            </summary>
            <returns>The maximum possible result of the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.MinRoll">
            <summary>
            Returns the minimum possible result of the dice expression.
            </summary>
            <returns>The minimum possible result of the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.Roll(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Rolls the expression using the RNG given, returning the result.
            </summary>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <returns>The result obtained by rolling the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.ToString">
            <summary>
            Returns a parenthesized string representing the dice expression in dice notation
            </summary>
            <returns>A parenthesized string representing the expression.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.ImpossibleDieException">
            <summary>
            Exception that is thrown when a die is attempted to be constructed with an invalid number of sides.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and the exception that caused this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidChooseException">
            <summary>
            Exception that is thrown when a dice term is constructed with a 'k' choose operation to keep
            an invalid number of dice.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException">
            <summary>
            Exception that is thrown when a dice term is constructed with a negative number of dice.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException">
            <summary>
            Exception that is thrown when a the syntax of a dice notation string is determined to be invalid.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.IParser">
            <summary>
            Interface for a class that parses a string representing a dice expression into an
            <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance.  You might implement this if you need to implement a custom
            dice parser.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.IParser.Parse(System.String)">
            <summary>
            Parses the dice expression specified into a <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance.
            </summary>
            <param name="expression">The expression to parse.</param>
            <returns>
            An <see cref="T:GoRogue.DiceNotation.DiceExpression" /> representing the given expression, that can "roll" the expression on command.
            </returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Parser">
            <summary>
            Default class for parsing a string representing a dice expression into a <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Parser.Parse(System.String)">
            <summary>
            Parses the dice expression specified into a <see cref="T:GoRogue.DiceNotation.DiceExpression" /> instance.
            </summary>
            <remarks>
            Breaks the dice expression into postfix form, and evaluates the postfix expression to the
            degree necessary to produce the appropriate chain of <see cref="T:GoRogue.DiceNotation.Terms.ITerm" /> instances.
            </remarks>
            <param name="expression">The expression to parse.</param>
            <returns>
            An <see cref="T:GoRogue.DiceNotation.DiceExpression" /> representing the given expression, that can "roll" the expression on command.
            </returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.AddTerm">
            <summary>
            Term representing the addition operator -- adds two terms together.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to add.
            </summary>
            <param name="term1">Left-hand side.</param>
            <param name="term2">Right-hand side.</param>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.AddTerm.Term1">
            <summary>
            First term (left-hand side).
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.AddTerm.Term2">
            <summary>
            Second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Adds its two terms together, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to use, passed to other terms.</param>
            <returns>The result of adding <see cref="F:GoRogue.DiceNotation.Terms.AddTerm.Term1" /> and <see cref="F:GoRogue.DiceNotation.Terms.AddTerm.Term2" />.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.ToString">
            <summary>
            Converts to a parenthesized string.
            </summary>
            <returns>A parenthesized string representing the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.ConstantTerm">
            <summary>
            Base term -- represents a numerical constant.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.ConstantTerm.Value">
            <summary>
            The numerical constant represented by this term.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.#ctor(System.Int32)">
            <summary>
            Constructor. Takes the numerical constant it represents.
            </summary>
            <param name="value">The numerical value this term represents.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Returns the numerical constant it represents. RNG is unused.
            </summary>
            <param name="rng">(Unused) rng.</param>
            <returns>The numerical constant this term represents.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.ToString">
            <summary>
            Returns a string representation of this constant.
            </summary>
            <returns>The numerical constant being represented, as a string.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.DiceTerm">
            <summary>
            Represents a dice term, eg 1d4 or 2d6.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the terms representing multiplicity and number of sides.
            </summary>
            <param name="multiplicity">
            Term representing the number of dice being rolled -- 2d6 has multiplicity 2.
            </param>
            <param name="sides">
            Term representing the number of sides the dice have -- 2d6 has 6 sides.
            </param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.DiceResults">
            <summary>
            An enumerable of integers representing the result of each dice roll. The expression 2d6
            rolls 2 dice, and as such this enumerable would be of length 2 and contain the result of
            each individual die.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.LastMultiplicity">
            <summary>
            The result of evaluating the <see cref="F:GoRogue.DiceNotation.Terms.DiceTerm.Multiplicity" /> term that was used during the last call to
            <see cref="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)" />.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.LastSidedness">
            <summary>
            The result of evaluating the <see cref="F:GoRogue.DiceNotation.Terms.DiceTerm.Sides" /> term that was used during the last call to
            <see cref="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)" />.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.DiceTerm.Multiplicity">
            <summary>
            Term representing the number of dice being rolled -- 2d6 has multiplicity 2.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.DiceTerm.Sides">
            <summary>
            Term representing the number of sides the dice have -- 2d6 has 6 sides.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Rolls the dice, returning the sum.
            </summary>
            <param name="rng">The RNG to use for rolling,</param>
            <returns>The sum of the roll.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.ToString">
            <summary>
            Gets a parenthesized string representation of the dice term, eg (2d6).
            </summary>
            <returns>A parenthesized representation of the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.DivideTerm">
            <summary>
            Term representing the division operator -- divides the first term by the second.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to divide.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (right-hand side).</param>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.DivideTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.DivideTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Divides the first term by the second, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating <see cref="F:GoRogue.DiceNotation.Terms.DivideTerm.Term1" /> / <see cref="F:GoRogue.DiceNotation.Terms.DivideTerm.Term2" />.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.ToString">
            <summary>
            Returns a parenthesized string representing the operation.
            </summary>
            <returns>A parenthesized string representing the operation.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.ITerm">
            <summary>
            Interface for a term of a dice expression that can be evaluated.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ITerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Evaluates the term and returns the result.
            </summary>
            <param name="rng">The rng to use.</param>
            <returns>The result of evaluating the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.KeepTerm">
            <summary>
            Term representing the keep operator -- keeping only the n highest dice from a dice term.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.KeepTerm.DiceTerm">
            <summary>
            The dice term to operate on.
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.KeepTerm.Keep">
            <summary>
            The number of dice to keep.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.DiceTerm)">
            <summary>
            Constructor. Takes a term representing the number of dice to keep, and the dice term to
            operate on.
            </summary>
            <param name="keep">Term representing the number of dice to keep.</param>
            <param name="diceTerm">The dice term to operate on.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Evaluates the term (as well as the dice expression), returning the sum of the highest n
            rolls in the dice term.
            </summary>
            <param name="rng">The rng to use -- passed to the dice term being operated on.</param>
            <returns>
            The sum of the highest n rolls of the dice term being operated on, where n is equal to
            the value of the keep variable taken in the constructor.
            </returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.ToString">
            <summary>
            Returns a parenthesized string representing the term -- eg (4d6k3) or (2d6k2)
            </summary>
            <returns>A parenthesized string representing the term</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.MultiplyTerm">
            <summary>
            Term representing the multiplication operator -- multiplies <see cref="F:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1" /> and <see cref="F:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2" />.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the terms that will be multiplied.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (left-hand side).</param>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Multiplies the first term by the second, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating <see cref="F:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1" /> * <see cref="F:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2" />.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.ToString">
            <summary>
            Returns a parenthesized string representing the term.
            </summary>
            <returns>A parenthesized string representing the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.SubtractTerm">
            <summary>
            Term representing the subtraction operator -- subtracts the second term from the first.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to subtract.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (right-hand side).</param>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.SubtractTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Terms.SubtractTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.GetResult(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Subtracts the second term from the first, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating <see cref="F:GoRogue.DiceNotation.Terms.SubtractTerm.Term1" /> - <see cref="F:GoRogue.DiceNotation.Terms.SubtractTerm.Term2" />.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.ToString">
            <summary>
            Returns a parenthesized string representing the operation.
            </summary>
            <returns>A parenthesized string representing the operation.</returns>
        </member>
        <member name="T:GoRogue.JoinedEventArgs">
            <summary>
            Event arguments for the <see cref="E:GoRogue.DisjointSet.SetsJoined"/> event.
            </summary>
        </member>
        <member name="F:GoRogue.JoinedEventArgs.LargerSetID">
            <summary>
            The larger of the two sets that were joined; becomes the new parent set.
            </summary>
        </member>
        <member name="F:GoRogue.JoinedEventArgs.SmallerSetID">
            <summary>
            The smaller of the two sets that were joined; becomes the new child set.
            </summary>
        </member>
        <member name="M:GoRogue.JoinedEventArgs.#ctor(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="largerSetID">The larger of the two sets that were joined; becomes the new parent set.</param>
             <param name="smallerSetID">The smaller of the two sets that were joined; becomes the new child set.</param>
        </member>
        <member name="T:GoRogue.JoinedEventArgs`1">
            <summary>
            Event arguments for the <see cref="E:GoRogue.DisjointSet`1.SetsJoined"/> event.
            </summary>
        </member>
        <member name="F:GoRogue.JoinedEventArgs`1.LargerSet">
            <summary>
            The larger of the two sets that were joined; becomes the new parent set.
            </summary>
        </member>
        <member name="F:GoRogue.JoinedEventArgs`1.SmallerSet">
            <summary>
            The smaller of the two sets that were joined; becomes the new child set.
            </summary>
        </member>
        <member name="M:GoRogue.JoinedEventArgs`1.#ctor(`0,`0)">
             <summary>
            
             </summary>
             <param name="largerSet">The larger of the two sets that were joined; becomes the new parent set.</param>
             <param name="smallerSet">The smaller of the two sets that were joined; becomes the new child set.</param>
        </member>
        <member name="T:GoRogue.DisjointSet">
            <summary>
            Basic representation of a disjoint set data structure.
            </summary>
            <remarks>
            For reasons pertaining to optimization, this disjoint set implementation does not use
            generics, and instead holds integer values, which will be exactly all integer values in range
            [0, num_items_in_set - 1].  Thus, you will need to assign appropriate IDs to objects you intend
            to add and map them appropriately.
            </remarks>
        </member>
        <member name="E:GoRogue.DisjointSet.SetsJoined">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet.#ctor(System.Int32)">
            <summary>
            Constructor. The disjoint set will contain all values in range [0, <paramref name="size" /> - 1].
            </summary>
            <param name="size">(Max) size of the disjoint set.</param>
        </member>
        <member name="P:GoRogue.DisjointSet.Count">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet.Find(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet.InSameSet(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet.AsReadOnly">
            <summary>
            Returns a read-only representation of the disjoint set.
            </summary>
            <returns>A read-only representation of the disjoint set.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.MakeUnion(System.Int32,System.Int32)">
            <summary>
            Performs a union of the sets containing the objects specified by the two IDs. After this operation,
            every element in the sets containing the two objects specified will be part of one larger set.
            </summary>
            <remarks>If the two elements are already in the same set, nothing is done.</remarks>
            <param name="obj1" />
            <param name="obj2" />
        </member>
        <member name="M:GoRogue.DisjointSet.ToString">
            <summary>
            Returns a string representation of the DisjointSet, showing IDs of parents and all elements in
            their set.
            </summary>
            <returns>A string representation of the DisjointSet.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.ExtendToString(System.Func{System.Int32,System.String})">
            <summary>
            Returns a string representation of the DisjointSet, showing parents and all elements in
            their set.  The given function is used to produce the string for each element.
            </summary>
            <returns>A string representation of the DisjointSet.</returns>
        </member>
        <member name="T:GoRogue.DisjointSet`1">
            <summary>
            An easier-to-use (but less efficient) variant of <see cref="T:GoRogue.DisjointSet"/>.  This version takes actual objects
            of type T, and manages IDs for you automatically.
            </summary>
            <remarks>
            This set structure is effectively exactly like <see cref="T:GoRogue.DisjointSet"/>, however it takes type T instead
            of IDs.  For the sake of efficiency, it still requires the number of elements to be known when the set is
            created.
            </remarks>
            <typeparam name="T">Type of elements in the set.</typeparam>
        </member>
        <member name="E:GoRogue.DisjointSet`1.SetsJoined">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.DisjointSet`1.Count">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new disjoint set that is composed of the given items.  Each item will be its own
            unique set.
            </summary>
            <remarks>
            The items will be mapped to IDs in the range [0, <paramref name="items" />.Length - 1]
            via a Dictionary, where the keys are hashed using the comparer specified, or the default hash function
            if no comparer is specified.
            </remarks>
            <param name="items">Items to place in the disjoint set.</param>
            <param name="comparer">Optional comparer to use when hashing items.</param>
        </member>
        <member name="M:GoRogue.DisjointSet`1.Find(`0)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet`1.InSameSet(`0,`0)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.DisjointSet`1.AsReadOnly">
            <summary>
            Returns a read-only representation of the disjoint set.
            </summary>
            <returns>A read-only representation of the disjoint set.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet`1.MakeUnion(`0,`0)">
            <summary>
            Performs a union of the sets containing the two objects specified. After this operation,
            every element in the sets containing the two objects specified will be part of one larger set.
            </summary>
            <remarks>If the two elements are already in the same set, nothing is done.</remarks>
            <param name="item1" />
            <param name="item2" />
        </member>
        <member name="M:GoRogue.DisjointSet`1.ToString">
            <summary>
            Returns a string representation of the DisjointSet, parents and all elements in
            their set.  The element's default ToString method is used to produce the string.
            </summary>
            <returns>A string representation of the DisjointSet.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet`1.ExtendToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the DisjointSet, showing parents and all elements in
            their set.  The given function is used to produce the string for each element.
            </summary>
            <returns>A string representation of the DisjointSet.</returns>
        </member>
        <member name="T:GoRogue.Effects.AdvancedEffect`1">
            <summary>
            More advanced version of <see cref="T:GoRogue.Effects.Effect"/> which allows for a parameter to be passed to the
            Trigger method.
            </summary>
            <remarks>
            This effect type is useful when information about a particular trigger needs to be passed to the effect
            in order for it to work.  For example, an effect which reacts to damage might need to know how much damage
            is being dealt in order to function.
            </remarks>
            <typeparam name="TTriggerArgs">
            The type of the parameter that will be specified to the <see cref="M:GoRogue.Effects.AdvancedEffect`1.Trigger(`0)" />
            function (or its overloads) when called.
            </typeparam>
        </member>
        <member name="M:GoRogue.Effects.AdvancedEffect`1.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Name for the effect.</param>
            <param name="startingDuration">Starting duration for the effect.</param>
        </member>
        <member name="M:GoRogue.Effects.AdvancedEffect`1.Trigger(System.Boolean@,`0)">
            <summary>
            Triggers the effect.  If you're calling this function manually, you should use the
            <see cref="M:GoRogue.Effects.AdvancedEffect`1.Trigger(`0)"/> function instead, unless you intend to manually support cancellation of
            a trigger.
            </summary>
            <remarks>
            Any effect that has Instant duration or duration 0 when this function is called
            will still have its <see cref="M:GoRogue.Effects.AdvancedEffect`1.OnTrigger(System.Boolean@,`0)" /> function called.
            </remarks>
            <param name="cancelTrigger">
            When set to true, if the effect is being called by an EffectTrigger, the trigger will be cancelled;
            eg. any events which have yet to be triggered will not be triggered during the current call to
            <see cref="M:GoRogue.Effects.EffectTrigger.TriggerEffects"/>.  If the effect is not being called by an EffectTrigger,
            this parameter has no effect.
            </param>
            <param name="args">The parameter to pass to the <see cref="M:GoRogue.Effects.AdvancedEffect`1.OnTrigger(System.Boolean@,`0)" /> function.</param>
        </member>
        <member name="M:GoRogue.Effects.AdvancedEffect`1.Trigger(`0)">
            <summary>
            Triggers the effect, ignoring any result set to the boolean value in <see cref="M:GoRogue.Effects.AdvancedEffect`1.Trigger(System.Boolean@,`0)"/>.
            Should be called to trigger instantaneously occuring effects or effects that aren't part of an EffectTrigger
            and thus don't support trigger cancellation.
            </summary>
            <remarks>
            Any effect that has Instant duration or duration 0 when this function is called
            will still have its <see cref="M:GoRogue.Effects.AdvancedEffect`1.OnTrigger(System.Boolean@,`0)" /> function called.
            </remarks>
            <param name="args">The parameter to pass to the <see cref="M:GoRogue.Effects.AdvancedEffect`1.OnTrigger(System.Boolean@,`0)" /> function.</param>
        </member>
        <member name="M:GoRogue.Effects.AdvancedEffect`1.OnTrigger(System.Boolean@,`0)">
            <summary>
            Implement to take whatever action(s) the effect is supposed to accomplish.
            This function is called automatically when <see cref="M:GoRogue.Effects.AdvancedEffect`1.Trigger(System.Boolean@,`0)" /> is called.
            </summary>
            <param name="cancelTrigger">
            When set to true, if the effect is being called by an EffectTrigger, the trigger will be cancelled;
            eg. any events which have yet to be triggered will not be triggered during the current call to
            <see cref="M:GoRogue.Effects.EffectTrigger.TriggerEffects"/>.  If the effect is not being called by an EffectTrigger,
            this parameter has no effect.
            </param>
            <param name="args">Arguments passed to the Trigger function.</param>
        </member>
        <member name="T:GoRogue.Effects.AdvancedEffectTrigger`1">
            <summary>
            More advanced version of <see cref="T:GoRogue.Effects.EffectTrigger"/> which allows for a parameter to be passed to the
            TriggerEffects method.
            </summary>
            <remarks>
            This effect trigger type is useful when information about a particular trigger needs to be passed to the effects
            in order for them to work.  For example, effects which react to damage might need to know how much damage
            is being dealt in order to function.
            </remarks>
            <typeparam name="TTriggerArgs">
            The type of the parameter that will be specified to the <see cref="M:GoRogue.Effects.AdvancedEffect`1.Trigger(System.Boolean@,`0)" />
            function when called.
            </typeparam>
        </member>
        <member name="M:GoRogue.Effects.AdvancedEffectTrigger`1.TriggerEffects(`0)">
            <summary>
            Calls the <see cref="M:GoRogue.Effects.AdvancedEffect`1.Trigger(System.Boolean@,`0)" /> function of each effect
            in the <see cref="N:GoRogue.Effects" /> list (as long as its duration is not 0), then
            removes any effect that has duration 0.
            </summary>
            <remarks>
            If some effect sets the boolean it receives as an "out" parameter to true, the loop will be broken and no
            subsequent effects in the list will have Trigger called. After either this occurs or all effects have had
            their Trigger function called, any effect in the list that has a duration of 0 is automatically removed from
            the list.
            </remarks>
            <param name="args">Arguments to pass to the Trigger function of each effect that is triggered.</param>
        </member>
        <member name="T:GoRogue.Effects.Effect">
             <summary>
             Class designed to represent any sort of in-game effect. This could be anything from a simple
             physical damage effect to a heal effect or permanent effects.  These might include AOE effects,
             damage over time effects, or even potentially a special effect that simply boosts a stat.
             </summary>
             <remarks>
             Effectively, the class is nothing more than a basis for the concept of something that
             happens, potentially instantaneously or potentially one or more times on a certain event
             (beginning of a turn, end of a turn, on taking damage, etc). The standard way to use the
             Effect class is to create a subclass of Effect, that at the very least implements the
             <see cref="M:GoRogue.Effects.Effect.OnTrigger(System.Boolean@)" /> function, which should accomplish whatever the effect should
             do when it is triggered.
            
             The concept of a duration is also built into the interface, and is considered to be in arbitrary units.  The duration
             concept is designed to be used with <see cref="T:GoRogue.Effects.EffectTrigger" /> instances, and has no effect when an effect is not
             utilized with an EffectTrigger.  The duration is interpreted as simply the number of times the effect's
             <see cref="M:GoRogue.Effects.Effect.Trigger(System.Boolean@)" />) function will be called before it will be removed from an EffectTrigger. If the
             effect is instantaneous, eg. it happens only when Trigger is called, on no particular event (such as a simple instant damage
             effect), then the duration specified in the constructor should be the static class constant
             <see cref="F:GoRogue.Effects.EffectDuration.Instant" />. If the effect is meant to have an infinite duration, or the effect wears off on some
             condition other than time passing, the duration may be set to <see cref="F:GoRogue.Effects.EffectDuration.Infinite" />, and then manipulated
             appropriately to 0 when the effect has expired. More explanation of Effects and EffectTriggers, and usage examples,
             can be found at the GoRogue documentation site <a href="http://www.roguelib.com/articles/howtos/effects-system.html">here</a>.
             </remarks>
        </member>
        <member name="M:GoRogue.Effects.Effect.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Name for the effect.</param>
            <param name="startingDuration">Starting duration for the effect.</param>
        </member>
        <member name="M:GoRogue.Effects.Effect.Trigger(System.Boolean@)">
            <summary>
            Triggers the effect.  If you're calling this function manually, you should use the
            <see cref="M:GoRogue.Effects.Effect.Trigger"/> function instead, unless you intend to manually support cancellation of a trigger.
            </summary>
            <remarks>
            Any effect that has Instant duration or duration 0 when this function is called
            will still have its <see cref="M:GoRogue.Effects.Effect.OnTrigger(System.Boolean@)" /> function called.
            </remarks>
            <param name="cancelTrigger">
            When set to true, if the effect is being called by an EffectTrigger, the trigger will be cancelled;
            eg. any events which have yet to be triggered will not be triggered during the current call to
            <see cref="M:GoRogue.Effects.EffectTrigger.TriggerEffects"/>.  If the effect is not being called by an EffectTrigger,
            this parameter has no effect.
            </param>
        </member>
        <member name="M:GoRogue.Effects.Effect.Trigger">
            <summary>
            Triggers the effect, ignoring any result set to the boolean value in <see cref="M:GoRogue.Effects.Effect.Trigger(System.Boolean@)"/>.
            Should be called to trigger instantaneously occuring effects or effects that aren't part of an EffectTrigger
            and thus don't support trigger cancellation.
            </summary>
            <remarks>
            Any effect that has Instant duration or duration 0 when this function is called
            will still have its <see cref="M:GoRogue.Effects.Effect.OnTrigger(System.Boolean@)" /> function called.
            </remarks>
        </member>
        <member name="M:GoRogue.Effects.Effect.OnTrigger(System.Boolean@)">
            <summary>
            Implement to take whatever action(s) the effect is supposed to accomplish.
            This function is called automatically when <see cref="M:GoRogue.Effects.Effect.Trigger(System.Boolean@)" /> is called.
            </summary>
            <param name="cancelTrigger">
            When set to true, if the effect is being called by an EffectTrigger, the trigger will be cancelled;
            eg. any events which have yet to be triggered will not be triggered during the current call to
            <see cref="M:GoRogue.Effects.EffectTrigger.TriggerEffects"/>.  If the effect is not being called by an EffectTrigger,
            this parameter has no effect.
            </param>
        </member>
        <member name="T:GoRogue.Effects.EffectBase">
            <summary>
            Base class for <see cref="T:GoRogue.Effects.Effect"/> and <see cref="T:GoRogue.Effects.AdvancedEffect`1"/>.  Typically not useful
            unless you're creating a a custom implementation of effects and/or triggers.
            </summary>
        </member>
        <member name="P:GoRogue.Effects.EffectBase.Duration">
            <summary>
            The duration of the effect.
            </summary>
            <remarks>
            When the duration reaches 0, the effect will be automatically removed from an
            <see cref="T:GoRogue.Effects.EffectTrigger" />.
            The duration can be changed from a subclass, which can be used in OnTrigger to
            cause an effect to be "cancelled", eg. immediately expire, or to extend/reduce its duration.
            </remarks>
        </member>
        <member name="P:GoRogue.Effects.EffectBase.Name">
            <summary>
            The name of the effect.
            </summary>
        </member>
        <member name="E:GoRogue.Effects.EffectBase.Expired">
            <summary>
            Event that fires as soon as the effect is about to expire. Fires after the
            OnTrigger function has been called but before it is
            removed from any <see cref="T:GoRogue.Effects.EffectTrigger" /> instances.
            </summary>
        </member>
        <member name="M:GoRogue.Effects.EffectBase.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Name for the effect.</param>
            <param name="startingDuration">Starting duration for the effect.</param>
        </member>
        <member name="M:GoRogue.Effects.EffectBase.ToString">
            <summary>
            Returns a string of the effect's name and duration.
            </summary>
            <returns>String representation of the effect.</returns>
        </member>
        <member name="T:GoRogue.Effects.EffectDuration">
            <summary>
            Static class containing special constants used for the duration of effects.
            </summary>
        </member>
        <member name="F:GoRogue.Effects.EffectDuration.Infinite">
            <summary>
            The value one should specify as the effect duration for an infinite effect, eg. an effect
            that will never expire or whose expiration time is arbitrary (for example, based on a condition
            other than the passing of time).
            </summary>
        </member>
        <member name="F:GoRogue.Effects.EffectDuration.Instant">
            <summary>
            The value one should specify as the effect duration for an instantaneous effect, eg. an
            effect that only occurs when Trigger is manually called, and thus cannot be added to an
            effect trigger.
            </summary>
        </member>
        <member name="T:GoRogue.Effects.EffectTrigger">
             <summary>
             Represents an "event" that can automatically trigger and manage one or more
             <see cref="T:GoRogue.Effects.Effect" /> instances, and acts as part of the implementation of
             duration in Effect.
             </summary>
             <remarks>
             EffectTrigger's primary purpose is to represent an event that can trigger one or more effects, and
             automatically remove those effects from the list when their duration reaches 0.  Each EffectTrigger
             instance can have one or more (non-instantaneous) effects added to it.
            
             Each time the <see cref="M:GoRogue.Effects.EffectTrigger.TriggerEffects" /> function is called, every Effect has its
             Trigger function called (provided its duration is not 0). Each Effect may, via the cancelTrigger
             parameter, member, stop the event from being sent to subsequent effects in the EffectTrigger's list.
             Once either all effects in the list have had their Trigger function called, or some effect has cancelled the
             triggering, any effect whose duration has reached 0 is removed from the EffectTrigger automatically.
            
             Typically, one instance of this class is created per "event" that can trigger effects, and then the
             instance's TriggerEffects function is called whenever that event happens. For example, in a
             typical roguelike, all damageable creatures might have an instance of this class called
             OnDamageTakenEffects. Any effect that should trigger when that creature takes damage would then be
             added to that creature's OnDamageTakenEffects EffectTrigger. The TakeDamage function of that
             creature would then need to call OnDamageTakenEffects.TriggerEffects(...). In this way, all effects
             added to the OnDamageTakenEffects EffectTrigger would be triggered automatically whenever the
             creature takes damage.
            
             For some complex game mechanics, it may be desirable to control how effects stack, the order they appear
             in the effects list of EffectTriggers, etc. In these cases, sub-classing EffectTrigger and overriding the
             add and remove functions can allow this functionality.
            
             If you need to pass a parameter with extra data to the Trigger function, you should use <see cref="T:GoRogue.Effects.AdvancedEffectTrigger`1"/>
             and <see cref="T:GoRogue.Effects.AdvancedEffect`1"/> instead.
             </remarks>
        </member>
        <member name="M:GoRogue.Effects.EffectTrigger.TriggerEffects">
            <summary>
            Calls the <see cref="M:GoRogue.Effects.Effect.Trigger(System.Boolean@)" /> function of each effect
            in the <see cref="N:GoRogue.Effects" /> list (as long as its duration is not 0), then
            removes any effect that has duration 0.
            </summary>
            <remarks>
            If some effect sets the boolean it receives as an "out" parameter to true, the loop will be broken and no
            subsequent effects in the list will have Trigger called. After either this occurs or all effects have had
            their Trigger function called, any effect in the list that has a duration of 0 is automatically removed from
            the list.
            </remarks>
        </member>
        <member name="T:GoRogue.Effects.EffectTriggerBase`1">
            <summary>
            Base class for <see cref="T:GoRogue.Effects.EffectTrigger"/> and <see cref="T:GoRogue.Effects.AdvancedEffectTrigger`1"/>.  Typically not
            useful unless you're creating a a custom implementation of effects and/or triggers.
            </summary>
        </member>
        <member name="F:GoRogue.Effects.EffectTriggerBase`1.EffectsList">
            <summary>
            All effects that are part of this trigger.
            </summary>
        </member>
        <member name="P:GoRogue.Effects.EffectTriggerBase`1.Effects">
            <summary>
            List of all effects that are part of this trigger.
            </summary>
        </member>
        <member name="M:GoRogue.Effects.EffectTriggerBase`1.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.Effects.EffectTriggerBase`1.Add(`0)">
            <summary>
            Adds the given effect to this trigger, provided the effect's duration is not 0. If
            the effect's duration is 0, an ArgumentException is thrown.
            </summary>
            <param name="effect">The effect to add to this trigger.</param>
        </member>
        <member name="M:GoRogue.Effects.EffectTriggerBase`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the given effects to this trigger, provided the effect's durations are not 0. If
            an effect's duration is 0, an ArgumentException is thrown.
            </summary>
            <param name="effects">The effects to add to this trigger.</param>
        </member>
        <member name="M:GoRogue.Effects.EffectTriggerBase`1.Remove(`0)">
            <summary>
            Removes the given effect from this trigger.
            </summary>
            <param name="effect">The effect to remove</param>
        </member>
        <member name="M:GoRogue.Effects.EffectTriggerBase`1.RemoveAll(System.Predicate{`0})">
            <summary>
            Removes all given effects from this trigger which match the predicate.
            </summary>
            <param name="match">The predicate to decide which effects to remove.</param>
        </member>
        <member name="M:GoRogue.Effects.EffectTriggerBase`1.ToString">
            <summary>
            Yields a string representation of each effect that has been added to the effect trigger.
            </summary>
            <returns>
            A string representation of each effect that has been added to the effect trigger.
            </returns>
        </member>
        <member name="T:GoRogue.Factories.AdvancedFactory`3">
            <summary>
            A more advanced factory that produces a type of object based on a blueprint and a set of configuration parameters.
            </summary>
            <typeparam name="TBlueprintConfig">
            The type of parameter passed to the <see cref="M:GoRogue.Factories.AdvancedFactory`3.Create(`0,`1)" />
            function each time an object is created.
            </typeparam>
            <typeparam name="TBlueprintID">The type used to uniquely identify blueprints.</typeparam>
            <typeparam name="TProduced">The type of object this factory creates.</typeparam>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.#ctor(System.Collections.Generic.IEnumerable{GoRogue.Factories.IAdvancedFactoryBlueprint{`0,`1,`2}})">
            <summary>
            Constructor.  Takes some initial blueprints to add.
            </summary>
            <param name="initialBlueprints">Initial blueprints to add.</param>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.GetEnumerator">
            <summary>
            Gets an enumerator of all of the blueprints in the factory.
            </summary>
            <returns>An enumeration of the blueprints.</returns>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator of all of the blueprints in the factory.
            </summary>
            <returns>An enumeration of the blueprints.</returns>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.Add(GoRogue.Factories.IAdvancedFactoryBlueprint{`0,`1,`2})">
            <summary>
            Adds a blueprint to the factory.
            </summary>
            <param name="blueprint">The blueprint to add.</param>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.AddRange(System.Collections.Generic.IEnumerable{GoRogue.Factories.IAdvancedFactoryBlueprint{`0,`1,`2}})">
            <summary>
            Adds the given blueprints to the factory.
            </summary>
            <param name="blueprints">The blueprints to add.</param>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.Create(`0,`1)">
            <summary>
            Creates a <typeparamref name="TProduced" /> object using the blueprint with the given factory id, and the given
            settings object.
            </summary>
            <param name="blueprintID">The factory id of a blueprint.</param>
            <param name="blueprintConfig">A settings object passed to the Create function of the blueprint.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.BlueprintExists(`0)">
            <summary>
            Checks if a blueprint exists.
            </summary>
            <param name="blueprintID">The blueprint to check for.</param>
            <returns>Returns true when the specified <paramref name="blueprintID" /> exists; otherwise false.</returns>
        </member>
        <member name="M:GoRogue.Factories.AdvancedFactory`3.GetBlueprint(`0)">
            <summary>
            Gets a blueprint by identifier.
            </summary>
            <param name="blueprintID">The blueprint identifier to get.</param>
            <returns>The blueprint of the object.</returns>
            <exception cref="T:GoRogue.Factories.ItemNotDefinedException`1">Thrown if the factory identifier does not exist.</exception>
        </member>
        <member name="T:GoRogue.Factories.Factory`2">
            <summary>
            A simple factory that produces a type of object based on a blueprint.
            </summary>
            <typeparam name="TBlueprintID">The type used to uniquely identify blueprints.</typeparam>
            <typeparam name="TProduced">The type of object this factory creates.</typeparam>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.#ctor(System.Collections.Generic.IEnumerable{GoRogue.Factories.IFactoryBlueprint{`0,`1}})">
            <summary>
            Constructor.  Takes initial blueprints to add.
            </summary>
            <param name="initialBlueprints">Initial blueprints to add.</param>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.GetEnumerator">
            <summary>
            Gets an enumerator of all of the blueprints in the factory.
            </summary>
            <returns>An enumeration of the blueprints.</returns>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator of all of the blueprints in the factory.
            </summary>
            <returns>An enumeration of the blueprints.</returns>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.Add(GoRogue.Factories.IFactoryBlueprint{`0,`1})">
            <summary>
            Adds a blueprint to the factory.
            </summary>
            <param name="blueprint">The blueprint to add.</param>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.AddRange(System.Collections.Generic.IEnumerable{GoRogue.Factories.IFactoryBlueprint{`0,`1}})">
            <summary>
            Adds the given blueprints to the factory.
            </summary>
            <param name="blueprints">The blueprints to add.</param>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.Create(`0)">
            <summary>
            Creates a <typeparamref name="TProduced" /> object using the blueprint with the given factory id.
            </summary>
            <param name="blueprintID">The factory id of a blueprint.</param>
            <returns>A new object.</returns>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.BlueprintExists(`0)">
            <summary>
            Checks if a blueprint exists.
            </summary>
            <param name="blueprintID">The blueprint to check for.</param>
            <returns>Returns true when the specified <paramref name="blueprintID" /> exists; otherwise false.</returns>
        </member>
        <member name="M:GoRogue.Factories.Factory`2.GetBlueprint(`0)">
            <summary>
            Gets a blueprint by identifier.
            </summary>
            <param name="blueprintID">The blueprint identifier to get.</param>
            <returns>The blueprint of the object.</returns>
            <exception cref="T:GoRogue.Factories.ItemNotDefinedException`1">Thrown if the factory identifier does not exist.</exception>
        </member>
        <member name="T:GoRogue.Factories.IAdvancedFactoryBlueprint`3">
            <summary>
            Defines how to create a <typeparamref name="TProduced" /> object for use in an
            <see cref="T:GoRogue.Factories.AdvancedFactory`3" />.
            </summary>
            <typeparam name="TBlueprintID">The type used to uniquely identify blueprints.</typeparam>
            <typeparam name="TBlueprintConfig">
            The type of the parameter to pass to the <see cref="M:GoRogue.Factories.IAdvancedFactoryBlueprint`3.Create(`1)" />
            function.
            </typeparam>
            <typeparam name="TProduced">The type of object to create.</typeparam>
        </member>
        <member name="P:GoRogue.Factories.IAdvancedFactoryBlueprint`3.ID">
            <summary>
            A unique identifier of this factory definition.
            </summary>
        </member>
        <member name="M:GoRogue.Factories.IAdvancedFactoryBlueprint`3.Create(`1)">
            <summary>
            Creates an object of the type specified by TProduced using the given configuration parameters.
            </summary>
            <param name="config">Configuration parameters used to create the object.</param>
            <returns>The created object.</returns>
        </member>
        <member name="T:GoRogue.Factories.IFactoryBlueprint`2">
            <summary>
            Defines how to create a <typeparamref name="TProduced" /> object for use in an <see cref="T:GoRogue.Factories.Factory`2" />.
            </summary>
            <typeparam name="TBlueprintID">The type used to uniquely identify blueprints.</typeparam>
            <typeparam name="TProduced">The type of object to create.</typeparam>
        </member>
        <member name="P:GoRogue.Factories.IFactoryBlueprint`2.ID">
            <summary>
            A unique identifier of this factory definition.
            </summary>
        </member>
        <member name="M:GoRogue.Factories.IFactoryBlueprint`2.Create">
            <summary>
            Creates an object of the type specified by TProduced.
            </summary>
            <returns>The created object.</returns>
        </member>
        <member name="T:GoRogue.Factories.IFactoryObject`1">
            <summary>
            Interface that can optionally be implemented by objects created via a <see cref="T:GoRogue.Factories.Factory`2" /> or
            <see cref="T:GoRogue.Factories.AdvancedFactory`3" />.  The <see cref="P:GoRogue.Factories.IFactoryObject`1.DefinitionID" /> property
            will be automatically set to the ID of the blueprint used to create the object when the factory's Create function is
            called.
            </summary>
        </member>
        <member name="P:GoRogue.Factories.IFactoryObject`1.DefinitionID">
            <summary>
            The identifier of the blueprint that created this object. Do not set manually -- the factory
            will automatically set this field when the object is created.
            </summary>
        </member>
        <member name="T:GoRogue.Factories.ItemNotDefinedException`1">
            <summary>
            Exception thrown by <see cref="T:GoRogue.Factories.AdvancedFactory`3" /> or <see cref="T:GoRogue.Factories.Factory`2" />
            objects when a blueprint that doesn't exist is used.
            </summary>
        </member>
        <member name="M:GoRogue.Factories.ItemNotDefinedException`1.#ctor">
            <summary>
            Creates an exception with default message.
            </summary>
        </member>
        <member name="M:GoRogue.Factories.ItemNotDefinedException`1.#ctor(System.String,System.Exception)">
            <summary>
            Creates an exception with the specified inner exception and message.
            </summary>
            <param name="message">Exception message</param>
            <param name="innerException">Exception that caused this exception</param>
        </member>
        <member name="M:GoRogue.Factories.ItemNotDefinedException`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Creates an exception based on serialization context.
            </summary>
            <param name="info" />
            <param name="context" />
        </member>
        <member name="M:GoRogue.Factories.ItemNotDefinedException`1.#ctor(`0)">
            <summary>
            Creates an exception with a message based on the specified factory ID.
            </summary>
            <param name="factoryId">Factory id that caused the error.</param>
        </member>
        <member name="T:GoRogue.Factories.LambdaAdvancedFactoryBlueprint`3">
            <summary>
            An implementation of <see cref="T:GoRogue.Factories.IAdvancedFactoryBlueprint`3"/> that allows you to specify
            a Func object to use as the factory method.
            </summary>
            <remarks>
            This class may be useful for simple cases where your blueprint has no state, and you simply need to specify
            some code to run to create the object that takes a parameter.  For more complex cases, you may want to implement
            your own IAdvancedFactoryBlueprint.
            </remarks>
            <typeparam name="TBlueprintID">The type being used to identify what object to produce.</typeparam>
            <typeparam name="TBlueprintConfig">The type of object to pass to the creation function.</typeparam>
            <typeparam name="TProduced">The type of object being produced.</typeparam>
        </member>
        <member name="P:GoRogue.Factories.LambdaAdvancedFactoryBlueprint`3.ID">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Factories.LambdaAdvancedFactoryBlueprint`3.#ctor(`0,System.Func{`1,`2})">
            <summary>
            Constructor.
            </summary>
            <param name="id">A unique identifier for this factory blueprint definition.</param>
            <param name="factoryMethod">The method to call when <see cref="M:GoRogue.Factories.LambdaAdvancedFactoryBlueprint`3.Create(`1)"/> is used in order to get the object to return.</param>
        </member>
        <member name="M:GoRogue.Factories.LambdaAdvancedFactoryBlueprint`3.Create(`1)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.Factories.LambdaFactoryBlueprint`2">
            <summary>
            An implementation of <see cref="T:GoRogue.Factories.IFactoryBlueprint`2"/> that allows you to specify
            a Func object to use as the factory method.
            </summary>
            <remarks>
            This class may be useful for simple cases where your blueprint has no state, and you simply need to specify
            some code to run to create the object.  For more complex cases, you may want to implement your own IFactoryBlueprint.
            </remarks>
            <typeparam name="TBlueprintID">The type being used to identify what object to produce.</typeparam>
            <typeparam name="TProduced">The type of object being produced.</typeparam>
        </member>
        <member name="P:GoRogue.Factories.LambdaFactoryBlueprint`2.ID">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.Factories.LambdaFactoryBlueprint`2.#ctor(`0,System.Func{`1})">
            <summary>
            Constructor.
            </summary>
            <param name="id">A unique identifier for this factory blueprint definition.</param>
            <param name="factoryMethod">The method to call when <see cref="M:GoRogue.Factories.LambdaFactoryBlueprint`2.Create"/> is used in order to get the object to return.</param>
        </member>
        <member name="M:GoRogue.Factories.LambdaFactoryBlueprint`2.Create">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.FOV.FOVBooleanToDoubleTranslationView">
            <summary>
            Implements a grid view which, given an <see cref="T:GoRogue.FOV.IReadOnlyFOV"/> instance, can calculate the value for <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/> based on
            <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/>.  The double returned will be 0 if the square is outside the FOV, and will be a value in the range (0, 1] which
            is a function of the distance from the appropriate source otherwise.
            </summary>
            <remarks>
            This is useful to use as the DoubleResultView property of an FOV, if the FOV algorithm really only deals in boolean values and the doubles returned are purely
            a function of the calculation's radius/distance.  FOV implementations using this method of determining the DoubleResultView values from the BooleanResultView values
            can typically use less memory than algorithms dealing directly in doubles; but accessing values from DoubleResultView will be slower, especially when multiple
            CalculateAppend calls are used before values are retrieved.
            </remarks>
        </member>
        <member name="P:GoRogue.FOV.FOVBooleanToDoubleTranslationView.Width">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.FOV.FOVBooleanToDoubleTranslationView.Height">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.FOV.FOVBooleanToDoubleTranslationView.Item(SadRogue.Primitives.Point)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBooleanToDoubleTranslationView.#ctor(GoRogue.FOV.IReadOnlyFOV)">
            <summary>
            Constructor.
            </summary>
            <param name="parent">The <see cref="T:GoRogue.FOV.IReadOnlyFOV"/> instance for which this grid view is producing double values.</param>
        </member>
        <member name="T:GoRogue.FOV.BooleanBasedFOVBase">
             <summary>
             Base class which is convenient for defining FOV algorithms which produce an array of booleans as output, and thus they derive
             their <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/> values from the boolean values, by making the double value returned a function of distance from
             the origin relative to radius.
             </summary>
             <remarks>
             This class inherits from <see cref="T:GoRogue.FOV.FOVBase"/>, and all the caveats mentioned in its remarks section should apply.  If you instead
             want to define an FOV algorithm as returning double values, and deriving boolean from that, you can use <see cref="T:GoRogue.FOV.DoubleBasedFOVBase"/>
             instead.  If neither of those use cases fits your situation, feel free to use <see cref="T:GoRogue.FOV.FOVBase"/> or <see cref="T:GoRogue.FOV.IFOV"/> directly.
            
             Although it can vary by implementation, if all other things are equal, classes that use this implementation as opposed to <see cref="T:GoRogue.FOV.DoubleBasedFOVBase"/>
             generally tend to take up less memory, however they may take more time to retrieve values from <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/>.
             Retrieving values from <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/> is generally faster than from DoubleResultView, since the double values are derived
             from the boolean values.
            
             Although using <see cref="T:GoRogue.FOV.DoubleBasedFOVBase"/> is usually a better default, the tradeoffs of this method can be good for extremely large maps, especially
             when CalculateAppend isn't used much and/or only BooleanResultView is primarily used.
            
             Library implementations typically provide versions of any given algorithm defined via both this class and <see cref="T:GoRogue.FOV.DoubleBasedFOVBase"/> where possible.
             </remarks>
        </member>
        <member name="P:GoRogue.FOV.BooleanBasedFOVBase.DoubleResultView">
            <inheritdoc />
        </member>
        <member name="F:GoRogue.FOV.BooleanBasedFOVBase.ResultView">
            <summary>
            View in which the results of LOS calculations are stored.  The values in this view are used to derive
            the public result views.
            </summary>
            <remarks>
            The requirements for these values are identical to <see cref="P:GoRogue.FOV.BooleanBasedFOVBase.BooleanResultView"/>.  BooleanResultView simply
            exposes these values directly; DoubleResultView returns 0 for any location where BooleanResultView returns false,
            and otherwise returns a non-0 double that is a function of distance/falloff from the source (a value in range (0, 1]).
            </remarks>
        </member>
        <member name="P:GoRogue.FOV.BooleanBasedFOVBase.BooleanResultView">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.FOV.BooleanBasedFOVBase.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean})">
            <summary>
            Constructor.
            </summary>
            <param name="transparencyView">
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </param>
            <param name="resultView">The view in which FOV calculations are stored.</param>
        </member>
        <member name="T:GoRogue.FOV.DoubleBasedFOVBase">
             <summary>
             Base class which is convenient for defining FOV algorithms which produce an array of doubles as output, and thus they derive
             their <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/> values from the double values (anything greater than 0 is true).
             </summary>
             <remarks>
             This class inherits from <see cref="T:GoRogue.FOV.FOVBase"/>, and all the caveats mentioned in its remarks section should apply.  If you instead
             want to define an FOV algorithm as returning boolean values, and deriving doubles from that, you can use <see cref="T:GoRogue.FOV.BooleanBasedFOVBase"/>
             instead.  If neither of those use cases fits your situation, feel free to use <see cref="T:GoRogue.FOV.FOVBase"/> or <see cref="T:GoRogue.FOV.IFOV"/> directly.
            
             Although it can vary by implementation, if all other things are equal, classes that use this implementation as opposed to <see cref="T:GoRogue.FOV.BooleanBasedFOVBase"/>
             generally tend to take up more memory, however they will generally be able to retrieve values from <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/> more quickly.
             Retrieving values from <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/> can be slightly slower than from DoubleResultView, since the boolean values are derived
             from the double values.
             </remarks>
        </member>
        <member name="F:GoRogue.FOV.DoubleBasedFOVBase.ResultView">
            <summary>
            View in which the results of LOS calculations are stored.  The values in this view are used to derive
            the public result views.
            </summary>
            <remarks>
            The requirements for these values are identical to <see cref="P:GoRogue.FOV.DoubleBasedFOVBase.DoubleResultView"/>.  DoubleResultView simply
            exposes these values directly; BooleanResultView considers any location where ResultView > 0 to be true.
            </remarks>
        </member>
        <member name="P:GoRogue.FOV.DoubleBasedFOVBase.DoubleResultView">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.FOV.DoubleBasedFOVBase.BooleanResultView">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.FOV.DoubleBasedFOVBase.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.GridViews.ISettableGridView{System.Double})">
            <summary>
            Constructor.
            </summary>
            <param name="transparencyView">
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </param>
            <param name="resultView">The view in which FOV calculations are stored.</param>
        </member>
        <member name="T:GoRogue.FOV.FOVBase">
             <summary>
             Base class that is convenient for creating custom implementations of the <see cref="T:GoRogue.FOV.IFOV"/> interface.
             </summary>
             <remarks>
             This class implements much of the boilerplate code required to implement <see cref="T:GoRogue.FOV.IFOV"/> properly, making
             sure that the implementer has to implement only the minimal subset of functions and properties.
            
             An implementer should implement the OnCalculate overloads to perform their FOV calculation.  Notably, these
             functions SHOULD NOT call <see cref="M:GoRogue.FOV.FOVBase.Reset"/> nor perform any equivalent functionality, and SHOULD NOT
             fire the <see cref="E:GoRogue.FOV.FOVBase.Recalculated"/> or <see cref="E:GoRogue.FOV.FOVBase.VisibilityReset"/> events.  All of this is taken care of
             by the Calculate and CalculateAppend functions, which call OnCalculate.
            
             The implementation of OnCalculate, therefore, must not make any assumptions that squares start at a light level
             of 0, or any other light level.  It should responsibly handle overlapping with other values, an assume that any
             value it does see at a location is a valid one.  Therefore, the highest of the number currently present and the
             new number should always be kept.
             </remarks>
        </member>
        <member name="P:GoRogue.FOV.FOVBase.TransparencyView">
            <inheritdoc/>
        </member>
        <member name="E:GoRogue.FOV.FOVBase.Recalculated">
            <inheritdoc/>
        </member>
        <member name="E:GoRogue.FOV.FOVBase.VisibilityReset">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.FOV.FOVBase.CalculationsPerformed">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.FOV.FOVBase.CurrentFOV">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.FOV.FOVBase.NewlySeen">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.FOV.FOVBase.NewlyUnseen">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean})">
            <summary>
            Constructor.
            </summary>
            <param name="transparencyView">
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </param>
        </member>
        <member name="P:GoRogue.FOV.FOVBase.BooleanResultView">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.FOV.FOVBase.DoubleResultView">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.FOV.FOVBase.AsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.FOV.FOVBase.OnCalculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and radius shape.
            </summary>
            <remarks>
            Custom implementations would implement this function to perform their calculation; the Calculate functions
            call this then fire relevant events.
            </remarks>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.OnCalculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle" /> and <paramref name="span" />.  The resulting field of view,
            if unobstructed, will be a cone defined by the angle and span given.
            </summary>
            <remarks>
            Custom implementations would implement this function to perform their calculation; the Calculate functions
            call this then fire relevant events.
            </remarks>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points up, and angle increases result in the cone moving clockwise (like a compass).
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.OnReset">
            <summary>
            Resets all cells to not visible, and cycles current FOV to previous FOV, allowing a fresh set of
            calculations to begin.
            </summary>
            <remarks>
            This is (indirectly) called automatically by all Calculate overloads.  Custom implementations should
            implement this to reset their ResultView to all 0's in a way appropriate for their architecture, as well
            as cycle the current FOV to the previous FOV to prepare for a fresh FOV calculation.
            <see cref="M:GoRogue.FOV.FOVBase.Reset"/> also calls this function, along with firing relevant events.
            </remarks>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Calculate(System.Int32,System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.CalculateAppend(System.Int32,System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Calculate(SadRogue.Primitives.Point,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.CalculateAppend(SadRogue.Primitives.Point,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Calculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.CalculateAppend(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Calculate(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.CalculateAppend(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Calculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.CalculateAppend(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Calculate(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.CalculateAppend(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.Reset">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.ToString(System.Char,System.Char)">
            <summary>
            ToString overload that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in FOV.</param>
            <param name="sourceValue">The character used for any location that is in FOV.</param>
            <returns>The string representation of FOV, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the FOV, rounded to
            the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>A string representation of FOV, rounded to the given number of decimal places.</returns>
        </member>
        <member name="M:GoRogue.FOV.FOVBase.ToString">
            <summary>
            Returns a string representation of the map, where any location not in FOV is represented
            by a '-' character, and any position in FOV is represented by a '+'.
            </summary>
            <returns>A (multi-line) string representation of the FOV.</returns>
        </member>
        <member name="T:GoRogue.FOV.FOVCalculateParameters">
            <summary>
            Represents a set of parameters that were passed to a call to Calculate.
            </summary>
        </member>
        <member name="F:GoRogue.FOV.FOVCalculateParameters.Origin">
            <summary>
            Position of the FOV origin point.
            </summary>
        </member>
        <member name="F:GoRogue.FOV.FOVCalculateParameters.Radius">
            <summary>
            The maximum radius -- eg. the maximum distance of the field of view if completely unobstructed.
            </summary>
        </member>
        <member name="F:GoRogue.FOV.FOVCalculateParameters.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </summary>
        </member>
        <member name="F:GoRogue.FOV.FOVCalculateParameters.Angle">
            <summary>
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points upward, and increases move clockwise (like a compass)
            </summary>
        </member>
        <member name="F:GoRogue.FOV.FOVCalculateParameters.Span">
            <summary>
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <see cref="F:GoRogue.FOV.FOVCalculateParameters.Span"/> / 2 degrees are included on either side of the span line.
            </summary>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <summary>
            Constructor.
            </summary>
            <param name="origin">Position of the FOV origin point.</param>
            <param name="radius">The maximum radius -- eg. the maximum distance of the field of view if completely unobstructed.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points up, and increases move the cone clockwise (like a compass).
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="span"/>> / 2 degrees are included on either side of the span line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.Deconstruct(SadRogue.Primitives.Point@,System.Double@,SadRogue.Primitives.Distance@,System.Double@,System.Double@)">
            <summary>
            Supports C# Deconstruction syntax.
            </summary>
            <param name="origin"/>
            <param name="radius"/>
            <param name="distanceCalc"/>
            <param name="angle"/>
            <param name="span"/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.op_Implicit(GoRogue.FOV.FOVCalculateParameters)~System.ValueTuple{SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double}">
            <summary>
            Implicitly converts an FOVCalculateParameters object to an equivalent tuple.
            </summary>
            <param name="pair"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.op_Implicit(System.ValueTuple{SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double})~GoRogue.FOV.FOVCalculateParameters">
            <summary>
            Implicitly converts a tuple to its equivalent FOVCalculateParameters.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.ToTuple">
            <summary>
            Converts this FOVCalculateParameters object to an equivalent tuple.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.FromTuple(System.ValueTuple{SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double})">
            <summary>
            Converts the tuple to an equivalent FOVCalculateParameters object.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.Equals(GoRogue.FOV.FOVCalculateParameters)">
            <summary>
            True if the given objects have the same parameter values; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.Matches(GoRogue.FOV.FOVCalculateParameters)">
            <summary>
            True if the given object has the same parameter values; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.Equals(System.Object)">
            <summary>
            True if the given object is a FOVCalculateParameters and has the same parameter values; false otherwise.
            </summary>
            <param name="obj"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.GetHashCode">
            <summary>
            Returns a hash code based on all of the object's fields.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.op_Equality(GoRogue.FOV.FOVCalculateParameters,GoRogue.FOV.FOVCalculateParameters)">
            <summary>
            True if the given objects have the same parameter values; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="M:GoRogue.FOV.FOVCalculateParameters.op_Inequality(GoRogue.FOV.FOVCalculateParameters,GoRogue.FOV.FOVCalculateParameters)">
            <summary>
            True if the given objects have different parameter values; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="T:GoRogue.FOV.FOVRecalculatedEventArgs">
            <summary>
            Arguments for event fired when FOV is recalculated.
            </summary>
        </member>
        <member name="F:GoRogue.FOV.FOVRecalculatedEventArgs.CalculateParameters">
            <summary>
            The parameters (implicit and explicit) given to the Calculate call which triggered the event.
            </summary>
        </member>
        <member name="M:GoRogue.FOV.FOVRecalculatedEventArgs.#ctor(GoRogue.FOV.FOVCalculateParameters)">
            <summary>
            Create and configure the event argument object.
            </summary>
            <param name="calculateParameters">The parameters given to the calculate function (explicit and implicit).</param>
        </member>
        <member name="T:GoRogue.FOV.IFOV">
             <summary>
             Interface representing the capability to calculate a grid-based field of view for a map.
             </summary>
             <remarks>
             If you want a concrete implementation of FOV, see the <see cref="T:GoRogue.FOV.RecursiveShadowcastingFOV"/> class.  If you're implementing your
             own FOV system, you may want to consider inheriting from <see cref="T:GoRogue.FOV.FOVBase"/> if possible, as it implements
             much of the boilerplate code involved in implementing this interface.
            
             This interface conceptualizes FOV as a calculation based on a "transparency" map, represented by the
             <see cref="P:GoRogue.FOV.IReadOnlyFOV.TransparencyView"/> property.  This view acts as input to the calculation; a value of
             "true" indicates that a given position is transparent (i.e. does NOT block LOS), whereas a value of "false"
             indicates that a position DOES block line of sight.
            
             The calculation will be performed by the Calculate functions.  It should perform calculations such that
             the following fields produce the correct output (which is noted in the property documentation):
                 - <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/>
                 - <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/>
                 - <see cref="P:GoRogue.FOV.IReadOnlyFOV.CurrentFOV"/>
                 - <see cref="P:GoRogue.FOV.IReadOnlyFOV.NewlySeen"/>
                 - <see cref="P:GoRogue.FOV.IReadOnlyFOV.NewlyUnseen"/>
            
             The Calculate functions should also fire the <see cref="E:GoRogue.FOV.IFOV.Recalculated"/> event.
            
             Some of the output values can be derived based on others; for example, by definition, BooleanResultView should
             simply return true for any square where DoubleResultView returns a value > 0.0.  For this reason, as stated above,
             it is recommended that custom implementations inherit from <see cref="T:GoRogue.FOV.FOVBase"/> where possible, as it sets this
             all up correctly, and instead requires that you implement the minimal subset of properties/functions.
             </remarks>
        </member>
        <member name="E:GoRogue.FOV.IFOV.Recalculated">
            <summary>
            Fired whenever the FOV is recalculated.
            </summary>
        </member>
        <member name="E:GoRogue.FOV.IFOV.VisibilityReset">
            <summary>
            Fired when the existing FOV is reset prior to calculating a new one.
            </summary>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Calculate(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculates FOV given an origin point and a radius, overwriting the current FOV entirely. If no radius is
            specified, simply calculates with a radius of maximum integer value, which is effectively infinite. Radius
            is computed as a circle around the source (type <see cref="F:SadRogue.Primitives.Radius.Circle" />).
            </summary>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.CalculateAppend(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculates FOV given an origin point and a radius, adding the result onto the currently visible cells. If no
            radius is specified, simply calculates with a radius of maximum integer value, which is effectively infinite.
            Radius is computed as a circle around the source (type <see cref="F:SadRogue.Primitives.Radius.Circle" />).
            </summary>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Calculate(SadRogue.Primitives.Point,System.Double)">
            <summary>
            Calculates FOV given an origin point and a radius, overwriting the current FOV entirely. If no radius is
            specified, simply calculates with a radius of maximum integer value, which is effectively infinite.
            Radius is computed as a circle around the source (type <see cref="F:SadRogue.Primitives.Radius.Circle" />).
            </summary>
            <param name="origin">Position of origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.CalculateAppend(SadRogue.Primitives.Point,System.Double)">
            <summary>
            Calculates FOV given an origin point and a radius, adding the result onto the currently visible cells. If no
            radius is specified, simply calculates with a radius of maximum integer value, which is effectively infinite.
            Radius is computed as a circle around the source (type <see cref="F:SadRogue.Primitives.Radius.Circle" />).
            </summary>
            <param name="origin">Position of origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Calculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and radius shape, overwriting the current FOV entirely.
            </summary>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.CalculateAppend(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and radius shape, adding the result onto the currently
            visible cells.
            </summary>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Calculate(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and a radius shape, overwriting the current FOV entirely.
            </summary>
            <param name="origin">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.CalculateAppend(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance)">
            <summary>
            Calculates FOV given an origin point, a radius, and a radius shape, , adding the result onto the currently
            visible cells.
            </summary>
            <param name="origin">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Calculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle" /> and <paramref name="span" />.  The current field of view will be
            entirely overwritten with the new one.  The resulting field of view, if unobstructed, will be a cone defined
            by the angle and span given.
            </summary>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points up, and angle increases result in the cone moving clockwise (like a compass).
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.CalculateAppend(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle" /> and <paramref name="span" />.  The new field of view will be
            added onto the current one.  The resulting field of view, if unobstructed, will be a cone defined
            by the angle and span given.
            </summary>
            <param name="originX">Coordinate x-value of the origin.</param>
            <param name="originY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points up, and angle increases result in the cone moving clockwise (like a compass).
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Calculate(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle" /> and <paramref name="span" />.  The current field of view will be
            entirely overwritten with the new one.  The resulting field of view,
            if unobstructed, will be a cone defined by the angle and span given.
            </summary>
            <param name="origin">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points up, and angle increases result in the cone moving clockwise (like a compass).
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle" /> / 2 degrees are included on either side of the span line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.CalculateAppend(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV given an origin point, a radius, a radius shape, and the given field of view
            restrictions <paramref name="angle" /> and <paramref name="span" />.  The new field of view will be
            added onto the current one.  The resulting field of view, if unobstructed, will be a cone defined by the
            angle and span given.
            </summary>
            <param name="origin">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of the field of view if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, eg. <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the field of view cone. 0 degrees
            points up, and angle increases result in the cone moving clockwise (like a compass).
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the field of view cone --
            <paramref name="angle" /> / 2 degrees are included on either side of the span line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.IFOV.Reset">
            <summary>
            Resets the given field of view to no tiles visible.
            </summary>
            <remarks>
            After this function is called, any value in <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/> will be 0, and any
            value in <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/> will be false.  Additionally,
            <see cref="P:GoRogue.FOV.IReadOnlyFOV.CurrentFOV"/> will be blank.
            </remarks>
        </member>
        <member name="T:GoRogue.FOV.IReadOnlyFOV">
            <summary>
            Read-only interface of <see cref="T:GoRogue.FOV.IFOV" />.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.TransparencyView">
            <summary>
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView">
            <summary>
            A view of the calculation results in boolean form, where true indicates a location is in
            field of view, and false indicates it is not.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView">
            <summary>
            A view of the calculation results in double form, where a value greater than 0.0 indicates that the value
            is inside of FOV, and a value of 1.0 indicates the center point.  All other values vary between 0.0 and
            1.0, decreasing as positions get farther away from the center point.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.CurrentFOV">
            <summary>
            IEnumerable of only positions currently in the field of view.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.NewlySeen">
            <summary>
            IEnumerable of positions that ARE in field of view as of the most current Calculate call, but were
            NOT in field of view after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.NewlyUnseen">
            <summary>
            IEnumerable of positions that are NOT in field of view as of the most current Calculate call, but
            WERE in field of view after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.IReadOnlyFOV.CalculationsPerformed">
            <summary>
            A list of the parameters passed to each call to Calculate/CalculateAppend that has been performed since the last reset, in the order in which
            they were called.
            </summary>
        </member>
        <member name="M:GoRogue.FOV.IReadOnlyFOV.AsReadOnly">
            <summary>
            Returns a read-only representation of the field of view.
            </summary>
            <returns>This FOV object, as an <see cref="T:GoRogue.FOV.IReadOnlyFOV" /> instance.</returns>
        </member>
        <member name="M:GoRogue.FOV.IReadOnlyFOV.ToString(System.Char,System.Char)">
            <summary>
            ToString overload that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in FOV.</param>
            <param name="sourceValue">The character used for any location that is in FOV.</param>
            <returns>The string representation of FOV, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.FOV.IReadOnlyFOV.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the FOV, rounded to
            the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>A string representation of FOV, rounded to the given number of decimal places.</returns>
        </member>
        <member name="T:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV">
             <summary>
             An alternative implementation of <see cref="T:GoRogue.FOV.RecursiveShadowcastingFOV"/> which generates boolean values as the output of the FOV algorithm,
             rather than generating doubles and translating to booleans as needed.  It still implements <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/>, but those values
             are calculated on the fly from the boolean values, rather than the other way around.  These differences have performance implications that can make this
             algorithm more suitable for some scenarios (see remarks).
             </summary>
             <remarks>
             This implementation will retrieve values from <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/> more quickly than <see cref="T:GoRogue.FOV.RecursiveShadowcastingFOV"/>,
             However, retrieving values from <see cref="P:GoRogue.FOV.IReadOnlyFOV.DoubleResultView"/> is, generally slower; _much_ slower, in particular, if there are multiple FOV sources
             being appended together via multiple calls to CalculateAppend.  It will, however, take up significantly less memory for large maps.
            
             These tradeoffs, therefore, make this variation particularly suited to situations where you primarily make use of the <see cref="P:GoRogue.FOV.IReadOnlyFOV.BooleanResultView"/>
             property, or when your map is very large and you wish to reduce the memory consumption of the object.
             </remarks>
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})">
            <summary>
            Constructor.
            </summary>
            <param name="transparencyView">
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </param>
            <param name="hasher">The hashing algorithm to use for points in hash sets.  Defaults to the default hash algorithm for Points.</param>
        </member>
        <member name="P:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.CurrentFOV">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.NewlySeen">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.NewlyUnseen">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.OnCalculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.OnCalculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV.OnReset">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.FOV.RecursiveShadowcastingFOV">
            <summary>
            Implements <see cref="T:GoRogue.FOV.IFOV"/> by using a recursive shadow-casting implementation.
            </summary>
            <remarks>
            Compared to the functionally equivalent implementation of recursive shadowcasting, <see cref="T:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV"/>, this version
            is usually a reasonable default.  However, this version can take up a great deal of memory for large maps; in these cases, you may prefer
            <see cref="T:GoRogue.FOV.RecursiveShadowcastingBooleanBasedFOV"/> instead.
            </remarks>
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingFOV.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})">
            <summary>
            Constructor.
            </summary>
            <param name="transparencyView">
            The values used to calculate field of view. Values of true are considered
            non-blocking (transparent) to line of sight, while false values are considered
            to be blocking.
            </param>
            <param name="hasher">The hashing algorithm to use for points in hash sets.  Defaults to the default hash algorithm for Points.</param>
        </member>
        <member name="P:GoRogue.FOV.RecursiveShadowcastingFOV.CurrentFOV">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.FOV.RecursiveShadowcastingFOV.NewlySeen">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.FOV.RecursiveShadowcastingFOV.NewlyUnseen">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingFOV.OnCalculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingFOV.OnCalculate(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.FOV.RecursiveShadowcastingFOV.OnReset">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.GameFramework.GameObject">
            <summary>
            Concrete implementation of <see cref="T:GoRogue.GameFramework.IGameObject"/> that works for most use cases.
            </summary>
            <remarks>
            Any component collection implementing the proper interface may be passed in at construction and used as the
            <see cref="P:GoRogue.GameFramework.GameObject.GoRogueComponents"/> property value, however by default a <see cref="T:GoRogue.Components.ComponentCollection"/> is used,
            and thus will accept components of any type and will properly support <see cref="T:GoRogue.Components.ISortedComponent"/>.
            </remarks>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.#ctor(SadRogue.Primitives.Point,System.Int32,System.Boolean,System.Boolean,System.Func{System.UInt32},GoRogue.Components.IComponentCollection)">
            <summary>
            Constructor.
            </summary>
            <remarks>
            <paramref name="idGenerator" /> is used to generate an ID which is assigned to the <see cref="P:GoRogue.GameFramework.GameObject.ID"/>
            field. When null is specified, the constructor simply assigns a random number in range of valid uints. This
            is sufficiently distinct for the purposes of placing the objects in an <see cref="T:SadRogue.Primitives.SpatialMaps.ISpatialMap`1" />
            implementation, however obviously does NOT guarantee true uniqueness. If uniqueness or some other
            implementation is required, override this function to return an appropriate ID. Keep in mind a relatively
            high degree of uniqueness is necessary for efficient placement in an ISpatialMap implementation.
            </remarks>
            <param name="position">Position to start the object at.</param>
            <param name="layer">The layer of of a <see cref="T:GoRogue.GameFramework.Map" /> the object is assigned to.</param>
            <param name="isWalkable">
            Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same <see cref="T:GoRogue.GameFramework.Map" />.  Effectively, whether or
            not this object collides.
            </param>
            <param name="isTransparent">
            Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of calculating the FOV of a <see cref="T:GoRogue.GameFramework.Map" />.
            </param>
            <param name="idGenerator">
            The function used to generate and return an unsigned integer to use assign to the <see cref="P:GoRogue.GameFramework.GameObject.ID" /> field.
            Most of the time, you will not need to specify this as the default implementation will be sufficient.  See
            the constructor remarks for details.
            </param>
            <param name="customComponentCollection">
            A custom component collection to use for objects.  If not specified, a <see cref="T:GoRogue.Components.ComponentCollection"/> is
            used.  Typically you will not need to specify this, as a ComponentCollection is sufficient for nearly all
            use cases.
            </param>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.#ctor(System.Int32,System.Boolean,System.Boolean,System.Func{System.UInt32},GoRogue.Components.IComponentCollection)">
            <summary>
            Constructor.
            </summary>
            <remarks>
            <paramref name="idGenerator" /> is used to generate an ID which is assigned to the <see cref="P:GoRogue.GameFramework.GameObject.ID"/>
            field. When null is specified, the constructor simply assigns a random number in range of valid uints. This
            is sufficiently distinct for the purposes of placing the objects in an <see cref="T:SadRogue.Primitives.SpatialMaps.ISpatialMap`1" />
            implementation, however obviously does NOT guarantee true uniqueness. If uniqueness or some other
            implementation is required, override this function to return an appropriate ID. Keep in mind a relatively
            high degree of uniqueness is necessary for efficient placement in an ISpatialMap implementation.
            </remarks>
            <param name="layer">The layer of of a <see cref="T:GoRogue.GameFramework.Map" /> the object is assigned to.</param>
            <param name="isWalkable">
            Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same <see cref="T:GoRogue.GameFramework.Map" />.  Effectively, whether or
            not this object collides.
            </param>
            <param name="isTransparent">
            Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of calculating the FOV of a <see cref="T:GoRogue.GameFramework.Map" />.
            </param>
            <param name="idGenerator">
            The function used to generate and return an unsigned integer to use assign to the <see cref="P:GoRogue.GameFramework.GameObject.ID" /> field.
            Most of the time, you will not need to specify this as the default implementation will be sufficient.  See
            the constructor remarks for details.
            </param>
            <param name="customComponentCollection">
            A custom component collection to use for objects.  If not specified, a <see cref="T:GoRogue.Components.ComponentCollection"/> is
            used.  Typically you will not need to specify this, as a ComponentCollection is sufficient for nearly all
            use cases.
            </param>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.Position">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.PositionChanging">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.PositionChanged">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.IsWalkable">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.WalkabilityChanging">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.WalkabilityChanged">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.IsTransparent">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.TransparencyChanging">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.TransparencyChanged">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.ID">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.Layer">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.CurrentMap">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.AddedToMap">
            <inheritdoc />
        </member>
        <member name="E:GoRogue.GameFramework.GameObject.RemovedFromMap">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.GameObject.GoRogueComponents">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.GameFramework.GameObject.OnMapChanged(GoRogue.GameFramework.Map)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.GameFramework.GameObjectCurrentMapChanged">
            <summary>
            Event arguments for events fired when an <see cref="T:GoRogue.GameFramework.IGameObject"/> is added
            to/removed from a <see cref="F:GoRogue.GameFramework.GameObjectCurrentMapChanged.Map"/>.
            </summary>
        </member>
        <member name="F:GoRogue.GameFramework.GameObjectCurrentMapChanged.Map">
            <summary>
            The map that the object was added to/removed from.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.GameObjectCurrentMapChanged.#ctor(GoRogue.GameFramework.Map)">
            <summary>
            Creates a new argument for events.
            </summary>
            <param name="map">Map the object was added to/removed from.</param>
        </member>
        <member name="T:GoRogue.GameFramework.IGameObject">
             <summary>
             Base interface required for any object that has a grid position and can be added to a <see cref="T:GoRogue.GameFramework.Map" />.
             Implements basic attributes generally common to all objects on a map, as well as properties/methods that
             <see cref="T:GoRogue.GameFramework.Map"/> needs to function.  It also provides a container that you may attach arbitrary components to
             (via the <see cref="T:GoRogue.Components.ParentAware.IObjectWithComponents"/> interface).
            
             For a concrete implementation, see <see cref="T:GoRogue.GameFramework.GameObject"/>.
             </summary>
             <remarks>
             Generally, you can use <see cref="T:GoRogue.GameFramework.GameObject"/> instead of implementing this interface directly.  However, if
             the need to avoid inheritance or change that implementation arises, please note that the interface contains
             events that you must fire appropriately when the corresponding property implementations are changed.
             GoRogue defines helper methods for this; it is recommended that you use GameObject as an example.
            
             Regardless of what implementation is used, however, if <see cref="T:GoRogue.Components.ComponentCollection"/> (or some other custom
             collection implementing the proper functionality) is used, this object provides support for its components to
             (optionally) implement <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/>, or inherit from <see cref="T:GoRogue.Components.ParentAware.ParentAwareComponentBase"/>.
             In this case, the <see cref="P:GoRogue.Components.ParentAware.IParentAwareComponent.Parent"/> will be updated automatically as components are added/
             removed.  Typically, you will want to inherit your components from <see cref="T:GoRogue.Components.ParentAware.ParentAwareComponentBase`1"/>,
             where TParent would be IGameObject or some class implementing that interface.
             </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.CurrentMap">
            <summary>
            The current <see cref="T:GoRogue.GameFramework.Map" /> which this object resides on.  Returns null if the object has not been added to a map.
            An IGameObject is allowed to reside on only one map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.AddedToMap">
            <summary>
            Fired when the object is added to a map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.RemovedFromMap">
            <summary>
            Fired when the object is removed from a map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.IsTransparent">
            <summary>
            Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of calculating FOV.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.TransparencyChanging">
            <summary>
            Fired when <see cref="P:GoRogue.GameFramework.IGameObject.IsTransparent"/> is about to be changed.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.TransparencyChanged">
            <summary>
            Fired when <see cref="P:GoRogue.GameFramework.IGameObject.IsTransparent"/> is changed.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.IGameObject.IsWalkable">
            <summary>
            Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same <see cref="T:GoRogue.GameFramework.Map" />.  Effectively, whether or
            not this object collides.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.WalkabilityChanging">
            <summary>
            Fired when <see cref="P:GoRogue.GameFramework.IGameObject.IsWalkable"/> is about to changed.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.IGameObject.WalkabilityChanged">
            <summary>
            Fired when <see cref="P:GoRogue.GameFramework.IGameObject.IsWalkable"/> is changed.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.IGameObject.OnMapChanged(GoRogue.GameFramework.Map)">
            <summary>
            Internal use only, do not call manually!  Must, at minimum, call <see cref="M:GoRogue.GameFramework.GameObjectExtensions.SafelySetCurrentMap(GoRogue.GameFramework.IGameObject,GoRogue.GameFramework.Map@,GoRogue.GameFramework.Map,System.EventHandler{GoRogue.GameFramework.GameObjectCurrentMapChanged},System.EventHandler{GoRogue.GameFramework.GameObjectCurrentMapChanged})"/>
            which will update the <see cref="P:GoRogue.GameFramework.IGameObject.CurrentMap" /> field of the IGameObject to reflect the change and fire map
            added/removed events as appropriate (or provide equivalent functionality).
            </summary>
            <param name="newMap">New map to which the IGameObject has been added.</param>
        </member>
        <member name="T:GoRogue.GameFramework.GameObjectExtensions">
            <summary>
            A collection of helpful extension methods for <see cref="T:GoRogue.GameFramework.IGameObject"/> instances.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.GameObjectExtensions.CanMove(GoRogue.GameFramework.IGameObject,SadRogue.Primitives.Point)">
            <summary>
            Returns true if the object can be moved to the location specified; false otherwise.
            </summary>
            <remarks>
            This function should return false in exactly any case where setting the <see cref="P:SadRogue.Primitives.IPositionable.Position" />
            property to the value specified would fail.
            </remarks>
            <param name="self" />
            <param name="position">The position to check.</param>
            <returns>True if the object can be moved to the specified position; false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObjectExtensions.CanMoveIn(GoRogue.GameFramework.IGameObject,SadRogue.Primitives.Direction)">
            <summary>
            Returns true if the object can move in the given direction; false otherwise.
            </summary>
            <remarks>
            See remarks in documentation for <see cref="M:GoRogue.GameFramework.GameObjectExtensions.CanMove(GoRogue.GameFramework.IGameObject,SadRogue.Primitives.Point)" /> for details
            on when this function should return false.
            </remarks>
            <param name="self" />
            <param name="direction">The direction of movement to check.</param>
            <returns>True if the object can be moved in the specified direction; false otherwise</returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObjectExtensions.CanSetWalkability(GoRogue.GameFramework.IGameObject,System.Boolean)">
            <summary>
            Returns true if the object can set its <see cref="P:GoRogue.GameFramework.IGameObject.IsWalkable"/> property to the specified
            value; false otherwise.
            </summary>
            <remarks>
            This returns true unless the new value would violate collision detection rules of a map.
            </remarks>
            <param name="self" />
            <param name="value">The new value for walkability to check.</param>
            <returns>
            True if the object can set its walkability to the given value without violating a map's collision detection,
            false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObjectExtensions.CanToggleWalkability(GoRogue.GameFramework.IGameObject)">
            <summary>
            Returns true if the object can toggle its <see cref="P:GoRogue.GameFramework.IGameObject.IsWalkable"/> property; false otherwise.
            </summary>
            <param name="self" />
            <returns>
            True if the object can toggle its walkability without violating a map's collision detection,
            false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObjectExtensions.SafelySetCurrentMap(GoRogue.GameFramework.IGameObject,GoRogue.GameFramework.Map@,GoRogue.GameFramework.Map,System.EventHandler{GoRogue.GameFramework.GameObjectCurrentMapChanged},System.EventHandler{GoRogue.GameFramework.GameObjectCurrentMapChanged})">
             <summary>
             Sets the given map field to the given value, and fires the AddedToMap event and RemovedFromMap
             event as necessary.
             </summary>
             <remarks>
             This is a convenience function to set the backing field for <see cref="P:GoRogue.GameFramework.IGameObject.CurrentMap"/>
             correctly, ensuring exceptions are handled and that events are fired properly.  Generally, this should
             only be called from within an implementation of <see cref="M:GoRogue.GameFramework.IGameObject.OnMapChanged(GoRogue.GameFramework.Map)"/>.
            
             See the implementation of <see cref="M:GoRogue.GameFramework.GameObject.OnMapChanged(GoRogue.GameFramework.Map)"/> for an example of intended use.
             </remarks>
             <param name="self" />
             <param name="currentMapField">Map field to set.</param>
             <param name="newValue">New value to set to the map field.</param>
             <param name="addedEvent">The <see cref="E:GoRogue.GameFramework.IGameObject.AddedToMap"/> event for the object whose map is being changed.</param>
             <param name="removedEvent">The <see cref="E:GoRogue.GameFramework.IGameObject.RemovedFromMap"/> event for the object whose map is being changed.</param>
        </member>
        <member name="T:GoRogue.GameFramework.Map">
             <summary>
             Base class for a map that consists of one or more objects of base type <see cref="T:GoRogue.GameFramework.IGameObject" />.  It
             implements basic functionality to manage and access these objects, as well as commonly needed functionality like
             tile exploration, FOV, and pathfinding.  It also provides methods to easily access these objects as instances of
             some derived type.  This can be used to easily access functionality you've implemented in a subclass.  Finally,
             it provides the ability to attach components to the map.
             </summary>
             <remarks>
             A Map consists of <see cref="T:GoRogue.GameFramework.IGameObject" /> instances on one or more layers.  These layers are numbered, from
             the lowest layer of 0 upward.  Each Map contains at minimum a layer 0, which is considered the "terrain" layer.
             All objects added to this layer cannot move while they are added to a map; though they can move when they aren't
             a part of any map.
            
             A map will typically also have some other layers, for non-terrain objects like monsters, items, etc.  The number
             of these layers present on the map, along with which of all the layers participate in collision detection, etc.,
             can be specified in the constructor.
            
             If <see cref="T:GoRogue.Components.ComponentCollection"/> (or some other custom collection implementing the proper functionality) is
             used, as the component collection, this object provides support for its components to (optionally) implement
             <see cref="T:GoRogue.Components.ParentAware.IParentAwareComponent"/>, or inherit from <see cref="T:GoRogue.Components.ParentAware.ParentAwareComponentBase"/>.
             In this case, the <see cref="P:GoRogue.Components.ParentAware.IParentAwareComponent.Parent"/> will be updated automatically as components are added/
             removed.  Typically, you will want to inherit your components from <see cref="T:GoRogue.Components.ParentAware.ParentAwareComponentBase`1"/>,
             where TParent would be Map or some class inheriting from it.
             </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.Map.PlayerFOV">
            <summary>
            FOV for the player.  By default, calculated based upon <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/>.
            <see cref="F:GoRogue.GameFramework.Map.PlayerExplored"/> is updated automatically when this is calculated.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.GoRogueComponents">
            <inheritdoc/>
        </member>
        <member name="F:GoRogue.GameFramework.Map.PlayerExplored">
            <summary>
            Whether or not each tile is considered explored.  Tiles start off unexplored, and become explored as soon as
            they are within <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/>.  This ArrayView may also have values set to it, to easily allow for
            custom serialization or wizard-mode like functionality.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.Map.#ctor(System.Int32,System.Int32,System.Int32,SadRogue.Primitives.Distance,System.Func{System.Int32,SadRogue.Primitives.Pooling.IListPool{GoRogue.GameFramework.IGameObject}},System.UInt32,System.UInt32,System.UInt32,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point},GoRogue.FOV.IFOV,GoRogue.Pathing.AStar,GoRogue.Components.IComponentCollection,System.Boolean)">
            <summary>
            Constructor.  Constructs terrain map as <see cref="T:SadRogue.Primitives.GridViews.ArrayView`1" />; with the given width/height.
            </summary>
            <param name="width">Width of the map.</param>
            <param name="height">Height of the map.</param>
            <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
            <param name="distanceMeasurement">
            <see cref="T:SadRogue.Primitives.Distance" /> measurement to use for pathfinding/measuring distance on the
            map.
            </param>
            <param name="customListPoolCreator">
            A function used to determine the list pool implementation used for the spatial maps which support multiple
            items in a location (if any).  The function takes the layer it is creating the pool for as a parameter.
            If no custom creator is specified, a ListPool is used.
            </param>
            <param name="layersBlockingWalkability">
            Layer mask containing those layers that should be allowed to have items that block walkability.
            Defaults to all layers.
            </param>
            <param name="layersBlockingTransparency">
            Layer mask containing those layers that should be allowed to have items that block FOV.
            Defaults to all layers.
            </param>
            <param name="entityLayersSupportingMultipleItems">
            Layer mask containing those layers that should be allowed to have multiple objects at the same
            location on the same layer.  Defaults to all layers.
            </param>
            <param name="pointComparer">
            Equality comparer to use for comparison and hashing of points, as object are added to/removed from/moved
            around the map.  Be especially mindful of the efficiency of its GetHashCode function, as it will
            determine the efficiency of many AMap functions.  Defaults to a fast hashing algorithm that generates
            a unique integer for each point based on the width of the map.
            </param>
            <param name="customPlayerFOV">
            Custom FOV to use for <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/>.  Defaults to a GoRogue's recursive shadow-casting
            implementation.  It may also be useful to specify this if you want the <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/> property
            to not use <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> for data.
            </param>
            <param name="customPather">
            Custom A* pathfinder for the map.  Typically, you wont' need to specify this; By default, uses
            <see cref="P:GoRogue.GameFramework.Map.WalkabilityView" /> to determine which locations can be reached, and calculates distance based
            on the <see cref="T:SadRogue.Primitives.Distance" /> passed to the Map in the constructor.
            </param>
            <param name="customComponentCollection">
            A custom component container to use for <see cref="P:GoRogue.GameFramework.Map.GoRogueComponents"/>.  If not specified, a
            <see cref="T:GoRogue.Components.ComponentCollection"/> is used.  Typically you will not need to specify this, as a
            ComponentCollection is sufficient for nearly all use cases.
            </param>
            <param name="useCachedGridViews">
            Whether or not to use cached grid views for <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> and <see cref="P:GoRogue.GameFramework.Map.WalkabilityView"/>,
            rather than calculating values on the fly.  Calculating on the fly is notably slower, but takes up less memory.
            </param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.#ctor(SadRogue.Primitives.GridViews.ISettableGridView{GoRogue.GameFramework.IGameObject},System.Int32,SadRogue.Primitives.Distance,System.Func{System.Int32,SadRogue.Primitives.Pooling.IListPool{GoRogue.GameFramework.IGameObject}},System.UInt32,System.UInt32,System.UInt32,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point},GoRogue.FOV.IFOV,GoRogue.Pathing.AStar,GoRogue.Components.IComponentCollection,System.Boolean)">
             <summary>
             Constructor.  Constructs map with the given terrain layer, determining width/height based on the
             width/height of that terrain layer.  Note that the terrainLayer you pass it is subject to some very specific
             restrictions; see the remarks for details.  Consider using <see cref="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,GoRogue.GameFramework.IGameObject})"/> instead of
             this constructor for more use cases.
             </summary>
             <remarks>
             Because of the way polymorphism works for custom classes in C#, the <paramref name="terrainLayer" />
             parameter MUST be of type <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" />, rather than
             <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> where T is a type that derives from or implements
             <see cref="T:GoRogue.GameFramework.IGameObject" />.  If you need to use a map view storing some type T rather than IGameObject, use
             the <see cref="M:GoRogue.GameFramework.Map.CreateMap``1(SadRogue.Primitives.GridViews.ISettableGridView{``0},System.Int32,SadRogue.Primitives.Distance,System.Func{System.Int32,SadRogue.Primitives.Pooling.IListPool{GoRogue.GameFramework.IGameObject}},System.UInt32,System.UInt32,System.UInt32,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point},GoRogue.FOV.IFOV,GoRogue.Pathing.AStar,GoRogue.Components.IComponentCollection)"/> function to create the map.
            
             Note that this constructor exists pretty much entirely for maximum compatibility; however using it is subject
             to a few restrictions.  Primarily, the <paramref name="terrainLayer"/> given must:
            
             1. Always consist of persistent objects.  This is to say, the layer _cannot_ be creating objects whenever
                they are requested via the indexer.  For example, a SettableLambdaGridView which creates a new GameObject
                based on some other data is NOT a valid <paramref name="terrainLayer"/>.  For this use case,
                <see cref="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,GoRogue.GameFramework.IGameObject})"/> is recommended instead.
            
             2. Always have its values swapped out via <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> function  after it is passed to this
                constructor, rather than via its set indexer.  Basically, the terrain view must not be changed by anything
                other than the map after this constructor takes it.
            
             Violating either of these conditions will create desync bugs that can leave the map in a completely unusable
             state.  Generally, this constructor should be used as a matter of last resort when there isn't a better way
             to accomplish your integration goals.  You should probably prefer the <see cref="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,GoRogue.GameFramework.IGameObject})"/>
             approach until/unless you have a reason not to.
             </remarks>
             <param name="terrainLayer">
             The <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> that represents the terrain layer for this map.  See the remarks
             section for some invariants that _must_ be adhered to regarding this parameter.
             </param>
             <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
             <param name="distanceMeasurement">
             <see cref="T:SadRogue.Primitives.Distance" /> measurement to use for pathfinding/measuring distance on the
             map.
             </param>
             <param name="customListPoolCreator">
             A function used to determine the list pool implementation used for the spatial maps which support multiple
             items in a location (if any).  The function takes the layer it is creating the pool for as a parameter.
             If no custom creator is specified, a ListPool is used.
             </param>
             <param name="layersBlockingWalkability">
             Layer mask containing those layers that should be allowed to have items that block walkability.
             Defaults to all layers.
             </param>
             <param name="layersBlockingTransparency">
             Layer mask containing those layers that should be allowed to have items that block FOV.
             Defaults to all layers.
             </param>
             <param name="entityLayersSupportingMultipleItems">
             Layer mask containing those layers that should be allowed to have multiple objects at the same
             location on the same layer.  Defaults to all layers.
             </param>
             <param name="pointComparer">
             Equality comparer to use for comparison and hashing of points, as object are added to/removed from/moved
             around the map.  Be especially mindful of the efficiency of its GetHashCode function, as it will
             determine the efficiency of many AMap functions.  Defaults to a fast hashing algorithm that generates
             a unique integer for each point based on the width of the map.
             </param>
             <param name="customPlayerFOV">
             Custom FOV to use for <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/>.  Defaults to a GoRogue's recursive shadow-casting
             implementation.  It may also be useful to specify this if you want the <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/> property
             to not use <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> for data.
             </param>
             <param name="customPather">
             Custom A* pathfinder for the map.  Typically, you wont' need to specify this; By default, uses
             <see cref="P:GoRogue.GameFramework.Map.WalkabilityView" /> to determine which locations can be reached, and calculates distance based
             on the <see cref="T:SadRogue.Primitives.Distance" /> passed to the Map in the constructor.
             </param>
             <param name="customComponentCollection">
             A custom component container to use for <see cref="P:GoRogue.GameFramework.Map.GoRogueComponents"/>.  If not specified, a
             <see cref="T:GoRogue.Components.ComponentCollection"/> is used.  Typically you will not need to specify this, as a
             ComponentCollection is sufficient for nearly all use cases.
             </param>
             <param name="useCachedGridViews">
             Whether or not to use cached grid views for <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> and <see cref="P:GoRogue.GameFramework.Map.WalkabilityView"/>,
             rather than calculating values on the fly.  Calculating on the fly is notably slower, but takes up less memory.
             </param>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Terrain">
            <summary>
            Terrain of the map.  Terrain at each location may be set via the <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)" /> function.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Entities">
            <summary>
            <see cref="T:SadRogue.Primitives.SpatialMaps.IReadOnlyLayeredSpatialMap`1" /> of all entities (non-terrain objects) on the map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.LayerMasker">
            <summary>
            <see cref="P:GoRogue.GameFramework.Map.LayerMasker" /> that should be used to create layer masks for this Map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.LayersBlockingWalkability">
            <summary>
            Layer mask that contains only layers that block walkability.  A non-walkable <see cref="T:GoRogue.GameFramework.IGameObject" /> can
            only be added to this map if the layer it resides on is contained within this layer mask.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.LayersBlockingTransparency">
            <summary>
            Layer mask that contains only layers that block transparency.  A non-transparent <see cref="T:GoRogue.GameFramework.IGameObject" />
            can only be added to this map if the layer it is on is contained within this layer mask.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.TransparencyView">
            <summary>
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" /> representing transparency values for each tile.  Each location returns true
            if the location is transparent (there are no non-transparent objects at that location), and false otherwise.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.WalkabilityView">
            <summary>
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" /> representing walkability values for each tile.  Each location is true if
            the location is walkable (there are no non-walkable objects at that location), and false otherwise.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.AStar">
            <summary>
            A* pathfinder for the map.  By default, uses <see cref="P:GoRogue.GameFramework.Map.WalkabilityView" /> to determine which locations can
            be reached, and calculates distance based on the <see cref="T:SadRogue.Primitives.Distance" /> passed to the Map in the constructor.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.DistanceMeasurement">
            <summary>
            <see cref="T:SadRogue.Primitives.Distance" /> measurement used for pathfinding and measuring distance on the map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Height">
            <summary>
            Height of the map, in grid spaces.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Width">
            <summary>
            Width of the map, in grid spaces.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map.Item(SadRogue.Primitives.Point)">
            <summary>
            Gets all objects at the given location, from the highest layer (layer with the highest number) down.
            </summary>
            <param name="pos">The position to retrieve objects for.</param>
            <returns>All objects at the given location, in order from highest layer to lowest layer.</returns>
        </member>
        <member name="E:GoRogue.GameFramework.Map.ObjectAdded">
            <summary>
            Event that is fired whenever some object is added to the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map.ObjectRemoved">
            <summary>
            Event that is fired whenever some object is removed from the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map.ObjectMoved">
            <summary>
            Event that is fired whenever some object that is part of the map is successfully moved.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CreateMap``1(SadRogue.Primitives.GridViews.ISettableGridView{``0},System.Int32,SadRogue.Primitives.Distance,System.Func{System.Int32,SadRogue.Primitives.Pooling.IListPool{GoRogue.GameFramework.IGameObject}},System.UInt32,System.UInt32,System.UInt32,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point},GoRogue.FOV.IFOV,GoRogue.Pathing.AStar,GoRogue.Components.IComponentCollection)">
             <summary>
             Effectively a helper-constructor.  Constructs a map using an <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> for the
             terrain map, where type T can be any type that implements <see cref="T:GoRogue.GameFramework.IGameObject" />.  Note that a Map that
             is constructed using this function will throw an <see cref="T:System.InvalidCastException" /> if any IGameObject is
             given to <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)" /> that cannot be cast to type T.  Also, the terrain layer given
             is subject to the same restrictions as noted in the corresponding map constructor.
             </summary>
             <remarks>
             Suppose you have a class MyTerrain that inherits from BaseClass and implements <see cref="T:GoRogue.GameFramework.IGameObject" />.
             This construction function allows you to construct your map using an
             <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> instance as the terrain map, which you cannot do with the regular
             constructor since <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> does not satisfy the constructor's type
             requirement of <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" />.
            
             Since this function under the hood creates a <see cref="T:SadRogue.Primitives.GridViews.SettableTranslationGridView`2" /> that
             translates to/from IGameObject as needed,
             any change made using the map's <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)" /> function will be reflected both in
             the map and in the original ISettableGridView.
            
             Note that the terrain view passed in is subject to the same restrictions as in the constructor which takes
             a custom terrain layer:
            
             1. Always consist of persistent objects.  This is to say, the layer _cannot_ be creating objects whenever
                they are requested via the indexer.  For example, a SettableLambdaGridView which creates a new GameObject
                based on some other data is NOT a valid <paramref name="terrainLayer"/>.  For this use case,
                <see cref="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,GoRogue.GameFramework.IGameObject})"/> is recommended instead.
            
             2. Always have its values swapped out via <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)"/> function  after it is passed to this
                constructor, rather than via its set indexer.  Basically, the terrain view must not be changed by anything
                other than the map after this constructor takes it.
            
             Violating either of these conditions will create desync bugs that can leave the map in a completely unusable
             state.  Generally, this helper-constructor should be used as a matter of last resort when there isn't a better way
             to accomplish your integration goals.  You should probably prefer the <see cref="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,GoRogue.GameFramework.IGameObject})"/>
             approach until/unless you have a reason not to.
             </remarks>
             <typeparam name="T">
             The type of terrain that will be stored in the created Map.  Can be any type that implements
             <see cref="T:GoRogue.GameFramework.IGameObject" />.
             </typeparam>
             <param name="terrainLayer">
             The <see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> that represents the terrain layer for this map.  After the
             map has been created, you should use the <see cref="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)" /> function to modify the
             values in this map view, rather than setting the values via the map view itself.  If you re-assign the
             value at a location via the map view, the <see cref="E:GoRogue.GameFramework.Map.ObjectAdded" />/<see cref="E:GoRogue.GameFramework.Map.ObjectRemoved" /> events are
             NOT guaranteed to be called, and many invariants of map may not be properly enforced.
             </param>
             <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
             <param name="distanceMeasurement">
             <see cref="T:SadRogue.Primitives.Distance" /> measurement to use for pathfinding/measuring distance on the
             map.
             </param>
             <param name="customListPoolCreator">
             A function used to determine the list pool implementation used for the spatial maps which support multiple
             items in a location (if any).  The function takes the layer it is creating the pool for as a parameter.
             If no custom creator is specified, a ListPool is used.
             </param>
             <param name="layersBlockingWalkability">
             Layer mask containing those layers that should be allowed to have items that block walkability.
             Defaults to all layers.
             </param>
             <param name="layersBlockingTransparency">
             Layer mask containing those layers that should be allowed to have items that block FOV.
             Defaults to all layers.
             </param>
             <param name="entityLayersSupportingMultipleItems">
             Layer mask containing those layers that should be allowed to have multiple objects at the same
             location on the same layer.  Defaults to all layers.
             </param>
             /// <param name="pointComparer">
             Equality comparer to use for comparison and hashing of points, as object are added to/removed from/moved
             around the map.  Be especially mindful of the efficiency of its GetHashCode function, as it will
             determine the efficiency of many AMap functions.  Defaults to a fast hashing algorithm that generates
             a unique integer for each point based on the width of the map.
             </param>
             <param name="customPlayerFOV">
             Custom FOV to use for <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/>.  Defaults to a GoRogue's recursive shadow-casting
             implementation.  It may also be useful to specify this if you want the <see cref="P:GoRogue.GameFramework.Map.PlayerFOV"/> property
             to not use <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> for data.
             </param>
             <param name="customPather">
             Custom A* pathfinder for the map.  Typically, you wont' need to specify this; By default, uses
             <see cref="P:GoRogue.GameFramework.Map.WalkabilityView" /> to determine which locations can be reached, and calculates distance based
             on the <see cref="T:SadRogue.Primitives.Distance" /> passed to the Map in the constructor.
             </param>
             <param name="customComponentContainer">
             A custom component container to use for <see cref="P:GoRogue.GameFramework.Map.GoRogueComponents"/>.  If not specified, a
             <see cref="T:GoRogue.Components.ComponentCollection"/> is used.  Typically you will not need to specify this, as a
             ComponentCollection is sufficient for nearly all use cases.
             </param>
             <returns>A new Map whose terrain is created using the given terrainLayer, and with the given parameters.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrainAt(SadRogue.Primitives.Point)">
            <summary>
            Gets the terrain object at the given location, or null if no terrain is set to that location.
            </summary>
            <param name="position">The position to get the terrain for.</param>
            <returns>The terrain at the given position, or null if no terrain exists at that location.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrainAt``1(SadRogue.Primitives.Point)">
            <summary>
            Gets the terrain object at the given location, as a value of type TerrainType.  Returns null if no terrain
            is set, or the terrain cannot be cast to the type specified.
            </summary>
            <typeparam name="TTerrain">Type to check for/return the terrain as.</typeparam>
            <param name="position">The position to get the terrain for.</param>
            <returns>
            The terrain at the given position, or null if either no terrain exists at that location or the terrain was
            not castable the given type.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrainAt(System.Int32,System.Int32)">
            <summary>
            Gets the terrain object at the given location, or null if no terrain is set to that location.
            </summary>
            <param name="x">X-value of the position to get the terrain for.</param>
            <param name="y">Y-value of the position to get the terrain for.</param>
            <returns>The terrain at the given position, or null if no terrain exists at that location.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetTerrainAt``1(System.Int32,System.Int32)">
            <summary>
            Gets the terrain object at the given location, as a value of type TerrainType.  Returns null if no terrain is set, or
            the terrain cannot be cast to the type specified.
            </summary>
            <typeparam name="TTerrain">Type to return the terrain as.</typeparam>
            <param name="x">X-value of the position to get the terrain for.</param>
            <param name="y">Y-value of the position to get the terrain for.</param>
            <returns>
            The terrain at the given position, or null if either no terrain exists at that location or the terrain was
            not castable to <typeparamref name="TTerrain"/>.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.SetTerrain(GoRogue.GameFramework.IGameObject)">
            <summary>
            Sets the terrain at the given objects location to the given object, overwriting any terrain already present
            there.
            </summary>
            <remarks>
            A GameObject that is added as Terrain must have a Layer of 0, must not be part of a map currently, and
            must have a position within the bounds of the map.
            </remarks>
            <param name="terrain">
            Terrain to replace the current terrain with. <paramref name="terrain" /> must have its
            <see cref="P:SadRogue.Primitives.IHasLayer.Layer" /> must be 0, or an exception will be thrown.
            </param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.RemoveTerrain(GoRogue.GameFramework.IGameObject)">
            <summary>
            Removes the given terrain object from the map.  If the given terrain object is not a part of the map,
            throws <see cref="T:System.ArgumentException"/>.
            </summary>
            <param name="terrain">Terrain to remove.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.RemoveTerrainAt(SadRogue.Primitives.Point)">
            <summary>
            Removes the terrain at the given location and returns it.  Throws <see cref="T:System.ArgumentException"/> if no
            terrain object has been added at that location.
            </summary>
            <param name="position">Position to remove terrain from.</param>
            <returns>Terrain that was at the position given.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.RemoveTerrainAt(System.Int32,System.Int32)">
            <summary>
            Removes the terrain at the given location and returns it.  Throws <see cref="T:System.ArgumentException"/> if no
            terrain object has been added at that location.
            </summary>
            <param name="x">X-value of the position to remove terrain from.</param>
            <param name="y">Y-value of the position to remove terrain from.</param>
            <returns>Terrain that was at the position given.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay``1(SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,GoRogue.GameFramework.IGameObject})">
            <summary>
            Sets all terrain on the map to the result of running the given translator on the value in
            <paramref name="overlay" /> at the corresponding position.  Useful, for example, for applying the map view
            resulting from map generation to a Map as terrain.
            </summary>
            <typeparam name="T">
            Type of values exposed by map view to translate.  Generally inferred by the compiler.
            </typeparam>
            <param name="overlay">_grid view to translate.</param>
            <param name="translator">
            Function that translates values of the type that <paramref name="overlay" /> exposes to values
            of type IGameObject.
            </param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.ApplyTerrainOverlay(SadRogue.Primitives.GridViews.IGridView{GoRogue.GameFramework.IGameObject})">
            <summary>
            Sets all terrain on the current map to be equal to the corresponding values from the map view you pass in.
            All terrain will in the map view will be removed from its current Map, if any, and its position edited
            to what it is in the <paramref name="overlay"/>, before it is added to the map.
            </summary>
            <remarks>
            If translation between the overlay and IGameObject is required, see the overloads of this function that
            take a translation function.
            </remarks>
            <param name="overlay">
            Grid view specifying the terrain apply to the map. Must have identical dimensions to the current map.
            </param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.AddEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Adds the given entity (non-terrain object) to its recorded location, removing it from the map it is currently a part
            of.  Throws ArgumentException if the entity could not be added (eg., collision detection would not allow it, etc.)
            </summary>
            <param name="entity">Entity to add.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.TryAddEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Adds the given entity (non-terrain object) to this map, removing it from the map it is currently a part
            of.  Returns false if the entity could not be added (eg., collision detection would not allow it, etc.); true otherwise.
            </summary>
            <param name="entity">Entity to add.</param>
            <returns>True if the entity was successfully added; false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.TryAddEntityAt(GoRogue.GameFramework.IGameObject,SadRogue.Primitives.Point)">
            <summary>
            Adds the given entity (non-terrain object) to the location specified, removing it from the map it is currently a part
            of.  Returns false if the entity could not be added (eg., collision detection would not allow it, etc.); true otherwise.
            </summary>
            <remarks>
            The entity's Position property will be set to the location specified before it is added, but only if the function returns true.  No changes
            will have been made to the entity if the function returns false; that is; you may assume that Moved events will not have fired,
            the entity will not have been removed from any map it is already a part of, etc.
            </remarks>
            <param name="entity">Entity to add.</param>
            <param name="position">Location to add the entity to.</param>
            <returns>True if the entity was successfully added to the location specified; false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CanAddEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Returns true if the entity given can be added to this map at its current position; false otherwise.
            </summary>
            <param name="entity">The entity to add.</param>
            <returns>true if the entity given can be added to this map at its current position; false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.CanAddEntityAt(GoRogue.GameFramework.IGameObject,SadRogue.Primitives.Point)">
            <summary>
            Returns true if the entity given can be added to this map at the position given; false otherwise.
            </summary>
            <param name="entity">The entity to add.</param>
            <param name="position">The position to add the entity at.</param>
            <returns>true if the entity given can be added to this map at the given position; false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntityAt``1(SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Gets the first (non-terrain) entity encountered at the given position that can be cast to the specified type, moving
            from the highest existing
            layer in the layer mask downward. Layer mask defaults to all layers. null is returned if no entities of the specified
            type are found, or if
            there are no entities at the location.
            </summary>
            <typeparam name="TEntity">Type of entities to return.</typeparam>
            <param name="position">Position to check get entity for.</param>
            <param name="layerMask">Layer mask for which layers can return an entity.  Defaults to all layers.</param>
            <returns>
            The first entity encountered, moving from the highest existing layer in the layer mask downward, or null if there are
            no entities of
            the specified type are found.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntityAt``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first (non-terrain) entity encountered at the given position that can be cast to the specified type, moving
            from the highest existing
            layer in the layer mask downward. Layer mask defaults to all layers. null is returned if no entities of the specified
            type are found, or if
            there are no entities at the location.
            </summary>
            <typeparam name="TEntity">Type of entities to return.</typeparam>
            <param name="x">X-value of the position to get entity for.</param>
            <param name="y">Y-value of the position to get entity for.</param>
            <param name="layerMask">Layer mask for which layers can return an entity.  Defaults to all layers.</param>
            <returns>
            The first entity encountered, moving from the highest existing layer in the layer mask downward, or null if there are
            no entities of
            the specified type are found.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntitiesAt``1(SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Gets all (non-terrain) entities encountered at the given position that are castable to type EntityType, in order from
            the highest existing layer in the layer mask downward.  Layer mask defaults to all layers.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <typeparam name="TEntity">Type of entities to return.</typeparam>
            <param name="position">Position to get entities for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>
            All entities encountered at the given position that are castable to the given type, in order from the highest existing
            layer
            in the mask downward.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetEntitiesAt``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all (non-terrain) entities encountered at the given position that are castable to type EntityType, in order from
            the highest existing layer in the layer mask downward.  Layer mask defaults to all layers.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <typeparam name="TEntity">Type of entities to return.</typeparam>
            <param name="x">X-value of the position to get entities for.</param>
            <param name="y">Y-value of the position to get entities for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>
            All entities encountered at the given position that are castable to the given type, in order from the highest existing
            layer
            in the mask downward.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.RemoveEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Removes the given entity (non-terrain object) from the map.  Throws ArgumentException if the entity was not
            part of this map.
            </summary>
            <param name="entity">The entity to remove from the map.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map.TryRemoveEntity(GoRogue.GameFramework.IGameObject)">
            <summary>
            Removes the given entity (non-terrain object) from the map.  Does nothing and returns false if the entity
            was not part of this map; returns true and removes it otherwise.
            </summary>
            <param name="entity">The entity to remove from the map.</param>
            <returns>True if the given entity was removed from the map; false otherwise (eg the entity given was not in the map).</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectAt(SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position, moving from the highest existing layer in the layer mask
            downward.  Layer mask defaults to all layers.
            </summary>
            <param name="position">Position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectAt``1(SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position that can be cast to the type specified, moving from the highest
            existing layer in the
            layer mask downward. Layer mask defaults to all layers.  null is returned if no objects of the specified type are
            found, or if there are no
            objects at the location.
            </summary>
            <typeparam name="TObject">Type of objects to return.</typeparam>
            <param name="position">Position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>
            The first object encountered, moving from the highest existing layer in the layer mask downward, or null if there are
            no objects of
            the specified type are found.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectAt(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position that can be cast to the specified type, moving from the highest
            existing layer in the
            layer mask downward. Layer mask defaults to all layers. null is returned if no objects of the specified type are found,
            or if there are no
            objects at the location.
            </summary>
            <param name="x">X-value of the position to get object for.</param>
            <param name="y">Y-value of the position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectAt``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position that can be cast to the specified type, moving from the highest
            existing layer in the
            layer mask downward. Layer mask defaults to all layers. null is returned if no objects of the specified type are found,
            or if there are no
            objects at the location.
            </summary>
            <typeparam name="TObject">Type of objects to return.</typeparam>
            <param name="x">X-value of the position to get object for.</param>
            <param name="y">Y-value of the position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>
            The first object encountered, moving from the highest existing layer in the layer mask downward, or null if there are
            no objects of
            the specified type are found.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectsAt(SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position, in order from the highest existing layer in the layer mask
            downward.  Layer mask defaults to all layers.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <param name="position">Position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position, in order from the highest existing layer in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectsAt``1(SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position that are castable to type ObjectType, in order from the highest
            existing layer in the layer mask downward. Layer mask defaults to all layers.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <typeparam name="TObject">Type of objects to return.</typeparam>
            <param name="position">Position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>
            All objects encountered at the given position that are castable to the given type, in order from the highest existing
            layer
            in the mask downward.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectsAt(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position, in order from the highest existing layer in the layer mask
            downward.  Layer mask defaults to all layers.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <param name="x">X-value of the position to get objects for.</param>
            <param name="y">Y-value of the position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position, in order from the highest existing layer in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GetObjectsAt``1(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position that are castable to type ObjectType, in order from the highest
            existing layer in the layer mask downward. Layer mask defaults to all layers.
            </summary>
            <remarks>
            This function returns a custom iterator which is very fast when used in a foreach loop.
            If you need an IEnumerable to use with LINQ or other code, the returned struct does implement that interface;
            however note that iterating over it this way will not perform as well as iterating directly over this object.
            </remarks>
            <typeparam name="TObject">Type of objects to return.</typeparam>
            <param name="x">X-value of the position to get objects for.</param>
            <param name="y">Y-value of the position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>
            All objects encountered at the given position that are castable to the given type, in order from the highest existing
            layer
            in the mask downward.
            </returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GameObjectCanMove(GoRogue.GameFramework.IGameObject,SadRogue.Primitives.Point)">
            <summary>
            Returns whether or not the given game object is allowed to move to the position specified.  The object
            specified must be part of the map.
            </summary>
            <param name="gameObject">Object to check.</param>
            <param name="newPosition">New position to check if the object can move to.</param>
            <returns>True if the object given can move to the given position, false otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the given object is not part of this map.</exception>
        </member>
        <member name="M:GoRogue.GameFramework.Map.GameObjectCanSetWalkability(GoRogue.GameFramework.IGameObject,System.Boolean)">
            <summary>
            Returns whether or not the given game object is allowed to set its <see cref="P:GoRogue.GameFramework.IGameObject.IsWalkable"/>
            property to the given value. The object specified must be part of the map.
            </summary>
            <param name="gameObject">Object to check.</param>
            <param name="value">New value to check for walkability.</param>
            <returns>
            True if the object may set its walkability to the given value without violating collision detection; false
            otherwise.
            </returns>
            <exception cref="T:System.ArgumentException">Thrown if the given object is not part of this map.</exception>
        </member>
        <member name="T:GoRogue.GameFramework.TerrainOnlyMapTransparencyView">
            <summary>
            Grid view used as the <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> for a map when only the terrain layer can have non-transparent
            tiles.
            </summary>
            <remarks>
            This class is used instead of a <see cref="T:SadRogue.Primitives.GridViews.LambdaGridView`1"/> in order to maximize performance.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.TerrainOnlyMapTransparencyView.Height">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.TerrainOnlyMapTransparencyView.Width">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.TerrainOnlyMapTransparencyView.Item(SadRogue.Primitives.Point)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.GameFramework.TerrainOnlyMapTransparencyView.#ctor(GoRogue.GameFramework.Map)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map which this grid view gets its data from.</param>
        </member>
        <member name="T:GoRogue.GameFramework.FullMapTransparencyView">
            <summary>
            Grid view used as the <see cref="P:GoRogue.GameFramework.Map.TransparencyView"/> for a map when non-terrain layers can have non-transparent objects.
            </summary>
            <remarks>
            This class is used instead of a <see cref="T:SadRogue.Primitives.GridViews.LambdaGridView`1"/> in order to maximize performance.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.FullMapTransparencyView.Height">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.FullMapTransparencyView.Width">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.FullMapTransparencyView.Item(SadRogue.Primitives.Point)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.GameFramework.FullMapTransparencyView.#ctor(GoRogue.GameFramework.Map)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map which this grid view gets its data from.</param>
        </member>
        <member name="T:GoRogue.GameFramework.TerrainOnlyMapWalkabilityView">
            <summary>
            Grid view used as the <see cref="P:GoRogue.GameFramework.Map.WalkabilityView"/> for a map when only the terrain layer can have non-walkable
            tiles.
            </summary>
            <remarks>
            This class is used instead of a <see cref="T:SadRogue.Primitives.GridViews.LambdaGridView`1"/> in order to maximize performance.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.TerrainOnlyMapWalkabilityView.Height">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.TerrainOnlyMapWalkabilityView.Width">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.TerrainOnlyMapWalkabilityView.Item(SadRogue.Primitives.Point)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.GameFramework.TerrainOnlyMapWalkabilityView.#ctor(GoRogue.GameFramework.Map)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map which this grid view gets its data from.</param>
        </member>
        <member name="T:GoRogue.GameFramework.FullMapWalkabilityView">
            <summary>
            Grid view used as the <see cref="P:GoRogue.GameFramework.Map.WalkabilityView"/> for a map when non-terrain layers can have non-walkable objects.
            </summary>
            <remarks>
            This class is used instead of a <see cref="T:SadRogue.Primitives.GridViews.LambdaGridView`1"/> in order to maximize performance.
            </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.FullMapWalkabilityView.Height">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.FullMapWalkabilityView.Width">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.GameFramework.FullMapWalkabilityView.Item(SadRogue.Primitives.Point)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.GameFramework.FullMapWalkabilityView.#ctor(GoRogue.GameFramework.Map)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map which this grid view gets its data from.</param>
        </member>
        <member name="T:GoRogue.GameFramework.MapObjectsAtEnumerator">
             <summary>
             A custom enumerator used to iterate over all objects on a <see cref="T:GoRogue.GameFramework.Map"/> which are at a given location on given layers
             efficiently.  Items are returned in order from highest layer to lowest, as applicable.
            
             Generally, you should use <see cref="M:GoRogue.GameFramework.Map.GetObjectsAt(SadRogue.Primitives.Point,System.UInt32)"/> or one of that function's overloads to get an
             instance of this enumerator, rather than creating one yourself.
             </summary>
             <remarks>
             This type is a struct, and as such is much more efficient when used in a foreach loop than a function returning
             IEnumerable&lt;IGameObject&gt; by using "yield return".  This type does implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
             so you can pass it to functions which require one (for example, System.LINQ).  However, this will have reduced
             performance due to boxing of the iterator.
             </remarks>
        </member>
        <member name="P:GoRogue.GameFramework.MapObjectsAtEnumerator.Current">
            <summary>
            The current value for enumeration.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtEnumerator.#ctor(GoRogue.GameFramework.Map,SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map to iterate over objects on.</param>
            <param name="position">The position to get objects at.</param>
            <param name="layerMask">A layer mask indicating what layers to include in the search for items.</param>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtEnumerator.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtEnumerator.GetEnumerator">
            <summary>
            Returns this enumerator.
            </summary>
            <returns>This enumerator.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtEnumerator.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.GameFramework.MapObjectsAtCastEnumerator`1">
             <summary>
             A custom enumerator used to iterate over all objects on a <see cref="T:GoRogue.GameFramework.Map"/> which are at a given location on given layers
             and are of a given type efficiently.  Items are returned in order from highest layer to lowest, as applicable.  Any items not of the given
             type are ignored.
            
             Generally, you should use <see cref="M:GoRogue.GameFramework.Map.GetObjectsAt``1(SadRogue.Primitives.Point,System.UInt32)"/> or one of that function's overloads to get an
             instance of this enumerator, rather than creating one yourself.
             </summary>
             <remarks>
             This type is a struct, and as such is much more efficient when used in a foreach loop than a function returning
             IEnumerable&lt;T&gt; by using "yield return".  This type does implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
             so you can pass it to functions which require one (for example, System.LINQ).  However, this will have reduced
             performance due to boxing of the iterator.
             </remarks>
             <typeparam name="T">The type of items to look for.</typeparam>
        </member>
        <member name="P:GoRogue.GameFramework.MapObjectsAtCastEnumerator`1.Current">
            <summary>
            The current value for enumeration.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtCastEnumerator`1.#ctor(GoRogue.GameFramework.Map,SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map to iterate over objects on.</param>
            <param name="position">The position to get objects at.</param>
            <param name="layerMask">A layer mask indicating what layers to include in the search for items.</param>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtCastEnumerator`1.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtCastEnumerator`1.GetEnumerator">
            <summary>
            Returns this enumerator.
            </summary>
            <returns>This enumerator.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.MapObjectsAtCastEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.GameFramework.MapEntitiesAtCastEnumerator`1">
             <summary>
             A custom enumerator used to iterate over all entities on a <see cref="T:GoRogue.GameFramework.Map"/> which are at a given location on given layers
             and are of a given type efficiently.  Entities are returned in order from highest layer to lowest, as applicable.  Any entities not of the given
             type are ignored.
            
             Generally, you should use <see cref="M:GoRogue.GameFramework.Map.GetEntitiesAt``1(SadRogue.Primitives.Point,System.UInt32)"/> or one of that function's overloads to get an
             instance of this enumerator, rather than creating one yourself.
             </summary>
             <remarks>
             This type is a struct, and as such is much more efficient when used in a foreach loop than a function returning
             IEnumerable&lt;T&gt; by using "yield return".  This type does implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>,
             so you can pass it to functions which require one (for example, System.LINQ).  However, this will have reduced
             performance due to boxing of the iterator.
             </remarks>
             <typeparam name="T">The type of entities to look for.</typeparam>
        </member>
        <member name="P:GoRogue.GameFramework.MapEntitiesAtCastEnumerator`1.Current">
            <summary>
            The current value for enumeration.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.MapEntitiesAtCastEnumerator`1.#ctor(GoRogue.GameFramework.Map,SadRogue.Primitives.Point,System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <param name="map">Map to iterate over entities on.</param>
            <param name="position">The position to get entities at.</param>
            <param name="layerMask">A layer mask indicating what layers to include in the search for entities.</param>
        </member>
        <member name="M:GoRogue.GameFramework.MapEntitiesAtCastEnumerator`1.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.GameFramework.MapEntitiesAtCastEnumerator`1.GetEnumerator">
            <summary>
            Returns this enumerator.
            </summary>
            <returns>This enumerator.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.MapEntitiesAtCastEnumerator`1.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.GridViews.InheritedTypeGridView`2">
            <summary>
            Grid view that translates from T1 to T2, assuming T2 inherits from T1, by simply casting.
            </summary>
            <remarks>
            This is useful to implement full co-variance/contra-variance with grid views, if you know that values that will be
            put into the map will be of a particular type.  An exception will occur if casting a value to T2 fails.
            </remarks>
            <typeparam name="T1">Base type of grid view to implement.</typeparam>
            <typeparam name="T2">Value inheriting from/implementing T1.</typeparam>
        </member>
        <member name="M:GoRogue.GridViews.InheritedTypeGridView`2.#ctor(SadRogue.Primitives.GridViews.ISettableGridView{`0})">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.GridViews.InheritedTypeGridView`2.#ctor(SadRogue.Primitives.GridViews.ISettableGridView{`0},SadRogue.Primitives.GridViews.ISettableGridView{`1})">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.GridViews.InheritedTypeGridView`2.TranslateGet(`0)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.GridViews.InheritedTypeGridView`2.TranslateSet(`1)">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.IReadOnlyDisjointSet">
            <summary>
            Read-only representation of <see cref="T:GoRogue.DisjointSet"/>.
            </summary>
        </member>
        <member name="E:GoRogue.IReadOnlyDisjointSet.SetsJoined">
            <summary>
            Fired when two sets are joined into one.  The arguments give the IDs of the two sets that were joined.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyDisjointSet.Count">
            <summary>
            Number of distinct sets.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet.Find(System.Int32)">
            <summary>
            Returns the ID for the parent of the set containing the set with ID <paramref name="objectID" />,
            performing path compression as search is completed.
            </summary>
            <param name="objectID">ID of the object to search for.</param>
            <returns>The ID for the parent of the object given.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet.InSameSet(System.Int32,System.Int32)">
            <summary>
            Returns true if the objects specified by the given IDs are in the same set.
            </summary>
            <param name="objectID1" />
            <param name="objectID2" />
            <returns>True if the the objects specified by the given IDs are in the same set, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.IReadOnlyDisjointSet`1">
            <summary>
            Read-only representation of <see cref="T:GoRogue.DisjointSet`1"/>.
            </summary>
        </member>
        <member name="E:GoRogue.IReadOnlyDisjointSet`1.SetsJoined">
            <summary>
            Fired when two sets are joined into one.  The arguments give the two sets that were joined.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyDisjointSet`1.Count">
            <summary>
            Number of distinct sets.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet`1.Find(`0)">
            <summary>
            Returns the parent of the set containing <paramref name="item" />, performing path compression as search is
            completed.
            </summary>
            <param name="item">Object to search for.</param>
            <returns>The parent of the object given.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet`1.InSameSet(`0,`0)">
            <summary>
            Returns true if the two objects specified are in the same set.
            </summary>
            <param name="item1" />
            <param name="item2" />
            <returns>True if the two objects are in the same set, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.LineHelpers">
            <summary>
            Provides implementations of various helper functions useful for gathering information from lines.
            </summary>
        </member>
        <member name="M:GoRogue.LineHelpers.LeftAt(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point},System.Int32)">
            <summary>
            Gets the left-most point in a list that is on the given y-value.
            </summary>
            <param name="self"/>
            <param name="y">Y-value to find the left-most point on.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.LineHelpers.RightAt(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point},System.Int32)">
            <summary>
            Gets the right-most point in a list that is on the given y-value.
            </summary>
            <param name="self"/>
            <param name="y">Y-value to find the right-most point on.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.LineHelpers.TopAt(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point},System.Int32)">
            <summary>
            Gets the top-most point in a list that is on the given x-value.
            </summary>
            <param name="self"/>
            <param name="x">X-value to find the top-most point on.</param>
            <returns/>
        </member>
        <member name="M:GoRogue.LineHelpers.BottomAt(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point},System.Int32)">
            <summary>
            Gets the top-most point in a list that is on the given x-value.
            </summary>
            <param name="self"/>
            <param name="x">X-value to find the top-most point on.</param>
            <returns/>
        </member>
        <member name="T:GoRogue.ListCastEnumerator`2">
             <summary>
             A custom enumerator that iterates over a List and casts its objects to the given type.
            
             All objects _must_ be of the specified type, or the iterator will not function.
             </summary>
             <remarks>
             This type is a struct, and as such is much more efficient when used in a foreach loop than a function returning
             IEnumerable&lt;T&gt; or using System.LINQ extensions such as Where.
            
             Otherwise, it has basically the same characteristics that exposing a list as <see cref="T:System.Collections.Generic.IEnumerable`1"/> would;
             so if you need to expose items as some type like IEnumerable, and the items are internally stored as a list, this
             can be a good option.  This type does implement IEnumerable, and as such can be used directly with functions that
             require one (for example, System.LINQ).  However, this will have reduced performance due to boxing of the iterator.
             </remarks>
             <typeparam name="TBase">Type items in the list are stored as.</typeparam>
             <typeparam name="TItem">Actual type of items in the list.</typeparam>
        </member>
        <member name="M:GoRogue.ListCastEnumerator`2.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Constructor.
            </summary>
            <param name="list">List to iterate over.</param>
        </member>
        <member name="M:GoRogue.ListCastEnumerator`2.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.ListCastEnumerator`2.MoveNext">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.ListCastEnumerator`2.Current">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.ListCastEnumerator`2.GetEnumerator">
            <summary>
            Returns this enumerator.
            </summary>
            <returns>This enumerator.</returns>
        </member>
        <member name="T:GoRogue.ReadOnlyListCastEnumerator`2">
             <summary>
             A structure similar to <see cref="T:GoRogue.ListCastEnumerator`2"/>, but for <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.  It is not quite
             as fast as <see cref="T:GoRogue.ListCastEnumerator`2"/>, but is still faster than using the typical Enumerable implementation
             for IReadOnlyList.  You should only use this if you can't use <see cref="T:GoRogue.ListCastEnumerator`2"/> due to the type
             you're working with; they share the same characteristics otherwise.
            
             All objects _must_ be of the specified type, or the iterator will not function.
             </summary>
             <typeparam name="TBase">Type items in the list are stored as.</typeparam>
             <typeparam name="TItem">Actual type of items in the list.</typeparam>
        </member>
        <member name="M:GoRogue.ReadOnlyListCastEnumerator`2.#ctor(System.Collections.Generic.IReadOnlyList{`0})">
            <summary>
            Constructor.
            </summary>
            <param name="list">List to iterate over.</param>
        </member>
        <member name="M:GoRogue.ReadOnlyListCastEnumerator`2.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.ReadOnlyListCastEnumerator`2.MoveNext">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.ReadOnlyListCastEnumerator`2.Current">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.ReadOnlyListCastEnumerator`2.GetEnumerator">
            <summary>
            Returns this enumerator.
            </summary>
            <returns>This enumerator.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair">
            <summary>
            A pair of points in different areas that have been selected as connection points by an
            <see cref="T:GoRogue.MapGeneration.ConnectionPointSelectors.IConnectionPointSelector"/>.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.Area1Position">
            <summary>
            The type of component expected.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.Area2Position">
            <summary>
            The tag expected to be associated with a component of the specified type.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.#ctor(SadRogue.Primitives.Point,SadRogue.Primitives.Point)">
            <summary>
            Constructor.
            </summary>
            <param name="area1Position"/>
            <param name="area2Position"/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.ToString">
            <summary>
            Returns a string representing the two points.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.Deconstruct(SadRogue.Primitives.Point@,SadRogue.Primitives.Point@)">
            <summary>
            Supports C# Deconstruction syntax.
            </summary>
            <param name="area1Position"/>
            <param name="area2Position"/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.op_Implicit(GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair)~System.ValueTuple{SadRogue.Primitives.Point,SadRogue.Primitives.Point}">
            <summary>
            Implicitly converts an AreaConnectionPointPair to an equivalent tuple.
            </summary>
            <param name="pair"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.op_Implicit(System.ValueTuple{SadRogue.Primitives.Point,SadRogue.Primitives.Point})~GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair">
            <summary>
            Implicitly converts a tuple to its equivalent AreaConnectionPointPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.ToTuple">
            <summary>
            Converts the pair to an equivalent tuple.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.FromTuple(System.ValueTuple{SadRogue.Primitives.Point,SadRogue.Primitives.Point})">
            <summary>
            Converts the tuple to an equivalent AreaConnectionPointPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.Equals(GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair)">
            <summary>
            True if the given pair contains the same points; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.Matches(GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair)">
            <summary>
            True if the given pair contains the same points; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.Equals(System.Object)">
            <summary>
            True if the given object is a AreaConnectionPointPair and has the same points; false otherwise.
            </summary>
            <param name="obj"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.GetHashCode">
            <summary>
            Returns a hash code based on all of the pair's field's.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.op_Equality(GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair,GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair)">
            <summary>
            True if the given pairs have the same points; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair.op_Inequality(GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair,GoRogue.MapGeneration.ConnectionPointSelectors.AreaConnectionPointPair)">
            <summary>
            True if the given pairs have different points for the first and second point, respectively; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="T:GoRogue.MapGeneration.ConnectionPointSelectors.CenterBoundsConnectionPointSelector">
            <summary>
            Implements a the selection algorithm that selects the center points of the bounding boxes of the given
            <see cref="T:SadRogue.Primitives.Area" /> instances as connection points.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.CenterBoundsConnectionPointSelector.SelectConnectionPoints(SadRogue.Primitives.IReadOnlyArea,SadRogue.Primitives.IReadOnlyArea)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.ConnectionPointSelectors.ClosestConnectionPointSelector">
            <summary>
            Implements a the selection algorithm that selects the two points closest to each other in the given <see cref="T:SadRogue.Primitives.Area" />
            instances.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.ConnectionPointSelectors.ClosestConnectionPointSelector.DistanceCalculation">
            <summary>
            Distance calculation to use to determine closeness.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.ClosestConnectionPointSelector.#ctor(SadRogue.Primitives.Distance)">
            <summary>
            Creates a new point selector.
            </summary>
            <param name="distanceCalculation">Distance calculation to use to determine closeness.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.ClosestConnectionPointSelector.SelectConnectionPoints(SadRogue.Primitives.IReadOnlyArea,SadRogue.Primitives.IReadOnlyArea)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.ConnectionPointSelectors.IConnectionPointSelector">
            <summary>
            Interface for implementing an algorithm for selecting the positions to connect in order to
            connect two given areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.IConnectionPointSelector.SelectConnectionPoints(SadRogue.Primitives.IReadOnlyArea,SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Implements the algorithm. Returns pair of positions -- one position in <paramref name="area1" />
            to use, and on position in <paramref name="area2" /> to use.
            </summary>
            <param name="area1">First <see cref="T:SadRogue.Primitives.Area" /> to connect.</param>
            <param name="area2">Second <see cref="T:SadRogue.Primitives.Area" /> to connect.</param>
            <returns>
            A pair of positions (one from each <see cref="T:SadRogue.Primitives.Area" />) to connect.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.ConnectionPointSelectors.RandomConnectionPointSelector">
            <summary>
            Implements a the selection algorithm that simply selects random points from the given
            areas' positions lists, using the RNG specified, or the default rng if null is given.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.RandomConnectionPointSelector.#ctor(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Constructor. Specifies the RNG to use, or null if the default RNG should be used.
            </summary>
            <param name="rng">The RNG to use, or null if the default RNG should be used.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ConnectionPointSelectors.RandomConnectionPointSelector.SelectConnectionPoints(SadRogue.Primitives.IReadOnlyArea,SadRogue.Primitives.IReadOnlyArea)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.ContextComponents.DoorList">
            <summary>
            A list of rooms and entry/exit points of those rooms, generated/added by map generation components, that tracks
            what generation step created/recorded which opening.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.DoorList.#ctor">
            <summary>
            Creates a new door manager context component.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.DoorList.DoorsPerRoom">
            <summary>
            A dictionary associating rooms to their lists of doors.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.DoorList.AddDoor(System.String,SadRogue.Primitives.Rectangle,SadRogue.Primitives.Point)">
            <summary>
            Records a new opening in the given room at the given position.
            </summary>
            <param name="generationStepName">The name of the generation step recording the door position.</param>
            <param name="room">The room the door is a part of.</param>
            <param name="doorPosition">The location of the door to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.DoorList.AddDoors(System.String,SadRogue.Primitives.Rectangle,SadRogue.Primitives.Point[])">
            <summary>
            Records new openings in the given room at the given positions.
            </summary>
            <param name="generationStepName">The name of the generation step recording the door positions.</param>
            <param name="room">The room the doors are part of.</param>
            <param name="doorPositions">The locations of the door to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.DoorList.AddDoors(System.String,SadRogue.Primitives.Rectangle,System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point})">
            <summary>
            Records new openings in the given room at the given positions.
            </summary>
            <param name="generationStepName">The name of the generation step recording the door positions.</param>
            <param name="room">The room the doors are part of.</param>
            <param name="doorPositions">The locations of the door to add.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.ContextComponents.ItemList`1">
            <summary>
            A generic list of items added by map generation steps, that tracks what generation step added what item.
            </summary>
            <typeparam name="TItem">Type of item being stored.</typeparam>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.#ctor">
            <summary>
            Creates an empty item list.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.#ctor(System.Collections.Generic.IEnumerable{GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0}})">
            <summary>
            Creates a new item list and adds the given items to it.
            </summary>
            <param name="initialItems">Initial item/step pairs to add to the list.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.#ctor(System.Int32)">
            <summary>
            Creates an empty item list with the specified initial capacity for items.
            </summary>
            <param name="initialItemCapacity"></param>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.ItemList`1.Items">
            <summary>
            The list of items added.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.ItemList`1.ItemToStepMapping">
            <summary>
            A mapping of each item to the <see cref="F:GoRogue.MapGeneration.GenerationStep.Name" /> of the generation step that created the item.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.Add(`0,System.String)">
            <summary>
            Adds an item to to the list.
            </summary>
            <param name="item">The item to add.</param>
            <param name="generationStepName">The <see cref="F:GoRogue.MapGeneration.GenerationStep.Name" /> of the generation step that created the item.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.AddRange(System.Collections.Generic.IEnumerable{`0},System.String)">
            <summary>
            Adds the given items to the list.
            </summary>
            <param name="items">The items to add.</param>
            <param name="generationStepName">The <see cref="F:GoRogue.MapGeneration.GenerationStep.Name" /> of the generation step that created the items.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.Remove(`0)">
            <summary>
            Removes the given item from the list.
            </summary>
            <param name="item">Item to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes the given items from the list.
            </summary>
            <param name="items">Items to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.Remove(System.Func{`0,System.Boolean})">
            <summary>
            Removes all items from the list for which the given function returns true.
            </summary>
            <param name="predicate">Predicate to determine which elements to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.GetEnumerator">
            <summary>
            Gets an enumerator of all items and the step that added them.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets a generic enumerator of all items and the step that added them.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1">
            <summary>
            An item added to a generation context component and the name of the step that added it.
            </summary>
            <typeparam name="TItem">The type of item stored in the pairing.</typeparam>
        </member>
        <member name="F:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.Item">
            <summary>
            The item.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.Step">
            <summary>
            The name associated with the step that created the item.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.#ctor(`0,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="item"/>
            <param name="step"/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.ToString">
            <summary>
            Returns a string representing the item and the name of the step that added it.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.Deconstruct(`0@,System.String@)">
            <summary>
            Supports C# Deconstruction syntax.
            </summary>
            <param name="item"/>
            <param name="step"/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.op_Implicit(GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0})~System.ValueTuple{`0,System.String}">
            <summary>
            Implicitly converts a ItemStepPair to an equivalent tuple.
            </summary>
            <param name="pair"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.op_Implicit(System.ValueTuple{`0,System.String})~GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0}">
            <summary>
            Implicitly converts a tuple to its equivalent ItemStepPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.ToTuple">
            <summary>
            Converts the pair to an equivalent tuple.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.FromTuple(System.ValueTuple{`0,System.String})">
            <summary>
            Converts the tuple to an equivalent ItemStepPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.Equals(GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0})">
            <summary>
            True if the given pair has equivalent items and that were generated by the same step; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.Matches(GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0})">
            <summary>
            True if the given pair has equivalent items and that were generated by the same step; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.Equals(System.Object)">
            <summary>
            True if the given object is an ItemStepPair that has an equivalent item that was generated by the same step;
            false otherwise.
            </summary>
            <param name="obj"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.GetHashCode">
            <summary>
            Returns a hash code based on all of the pair's fields.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.op_Equality(GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0},GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0})">
            <summary>
            True if the given pairs have the same component and tag; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.ItemStepPair`1.op_Inequality(GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0},GoRogue.MapGeneration.ContextComponents.ItemStepPair{`0})">
            <summary>
            True if the given pairs have different components and/or tags; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="T:GoRogue.MapGeneration.ContextComponents.RoomDoors">
            <summary>
            A list of openings in room walls, categorized by side they're on.  Typically created via a
            <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList" />.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.RoomDoors.#ctor(SadRogue.Primitives.Rectangle)">
            <summary>
            Creates a new list of doors for a given room.
            </summary>
            <param name="room">The room having its doors tracked.</param>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.TopDoors">
            <summary>
            Positions of doors on the top wall of the room.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.RightDoors">
            <summary>
            Positions of doors on the right wall of the room.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.BottomDoors">
            <summary>
            Positions of doors on the bottom wall of the room.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.LeftDoors">
            <summary>
            Positions of doors on the bottom wall of the room.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.Room">
            <summary>
            The room that is having its doors tracked.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.RoomWithOuterWalls">
            <summary>
            A rectangle including the outer walls of the room having its doors tracked.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.Doors">
            <summary>
            Positions all doors in all walls of the room, with no duplicate locations.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.DoorToStepMapping">
            <summary>
            A dictionary associating doors with the generation step that recorded/created them.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.ContextComponents.RoomDoors.Item(SadRogue.Primitives.Direction)">
            <summary>
            Retrieves a read-only list of doors on the given side.  Direction specified must be a cardinal.
            </summary>
            <param name="side">Side to get doors for.</param>
            <returns>A read-only list of doors on the given side.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.RoomDoors.AddDoor(System.String,SadRogue.Primitives.Point)">
            <summary>
            Adds the given position to the appropriate lists of doors.
            </summary>
            <param name="generationStepName">The name of the generation step that is adding the door.</param>
            <param name="doorPosition">Position to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.RoomDoors.AddDoors(System.String,SadRogue.Primitives.Point[])">
            <summary>
            Adds the given positions to the appropriate lists of doors.
            </summary>
            <param name="generationStepName">The name of the generation step that is adding the doors.</param>
            <param name="doorPositions">Positions to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.RoomDoors.AddDoors(System.String,System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point})">
            <summary>
            Adds the given positions to the appropriate lists of doors.
            </summary>
            <param name="generationStepName">The name of the generation step that is adding the doors.</param>
            <param name="doorPositions">Positions to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.RoomDoors.GetEnumerator">
            <summary>
            Gets an enumerator for all doors recorded and the step that added them.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.ContextComponents.RoomDoors.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for all doors recorded and the step that added them.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.MapGeneration.DefaultAlgorithms">
            <summary>
            A collection of functions that return pre-defined series of generation steps that generate particular types
            of maps.  For more customizable map generation, see documentation for the individual steps in <see cref="N:GoRogue.MapGeneration.Steps" /> and
            use AddStep
            to add them to a generator.
            </summary>
            <remarks>
            These algorithms serve as a quick way to generate a map and demonstrate how generation steps may be used together.
            Feel free to look at the source, and copy onr or more of the generation steps into a custom generator.
            </remarks>
        </member>
        <member name="M:GoRogue.MapGeneration.DefaultAlgorithms.BasicRandomRoomsMapSteps(ShaiRandom.Generators.IEnhancedRandom,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,GoRogue.MapGeneration.ConnectionPointSelectors.IConnectionPointSelector,GoRogue.MapGeneration.TunnelCreators.ITunnelCreator)">
            <summary>
            Generates a basic dungeon by randomly sizing and placing rooms on the map, then connecting them with basic
            tunnels.
            </summary>
            <param name="rng">The RNG to use for map generation.  Defaults to <see cref="F:GoRogue.Random.GlobalRandom.DefaultRNG" />.</param>
            <param name="minRooms">Minimum amount of rooms to generate on the map.  Defaults to 4.</param>
            <param name="maxRooms">Maximum amount of rooms to generate on the map.  Defaults to 10.</param>
            <param name="roomMinSize">The minimum size allowed for generated rooms.  Rounded up to an odd number.  Defaults to 3.</param>
            <param name="roomMaxSize">The maximum size allowed for generated rooms.  Rounded up to an odd number.  Defaults to 7.</param>
            <param name="roomSizeRatioX">The ratio of the room width to the height for generated rooms. Defaults to 1.0.</param>
            <param name="roomSizeRatioY">The ratio of the room height to the width for generated rooms. Defaults to 1.0.</param>
            <param name="maxCreationAttempts">
            The maximum times to re-generate a room that fails to place in a valid location
            before giving up on generating that room entirely.  Defaults to 10.
            </param>
            <param name="maxPlacementAttempts">
            The maximum times to attempt to place a room in a map without intersection, before
            giving up and re-generating that room. Defaults to 10.
            </param>
            <param name="connectionPointSelector">
            The area connection strategy to use. Defaults to a <see cref="T:GoRogue.MapGeneration.ConnectionPointSelectors.CenterBoundsConnectionPointSelector"/>.</param>
            <param name="tunnelCreator">
            The tunnel creation strategy to use. Defaults to <see cref="T:GoRogue.MapGeneration.TunnelCreators.HorizontalVerticalTunnelCreator"/> using
            the given RNG.</param>
            <returns>A set of map generation steps that generate a map with rectangular rooms connected to each other.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.DefaultAlgorithms.DungeonMazeMapSteps(ShaiRandom.Generators.IEnhancedRandom,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Int32)">
            <summary>
            Generates a dungeon map based on the process outlined here:
            http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/.
            </summary>
            <param name="rng">The RNG to use for map generation.  Defaults to <see cref="F:GoRogue.Random.GlobalRandom.DefaultRNG" />.</param>
            <param name="minRooms">Minimum amount of rooms to generate on the map.  Defaults to 4.</param>
            <param name="maxRooms">Maximum amount of rooms to generate on the map.  Defaults to 10.</param>
            <param name="roomMinSize">The minimum size allowed for generated rooms.  Rounded up to an odd number.  Defaults to 3.</param>
            <param name="roomMaxSize">The maximum size allowed for generated rooms.  Rounded up to an odd number.  Defaults to 7.</param>
            <param name="roomSizeRatioX">The ratio of the room width to the height for generated rooms. Defaults to 1.0.</param>
            <param name="roomSizeRatioY">The ratio of the room height to the width for generated rooms. Defaults to 1.0.</param>
            <param name="maxCreationAttempts">
            The maximum times to re-generate a room that fails to place in a valid location
            before giving up on generating that room entirely.  Defaults to 10.
            </param>
            <param name="maxPlacementAttempts">
            The maximum times to attempt to place a room in a map without intersection, before
            giving up and re-generating that room. Defaults to 10.
            </param>
            <param name="crawlerChangeDirectionImprovement">
            Out of 100, how much to increase the chance of a crawler changing
            direction each step during maze generation.  Once it changes direction, it resets to 0 and increases by this amount.
            Defaults to 10.
            </param>
            <param name="minSidesToConnect">Minimum sides of each room to connect to the maze.  Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of each room to connect to the maze. Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">
            A chance out of 100 to cancel selecting sides to connect to the maze
            (per room). Defaults to 50.
            </param>
            <param name="cancelConnectionPlacementChance">
            A chance out of 100 to cancel placing a door on a given side of a room
            after one has been placed on that side. Defaults to 70.
            </param>
            <param name="cancelConnectionPlacementChanceIncrease">
            The <paramref name="cancelConnectionPlacementChance" /> value is
            increased by this amount each time a door is placed on a given side of a room. Defaults to 10.
            </param>
            <param name="saveDeadEndChance">
            The chance out of 100 that a dead end is left alone during dead end trimming.  Defaults
            to 40.
            </param>
            <param name="maxTrimIterations">
            Maximum number of passes to make looking for dead ends per area during dead end
            trimming.  Defaults to infinity.
            </param>
            <returns>A set of map generation steps that generate a map with rectangular rooms connected by a maze of tunnels.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.DefaultAlgorithms.CellularAutomataGenerationSteps(ShaiRandom.Generators.IEnhancedRandom,System.UInt16,System.Int32,System.Int32,SadRogue.Primitives.Distance,GoRogue.MapGeneration.ConnectionPointSelectors.IConnectionPointSelector,GoRogue.MapGeneration.TunnelCreators.ITunnelCreator)">
            <summary>
            Generates a cave-like map using the cellular automata algorithm here:
            http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels.
            </summary>
            <param name="rng">The RNG to use.  Defaults to <see cref="F:GoRogue.Random.GlobalRandom.DefaultRNG"/>.</param>
            <param name="fillProbability">
            Represents the percent chance that a given cell will be a floor cell when the map is initially randomly
            filled. Recommended to be in range [40, 60].
            </param>
            <param name="totalIterations">
            Total number of times the cellular automata-based smoothing algorithm is executed.  Recommended to be in
            range [2, 10].
            </param>
            <param name="cutoffBigAreaFill">
            Total number of times the cellular automata smoothing variation that is more likely to
            result in "breaking up" large areas will be run before switching to the more standard
            nearest neighbors version. Must be less than or equal to <paramref name="totalIterations"/>.
            Recommended to be in range [2, 7].
            </param>
            <param name="distanceCalculation">
            The distance calculation that determines distance/neighbors for determining unique areas and connecting
            them.  Defaults to <see cref="F:SadRogue.Primitives.Distance.Manhattan"/>.
            </param>
            <param name="connectionPointSelector">
            The area connection strategy to use. Not all methods function on maps with concave areas
            -- see respective class documentation for details.  Defaults to using a
            <see cref="T:GoRogue.MapGeneration.ConnectionPointSelectors.RandomConnectionPointSelector"/>.
            </param>
            <param name="tunnelCreationMethod">
            The tunnel creation strategy to use. Defaults to <see cref="T:GoRogue.MapGeneration.TunnelCreators.DirectLineTunnelCreator" /> with
            given distance's adjacency rules.
            </param>
            <returns>A set of map generation steps that generate a cave-like map using the cellular automata algorithm.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.DefaultAlgorithms.RectangleMapSteps">
            <summary>
            Generates a simple map that is a hollowed-out rectangle surrounded by walls.
            </summary>
            <returns>A set of map generation steps that generate a simple map composed of a hollowed out rectangle
            surrounded by walls.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.GenerationContext">
            <summary>
            A context object used for map generation.  Map generation steps will require and retrieve components that have
            been added to this context when they need to retrieve data about the map generated by previous steps.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.GenerationContext.Height">
            <summary>
            Height of the map this context represents.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.GenerationContext.Width">
            <summary>
            Width of the map this context represents.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationContext.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a map context with no components, with the given width/height values.
            </summary>
            <param name="width">The width of the map this context represents.</param>
            <param name="height">The height of the map this context represents.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationContext.GetFirstOrNew``1(System.Func{``0},System.String)">
            <summary>
            Retrieves a context component (optionally with a given tag), or utilizes the specified function to create a
            new one and adds it if an existing one does not exist.
            </summary>
            <typeparam name="TComponent">Type of component to retrieve.</typeparam>
            <param name="newFunc">Function to use to create a new component, if there is no existing component.</param>
            <param name="tag">
            An optional tag that must be associated with the retrieved or created component.  If null is specified, no
            tag is associated with a new object, and any object meeting the type requirement will be allowed as the
            return value.
            </param>
            <returns>
            An existing component of the appropriate type if one exists, or the newly created/added component if not.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.InvalidConfigurationException">
            <summary>
            Raised by generation steps in <see cref="M:GoRogue.MapGeneration.GenerationStep.OnPerform(GoRogue.MapGeneration.GenerationContext)" /> when a parameter has been
            misconfigured.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.InvalidConfigurationException.#ctor(System.String)">
            <summary>
            Creates a configuration exception with a customized message.
            </summary>
            <param name="message" />
        </member>
        <member name="M:GoRogue.MapGeneration.InvalidConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a configuration exception with a customized message an inner exception.
            </summary>
            <param name="message" />
            <param name="innerException" />
        </member>
        <member name="M:GoRogue.MapGeneration.InvalidConfigurationException.#ctor(GoRogue.MapGeneration.GenerationStep,System.String,System.String)">
            <summary>
            Creates a configuration exception with a helpful message.
            </summary>
            <param name="step">The generation step that the misconfigured parameter was encountered in.</param>
            <param name="parameterName">The name of the misconfigured parameter.</param>
            <param name="message">A message explaining the requirements for the parameter's value.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.InvalidConfigurationException.#ctor">
            <summary>
            Creates an empty configuration exception.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.InvalidConfigurationException.ParameterName">
            <summary>
            Name of parameter that was misconfigured.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.InvalidConfigurationException.Step">
            <summary>
            Generation step that had a misconfigured parameter.
            </summary>
        </member>
        <member name="T:GoRogue.MapGeneration.MissingContextComponentException">
            <summary>
            Raised by <see cref="T:GoRogue.MapGeneration.GenerationStep" /> when required components are not present when
            <see cref="M:GoRogue.MapGeneration.GenerationStep.PerformStep(GoRogue.MapGeneration.GenerationContext)" /> is called.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MissingContextComponentException.RequiredComponentTag">
            <summary>
            Tag of the required component that was not found, or null if no tag was required.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MissingContextComponentException.RequiredComponentType">
            <summary>
            Type of the required component that was not found.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MissingContextComponentException.Step">
            <summary>
            Generation step that failed to find its required components.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MissingContextComponentException.#ctor(GoRogue.MapGeneration.GenerationStep,System.Type,System.String)">
            <summary>
            Creates a new exception with a helpful error message.
            </summary>
            <param name="step">Generation step that failed to find its required components.</param>
            <param name="requiredComponentType">Type of the required component that was not found.</param>
            <param name="requiredComponentTag">Tag of the required component that was not found, or null if no tag was required.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MissingContextComponentException.#ctor(System.String)">
            <summary>
            Creates an exception with a fully customized message.
            </summary>
            <param name="message" />
        </member>
        <member name="M:GoRogue.MapGeneration.MissingContextComponentException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an exception with a fully customized message and inner exception.
            </summary>
            <param name="message" />
            <param name="innerException" />
        </member>
        <member name="M:GoRogue.MapGeneration.MissingContextComponentException.#ctor">
            <summary>
            Creates an empty exception.
            </summary>
        </member>
        <member name="T:GoRogue.MapGeneration.RegenerateMapException">
            <summary>
            Raised by map generation steps if they detect that an invalid state (that can occasionally happen) is detected,
            and the map should be regenerated.  Automatically used by the <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> and
            <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGetStageEnumeratorSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> functions.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.RegenerateMapException.#ctor">
            <summary>
            Creates map regeneration exception with no message.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.RegenerateMapException.#ctor(System.String)">
            <summary>
            Creates a map regeneration exception with a customized message.
            </summary>
            <param name="message" />
        </member>
        <member name="M:GoRogue.MapGeneration.RegenerateMapException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a map regeneration exception with a customized message an inner exception.
            </summary>
            <param name="message" />
            <param name="innerException" />
        </member>
        <member name="T:GoRogue.MapGeneration.GenerationStep">
            <summary>
            Base class for implementing custom map generation steps.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.GenerationStep.Name">
            <summary>
            The name of the generation step.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationStep.#ctor(System.String)">
            <summary>
            Creates a generation step, optionally with a custom name.
            </summary>
            <param name="name">The name of the generation step being created.  Defaults to the name of the (runtime) class.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationStep.#ctor(System.String,System.Type[])">
            <summary>
            Creates a generation step that requires the given component(s) on the <see cref="T:GoRogue.MapGeneration.GenerationContext" /> to
            function.
            </summary>
            <param name="name">
            The name of the generation step being created.  Defaults to the name of the (runtime) class.
            </param>
            <param name="requiredComponents">
            Components (and associated tags) that <see cref="M:GoRogue.MapGeneration.GenerationStep.OnPerform(GoRogue.MapGeneration.GenerationContext)" /> will require from the
            context.  Null specified as a tag means no particular tag is required; only a component of the given type.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationStep.#ctor(System.String,GoRogue.Components.ComponentTypeTagPair[])">
            <summary>
            Creates a generation step that requires the given component(s) on the <see cref="T:GoRogue.MapGeneration.GenerationContext" /> to function.
            </summary>
            <param name="requiredComponents">
            Components that <see cref="M:GoRogue.MapGeneration.GenerationStep.OnPerform(GoRogue.MapGeneration.GenerationContext)" /> will require from the context, and the tag
            required for each component.  Null means no particular tag is required.
            </param>
            <param name="name">The name of the generation step being created.  Defaults to the name of the (runtime) class.</param>
        </member>
        <member name="P:GoRogue.MapGeneration.GenerationStep.RequiredComponents">
            <summary>
            Components that are required and enforced to be on the <see cref="T:GoRogue.MapGeneration.GenerationContext" /> when it is passed to
            <see cref="M:GoRogue.MapGeneration.GenerationStep.OnPerform(GoRogue.MapGeneration.GenerationContext)" />.
            Each component may optionally have a required tag.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationStep.PerformStep(GoRogue.MapGeneration.GenerationContext)">
            <summary>
            Performs the generation step on the given map context.  Throws exception if a required component is missing.
            This function is not virtual -- to implement actual generation logic, implement
            <see cref="M:GoRogue.MapGeneration.GenerationStep.OnPerform(GoRogue.MapGeneration.GenerationContext)" />.
            </summary>
            <param name="context">Context to perform the generation step on.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationStep.GetStageEnumerator(GoRogue.MapGeneration.GenerationContext)">
            <summary>
            Return an enumerator that, when evaluated to completion, will perform each "stage" of the generation step
            sequentially.
            </summary>
            <param name="context">Context to perform the generation step on.</param>
            <returns>An enumerator which, when evaluated, performs each stage of the step sequentially.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.GenerationStep.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <summary>
            Implement to perform the actual work of the generation step.  Use "yield return null" to indicate the end
            of a "stage", eg. a point where execution can be paused when using
            <see cref="M:GoRogue.MapGeneration.Generator.GetStageEnumerator"/>.
            </summary>
            <param name="context">Context to perform the generation step on.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.MapGenerationFailedException">
            <summary>
            Exception thrown when maximum retries for map generation is reached.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapGenerationFailedException.#ctor">
            <summary>
            Creates map gen failed exception with no message.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapGenerationFailedException.#ctor(System.String)">
            <summary>
            Creates a map gen failed exception with a customized message.
            </summary>
            <param name="message" />
        </member>
        <member name="M:GoRogue.MapGeneration.MapGenerationFailedException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a map gen failed exception with a customized message an inner exception.
            </summary>
            <param name="message" />
            <param name="innerException" />
        </member>
        <member name="T:GoRogue.MapGeneration.Generator">
            <summary>
            Map generator that applies a series of <see cref="T:GoRogue.MapGeneration.GenerationStep" /> instances to a
            <see cref="T:GoRogue.MapGeneration.GenerationContext" /> to generate a map.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Generator.Context">
            <summary>
            Context for the map this <see cref="T:GoRogue.MapGeneration.Generator" /> is generating.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a generator that will be used to generate a map of the given width/height.
            </summary>
            <param name="width">Width of the generated map.</param>
            <param name="height">Height of the generated map.</param>
        </member>
        <member name="P:GoRogue.MapGeneration.Generator.GenerationSteps">
            <summary>
            Steps used to generate the map.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.AddComponent(System.Object,System.String)">
            <summary>
            Adds a component to the context this generator is applying generation steps to.
            </summary>
            <param name="component">Component to add to the map context.</param>
            <param name="tag">An optional tag to give the component.  Defaults to no tag.</param>
            <returns>This generator (for chaining).</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.AddStep(GoRogue.MapGeneration.GenerationStep)">
            <summary>
            Adds a generation step.  Steps are executed in the order they are added.
            </summary>
            <param name="step">The generation step to add.</param>
            <returns>This generator (for chaining).</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.AddSteps(GoRogue.MapGeneration.GenerationStep[])">
            <summary>
            Adds the given generation steps.  Steps are executed in the order they are added.
            </summary>
            <param name="steps">The generation steps to add.</param>
            <returns>This generator (for chaining).</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.AddSteps(System.Collections.Generic.IEnumerable{GoRogue.MapGeneration.GenerationStep})">
            <summary>
            Adds the given generation steps.  Steps are executed in the order they are added.
            </summary>
            <param name="steps">The generation steps to add.</param>
            <returns>This generator (for chaining).</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.Clear">
            <summary>
            Clears the context and generation steps, resetting the generator back to a pre-configured state.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.Generate">
            <summary>
            Applies the generation steps added, in the order in which they were added, to the <see cref="F:GoRogue.MapGeneration.Generator.Context" /> to
            generate the map.  If you want to automatically handle <see cref="T:GoRogue.MapGeneration.RegenerateMapException"/>, call
            <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> instead.
            </summary>
            <remarks>
            Depending on the generation steps used, this function may throw RegenerateMapException if it detects
            that the map generated does not meet invariants due to RNG, in which case the map generation will need
            to be performed again.  See <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> for a method of ensuring this happens
            in a convenient way.
            </remarks>
            <returns>This generator (for chaining).</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)">
             <summary>
             Calls the <paramref name="generatorConfig"/> function to add components/steps to the generator, then calls
             <see cref="M:GoRogue.MapGeneration.Generator.Generate"/>.  If a <see cref="T:GoRogue.MapGeneration.RegenerateMapException"/> is thrown, re-generates the map by
             calling the configure function then generate again, up to the maximum retries specified.
             </summary>
             <remarks>
             This is a safe wrapper to work with generation procedures that can get themselves into an invalid state
             that requires re-generating the entire map.  Generation steps are clearly marked in documentation if they
             can produce such states.
            
             Ensure you do NOT create/use an RNG with a static seed within this function, as it could easily create
             an infinite loop (that would re-generate the same invalid map over and over).
             </remarks>
             <param name="generatorConfig">Function to configure the generator.</param>
             <param name="maxAttempts">Maximum times to attempt map generation, before throwing a MapGenerationFailed
             exception.  Defaults to infinite.</param>
             <returns>This generator (for chaining).</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.GetStageEnumerator">
             <summary>
             Returns an enumerator that, when evaluated to completion, performs each stage sequentially (as defined
             by the generation steps in their implementation); one stage per MoveNext call.
             Typically you will want to use <see cref="M:GoRogue.MapGeneration.Generator.Generate"/> instead.  If you want to automatically handle
             <see cref="T:GoRogue.MapGeneration.RegenerateMapException"/>, call <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGetStageEnumeratorSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> or
             <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> instead as applicable.
             </summary>
             <remarks>
             For traditional cases, you will want to call the <see cref="M:GoRogue.MapGeneration.Generator.Generate"/> function which simply completes
             all steps.  However, if you want to visually examine each stage of the generation algorithm, you can call
             this function, then call the resulting enumerator's MoveNext function each time you want to complete a
             stage.  This can be useful for demonstration purposes and debugging.
            
             Note that a <see cref="T:GoRogue.MapGeneration.RegenerateMapException"/> may be raised during this iteration, and it must be handled
             manually.  See <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGetStageEnumeratorSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/>  for a method of handling this automatically.
             </remarks>
             <returns>
             An enumerator that will complete a stage of the generation step each time its MoveNext function
             is called.
             </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generator.ConfigAndGetStageEnumeratorSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)">
            <summary>
            Calls the <paramref name="generatorConfig"/> function to add components/steps to the generator, then calls
            <see cref="M:GoRogue.MapGeneration.Generator.GetStageEnumerator"/> and evaluates its enumerator, returning at each step.  Restarts map
            generation automatically if <see cref="T:GoRogue.MapGeneration.RegenerateMapException"/> is thrown. Typically you will want
            to use <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> instead.
            </summary>
            <remarks>
            For traditional cases, you will want to call the <see cref="M:GoRogue.MapGeneration.Generator.ConfigAndGenerateSafe(System.Action{GoRogue.MapGeneration.Generator},System.Int32)"/> function which
            takes the same parameters and simply completes all steps.  However, if you want to visually examine each
            stage of the generation algorithm, you can call this function, then call the resulting enumerator's MoveNext
            function each time you want to complete a stage.  This can be useful for demonstration purposes and debugging.
            </remarks>
            <param name="generatorConfig">Function to configure the generator.</param>
            <param name="maxAttempts">Maximum times to attempt map generation, before throwing a MapGenerationFailed
            exception.  Defaults to infinite.</param>
            <returns>
            An enumerator that will complete a stage of the generation step each time its MoveNext function
            is called.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.IReadOnlyMultiArea">
            <summary>
            A interface adding onto IReadOnlyArea, intended to represent an area consisting of multiple other areas.
            Exposes a <see cref="P:GoRogue.MapGeneration.IReadOnlyMultiArea.SubAreas"/> field which lists the constituent areas.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMultiArea.SubAreas">
            <summary>
            List of all sub-areas in the MultiArea.
            </summary>
        </member>
        <member name="T:GoRogue.MapGeneration.MapAreaFinder">
            <summary>
            Class designed to calculate and produce a list of Areas representing each unique connected
            area of the map.
            </summary>
            <remarks>
            The class takes in an <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" />, where a value of true for a given position indicates it
            should be part of a map area, and false indicates it should not be part of any map area. In a
            classic roguelike dungeon example, this might be a view of "walkability" where floors return a
            value of true and walls return a value of false.
            </remarks>
        </member>
        <member name="P:GoRogue.MapGeneration.MapAreaFinder.AdjacencyMethod">
            <summary>
            The method used for determining connectivity of the grid.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MapAreaFinder.PointHasher">
            <summary>
            Point hashing algorithm to use for the areas created.  If set to null, the default point hashing algorithm
            will be used.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MapAreaFinder.AreasView">
            <summary>
            Grid view indicating which cells should be considered part of a map area and which should not.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.AdjacencyRule,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})">
            <summary>
            Constructor.
            </summary>
            <param name="areasView">
            Grid view indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
            <param name="pointHasher">
            Point hashing algorithm to use for the areas created.  If set to null the default point hashing algorithm
            will be used.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.MapAreasFor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.AdjacencyRule,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})">
            <summary>
            Convenience function that creates a MapAreaFinder and returns the result of that
            instances <see cref="M:GoRogue.MapGeneration.MapAreaFinder.MapAreas(System.Boolean)" /> function. Intended to be used for cases in which the area finder
            will never be re-used.
            </summary>
            <param name="map">
            Grid view indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
            <param name="pointHasher">
            Point hashing algorithm to use for the areas created.  If set to null the default point hashing algorithm
            will be used.
            </param>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.FillFrom(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.AdjacencyRule,SadRogue.Primitives.Point,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})">
            <summary>
            Convenience function that creates a MapAreaFinder and returns the result of that
            instance's <see cref="M:GoRogue.MapGeneration.MapAreaFinder.FillFrom(SadRogue.Primitives.Point,System.Boolean)" /> function. Intended to be used for cases
            in which the area finder will never be re-used.
            </summary>
            <param name="map">
            Grid view indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
            <param name="position">The position to start from.</param>
            <param name="pointHasher">
            Point hashing algorithm to use for the areas created.  If set to null the default point hashing algorithm
            will be used.
            </param>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.MapAreas(System.Boolean)">
            <summary>
            Calculates the list of map areas, returning each unique map area.
            </summary>
            <param name="clearVisited">
            Whether or not to reset all cells to unvisited before finding areas.  Visited positions cannot be included
            in any of the resulting areas.
            </param>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.FillFrom(SadRogue.Primitives.Point,System.Boolean)">
            <summary>
            Calculates and returns an area representing every point connected to the start point given.
            </summary>
            <param name="position">Position to start from.</param>
            <param name="clearVisited">
            Whether or not to reset all cells to unvisited before finding areas.  Visited positions cannot be included
            in the resulting area.
            </param>
            <returns>
            An area representing every point connected to the start point given, or null if there is no
            valid area starting from that point.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.ResetVisitedPositions">
            <summary>
            Resets all positions to "unvisited".  Called automatically if area-finding algorithms have the reset flag
            set to true.
            </summary>
        </member>
        <member name="T:GoRogue.MapGeneration.MultiArea">
            <summary>
            A class implementing the <see cref="T:GoRogue.MapGeneration.IReadOnlyMultiArea"/> interface, that derives its area from multiple
            "sub-areas".
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MultiArea.SubAreas">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.MapGeneration.MultiArea.Bounds">
            <summary>
            Smallest possible rectangle that encompasses every position in every sub-area.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MultiArea.Count">
            <summary>
            Number of positions in all of this area's sub-areas combined.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MultiArea.UseIndexEnumeration">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.MapGeneration.MultiArea.Item(System.Int32)">
            <summary>
            Returns positions from the area (via its sub-areas) in the same fashion you would via a list.
            </summary>
            <remarks>
            The indexing scheme considers index 0 to be index 0 in the first sub-area in <see cref="P:GoRogue.MapGeneration.MultiArea.SubAreas"/>.
            The indices proceed in increasing order across all points in that sub-area, then roll over into the next
             one.  Eg. index [SubAreas[0].Count] is actually index 0 in the second sub-area, ie. SubAreas[1][0].
            </remarks>
            <param name="index">Index of position to retrieve.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.#ctor">
            <summary>
            Creates an area with no points/subareas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.#ctor(SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Creates a MultiArea that has only the given sub-area.
            </summary>
            <param name="area">Sub-area to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.#ctor(System.Collections.Generic.IEnumerable{SadRogue.Primitives.IReadOnlyArea})">
            <summary>
            Creates a multi-area that is comprised of the given sub-areas.
            </summary>
            <param name="areas">Sub-areas to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Add(SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Adds the given sub-area to the MultiArea.
            </summary>
            <param name="subArea">The sub-area to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.AddRange(System.Collections.Generic.IEnumerable{SadRogue.Primitives.IReadOnlyArea})">
            <summary>
            Adds the given sub-areas to the MultiArea.
            </summary>
            <param name="subAreas">The sub-areas to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Clear">
            <summary>
            Clears all sub-areas from the MultiArea.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Remove(SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Removes the given sub-area from the MultiArea.
            </summary>
            <param name="subArea">The sub-area to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Matches(SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Compares for equality. Returns true if the two areas contain exactly the same points.
            </summary>
            <param name="other"/>
            <returns>True if the areas contain exactly the same points, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through all positions in all sub-areas.
            </summary>
            <returns>An enumerator that iterates through all positions in all sub-areas.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through all positions in all sub-areas.
            </summary>
            <returns>An enumerator that iterates through all positions in all sub-areas.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Contains(SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Returns whether or not the given area is completely contained within the summation of this area's subareas.
            </summary>
            <param name="area">Area to check.</param>
            <returns>
            True if the all of the given area's points are contained within one or more subareas, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Contains(SadRogue.Primitives.Point)">
            <summary>
            Determines whether or not the given position is considered within one of this area's subareas or not.
            </summary>
            <param name="position">The position to check.</param>
            <returns>True if the specified position is within one of the subareas, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Contains(System.Int32,System.Int32)">
            <summary>
            Determines whether or not the given position is considered within one of this area's subareas or not.
            </summary>
            <param name="positionX">X-value of the position to check.</param>
            <param name="positionY">X-value of the position to check.</param>
            <returns>True if the specified position is within one of the subareas, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MultiArea.Intersects(SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Returns whether or not the given map area intersects any of this area's subareas. If you intend to
            determine/use the exact intersection based on this return value, it is best to instead
            call <see cref="M:SadRogue.Primitives.Area.GetIntersection(SadRogue.Primitives.IReadOnlyArea,SadRogue.Primitives.IReadOnlyArea,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})"/>, and check the number
            of positions in the result (0 if no intersection).
            </summary>
            <param name="area">The area to check.</param>
            <returns>True if the given area intersects one of the current one's subareas, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.PolygonArea">
            <summary>
            An area with an arbitrary number of sides and corners
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Corners">
            <summary>
            The corners of this polygon
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.OuterPoints">
            <summary>
            The exterior points of the polygon
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.InnerPoints">
            <summary>
            The interior points of the polygon
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.PolygonArea.LineAlgorithm">
            <summary>
            Which Line-Drawing algorithm to use
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Bounds">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Count">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.UseIndexEnumeration">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Left">
            <summary>
            The left-most X-value of the Polygon
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Right">
            <summary>
            The right-most X-value of the Polygon
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Top">
            <summary>
            The top-most Y-value of the Polygon
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Bottom">
            <summary>
            The bottom-most Y-value of the Polygon
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Width">
            <summary>
            How Wide this Polygon is
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Height">
            <summary>
            how tall this Polygon is
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.PolygonArea.Center">
            <summary>
            The Center point of this Polygon
            </summary>
            <remarks>There is no guarantee that the center point lies within the polygon</remarks>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.IsCorner(SadRogue.Primitives.Point)">
            <summary>
            Returns true if the position provided is a corner of this polygon
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.ToString">
            <summary>
            Returns a string detailing the region's corner locations.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.#ctor(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point},SadRogue.Primitives.Lines.Algorithm)">
            <summary>
            Creates a new Polygon, with corners at the provided points
            </summary>
            <param name="corners">Each corner of the polygon, which is copied into a new list</param>
            <param name="algorithm">Which Line Algorithm to use</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.#ctor(System.Collections.Generic.List{SadRogue.Primitives.Point}@,SadRogue.Primitives.Lines.Algorithm)">
            <summary>
            Creates a new Polygon, with corners at the provided points
            </summary>
            <param name="corners">The corners of this polygon</param>
            <param name="algorithm">Which Line Algorithm to use</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.#ctor(SadRogue.Primitives.Lines.Algorithm,SadRogue.Primitives.Point[])">
            <summary>
            Returns a new PolygonArea with corners at the provided points.
            </summary>
            <param name="algorithm">Which Line-drawing algorithm to use</param>
            <param name="corners">The points which are corners for this polygon</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.#ctor(SadRogue.Primitives.Point[])">
            <summary>
            Returns a new polygon with corners at the provided points, using the algorithm DDA to produce lines
            </summary>
            <param name="corners">The corners of the polygon</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Rectangle(SadRogue.Primitives.Rectangle,SadRogue.Primitives.Lines.Algorithm)">
            <summary>
            Creates a new Polygon from a GoRogue.Rectangle.
            </summary>
            <param name="rectangle">The rectangle</param>
            <param name="algorithm">Line-drawing algorithm to use for finding boundaries.</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
            <returns>A new Polygon in the shape of a rectangle</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Parallelogram(SadRogue.Primitives.Point,System.Int32,System.Int32,System.Boolean,SadRogue.Primitives.Lines.Algorithm)">
            <summary>
            Creates a new Polygon in the shape of a parallelogram.
            </summary>
            <param name="origin">Origin of the parallelogram.</param>
            <param name="width">Width of the parallelogram.</param>
            <param name="height">Height of the parallelogram.</param>
            <param name="fromTop">Whether the parallelogram extends downward-right or upwards-right from the start</param>
            <param name="algorithm">Line-drawing algorithm to use for finding boundaries.</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
            <returns>A new Polygon in the shape of a parallelogram</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.RegularPolygon(SadRogue.Primitives.Point,System.Int32,System.Double,SadRogue.Primitives.Lines.Algorithm)">
            <summary>
            Creates a polygon whose sides are even-length
            </summary>
            <param name="center">The center point of this polygon</param>
            <param name="numberOfSides">Number of sides and corners on this polygon</param>
            <param name="radius">The desired distance between the center and each corner</param>
            <exception cref="T:System.ArgumentException">Must have 3 or more corners; Algorithm must produce ordered lines.</exception>
            <param name="algorithm">Which line-drawing algorithm to use</param>
            <returns></returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.RegularStar(SadRogue.Primitives.Point,System.Int32,System.Double,System.Double,SadRogue.Primitives.Lines.Algorithm)">
            <summary>
            Creates a new star-shaped polygon
            </summary>
            <param name="center">The center point of the star</param>
            <param name="points">How many points this star has</param>
            <param name="outerRadius">The distance between the center and a tip of the star</param>
            <param name="innerRadius">The distance between the center and an armpit of the star</param>
            <param name="algorithm">Which line-drawing algorithm to use</param>
            <exception cref="T:System.ArgumentException">Stars must have 3 or more points; algorithm must be ordered; inner and outer radius must be positive</exception>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Matches(SadRogue.Primitives.IReadOnlyArea)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Contains(SadRogue.Primitives.IReadOnlyArea)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Contains(SadRogue.Primitives.Point)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Contains(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Intersects(SadRogue.Primitives.IReadOnlyArea)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Matches(GoRogue.MapGeneration.PolygonArea)">
            <summary>
            Compares the polygons to ensure that they are defined by the same corners, and thus represent the same area.
            </summary>
            <param name="other"/>
            <returns>True if the polygons represent the same area; false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Translate(System.Int32,System.Int32)">
            <summary>
            Moves the Polygon in the indicated direction.
            </summary>
            <param name="dx">The X-value by which to shift</param>
            <param name="dy">The Y-value by which to shift</param>
            <returns></returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Translate(SadRogue.Primitives.Point)">
            <summary>
            Moves the Polygon in the indicated direction.
            </summary>
            <param name="delta">The amount (X and Y) to translate by.</param>
            <returns>A new, translated PolygonArea</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Rotate(System.Double)">
            <summary>
            Rotates the Polygon around it's center.
            </summary>
            <param name="degrees">The amount of degrees to rotate</param>
            <returns>A new, rotated PolygonArea</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Rotate(System.Double,SadRogue.Primitives.Point)">
            <summary>
            Rotates the Polygon around a point of origin
            </summary>
            <param name="degrees">The amount of degrees to rotate</param>
            <param name="origin">The Point around which to rotate</param>
            <returns>A new, rotated PolygonArea</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.FlipHorizontal(System.Int32)">
            <summary>
            Flip horizontally around an X-axis
            </summary>
            <param name="x">The value around which to flip.</param>
            <returns>A new, flipped PolygonArea</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.FlipVertical(System.Int32)">
            <summary>
            Flip vertically around a Y-axis
            </summary>
            <param name="y">The value around which to flip.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Transpose(System.Int32,System.Int32)">
            <summary>
            Invert the X and Y values of a Polygon, respective to a diagonal line
            </summary>
            <param name="x">Any X-value of a point which intersects the line around which to transpose</param>
            <param name="y">Any Y-value of a Point which intersects the line around which to transpose</param>
            <returns>A new PolygonArea</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.PolygonArea.Transpose(SadRogue.Primitives.Point)">
            <summary>
            Invert the X and Y values of a Polygon, respective to a diagonal line
            </summary>
            <param name="xy">Any point which intersects the line around which to transpose</param>
            <returns>A new PolygonArea</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.RectangleEdgePositionsList">
            <summary>
            An arbitrary list of any number of positions on the perimeter of a rectangle.  Commonly used to represent a list of
            doors or edges of rooms by
            some map generation steps.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.RectangleEdgePositionsList.Rectangle">
            <summary>
            The rectangle whose edge positions are being stored.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.#ctor(SadRogue.Primitives.Rectangle)">
            <summary>
            Creates a empty list of perimeter for a given rectangle.
            </summary>
            <param name="rectangle">The rectangle the structure stores perimeter positions for.</param>
        </member>
        <member name="P:GoRogue.MapGeneration.RectangleEdgePositionsList.TopPositions">
            <summary>
            Positions on the top edge of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.RectangleEdgePositionsList.RightPositions">
            <summary>
            Positions of doors on the right wall of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.RectangleEdgePositionsList.BottomPositions">
            <summary>
            Positions of doors on the bottom wall of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.RectangleEdgePositionsList.LeftPositions">
            <summary>
            Positions of doors on the bottom wall of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.RectangleEdgePositionsList.Positions">
            <summary>
            Positions being stored, with no duplicate locations.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.RectangleEdgePositionsList.Item(SadRogue.Primitives.Direction)">
            <summary>
            Retrieves a read-only list of stored positions on the given side.  Direction specified must be a cardinal.
            </summary>
            <param name="side">Side to get stored positions for.</param>
            <returns>A read-only list of stored positions on the given side.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.Add(SadRogue.Primitives.Point)">
            <summary>
            Adds the given position to the appropriate lists of positions.
            </summary>
            <param name="perimeterPosition">Position to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.AddRange(SadRogue.Primitives.Point[])">
            <summary>
            Adds the given positions to the appropriate lists of positions.
            </summary>
            <param name="perimeterPositions">Positions to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.AddRange(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point})">
            <summary>
            Adds the given positions to the appropriate lists of positions.
            </summary>
            <param name="perimeterPositions">Positions to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.Remove(SadRogue.Primitives.Point)">
            <summary>
            Removes the given position from the data structure.
            </summary>
            <param name="perimeterPosition">Position to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.RemoveRange(SadRogue.Primitives.Point[])">
            <summary>
            Removes the given positions from the data structure.
            </summary>
            <param name="perimeterPositions">Positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.RemoveRange(System.Collections.Generic.IEnumerable{SadRogue.Primitives.Point})">
            <summary>
            Removes the given positions from the data structure.
            </summary>
            <param name="perimeterPositions">Positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.Contains(SadRogue.Primitives.Point)">
            <summary>
            Returns whether or not the structure contains the given position.
            </summary>
            <param name="position" />
            <returns>Whether or not the structure contains the position specified.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.GetEnumerator">
            <summary>
            Gets an enumerator of all positions in the data structure.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.MapGeneration.RectangleEdgePositionsList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator of all positions in the data structure.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.MapGeneration.RegionAreaChangedEventArgs">
            <summary>
            Event fired when a region's Area is changed.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.RegionAreaChangedEventArgs.OldValue">
            <summary>
            The previous Area
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.RegionAreaChangedEventArgs.NewValue">
            <summary>
            The Area to which we update
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.RegionAreaChangedEventArgs.#ctor(GoRogue.MapGeneration.PolygonArea,GoRogue.MapGeneration.PolygonArea)">
            <summary>
            The Event Arguments for when a region's area is changed
            </summary>
            <param name="oldValue">The former value of the Area</param>
            <param name="newValue">The new value of the Area</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Region">
            <summary>
            A region of the map with four sides of arbitrary shape and size
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.Region.Area">
            <summary>
            The Area of this region
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Region.AreaChanged">
            <summary>
            Fired when the Area is changed.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.Region.GoRogueComponents">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.MapGeneration.Region.#ctor(GoRogue.MapGeneration.PolygonArea,GoRogue.Components.IComponentCollection)">
            <summary>
            Returns a new Region using the provided area
            </summary>
            <param name="area">This region's Area</param>
            <param name="components">A component collection for this region</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Region.ToString">
            <summary>
            Returns a string detailing the region's corner locations.
            </summary>
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.AreaFinder">
            <summary>
            Finds the distinct areas in the boolean grid view specified, and adds them to the item list with the tag
            specified.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.AreaFinder.GridViewComponentTag">
            <summary>
            Optional tag that must be associated with the grid view used to find areas.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.AreaFinder.AreasComponentTag">
            <summary>
            Optional tag that must be associated with the component used to store areas found by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.AreaFinder.AdjacencyMethod">
            <summary>
            The adjacency method to use for determining whether two locations are in the same area.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.AreaFinder.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new AreaFinder generation step.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.AreaFinder"/></param>
            <param name="gridViewComponentTag">
            Optional tag that must be associated with the grid view used to find areas.
            Defaults to "WallFloor".
            </param>
            <param name="areasComponentTag">
            Optional tag that must be associated with the component used to store areas found by this algorithm.
            Defaults to "Areas".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.AreaFinder.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration">
            <summary>
            Uses a cellular automata smoothing algorithm to smooth areas on the given map.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.AreaAdjacencyRule">
            <summary>
            The adjacency rule to use to determine the unique areas generated by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.TotalIterations">
            <summary>
            Total number of times the cellular automata-based smoothing algorithm is executed.
            Recommended to be in range [2, 10].
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.CutoffBigAreaFill">
            <summary>
            Total number of times the cellular automata smoothing variation that is more likely to
            result in "breaking up" large areas will be run before switching to the more standard
            nearest neighbors version. Must be less than or equal to <see cref="F:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.TotalIterations"/>.
            Recommended to be in range [2, 7].
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.#ctor(System.String,System.String)">
             <summary>
             Creates a new cellular automata based area generation step.
             </summary>
             <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration" />.</param>
            
             <param name="wallFloorComponentTag">
             Optional tag that must be associated with the map view component used to store/set
             floor/wall status.  Defaults to "WallFloor".
             </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.CellularAutomataAreaGeneration.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection">
            <summary>
            Connects areas of the map by connecting each area to its closest neighboring area, with distance between areas based on
            the connection point selector specified.
            Context Components Required:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <description>Default Tag</description>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />
                    </term>
                    <description>"Areas"</description>
                </item>
                <item>
                    <term><see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> where T is bool</term>
                    <description>"WallFloor"</description>
                </item>
            </list>
            Context Components Added/Used:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <description>Default Tag</description>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />
                    </term>
                    <description>"Tunnels"</description>
                </item>
            </list>
            In the case of the tunnels component, an existing component is used if an appropriate one is present; a new one is
            added if not.
            </summary>
            <remarks>
            This generation steps takes as input a <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> context component (with the tag "Areas", by
            default) containing areas to connect, and "WallFloor" map view context component
            that indicates wall/floor status for each location on the map.  It then connects the map areas in the list, generating
            tunnels in the process.  Each location comprising
            the generated tunnels is set to "true" in the "WallFloor" component.  Additionally, an <see cref="T:SadRogue.Primitives.Area" /> representing
            each tunnel created is added to the <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> context
            component (with the tag "Tunnels", by default).
            If an appropriate component with the specified tag exists for the resulting tunnels, the Areas are added to that
            component.  Otherwise, a new component is created.
            Areas are connected by drawing a tunnel between each Area and its closest neighboring area, based on distance
            between the points selected by the given <see cref="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.ConnectionPointSelector"/>.  The actual points selected in
            each area to connect, as well as the method for drawing tunnels between those areas, is customizable via the
            <see cref="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.ConnectionPointSelector" /> and <see cref="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.TunnelCreator" /> parameters.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.AreasComponentTag">
            <summary>
            Optional tag that must be associated with the component used to store map areas connected by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.TunnelsComponentTag">
            <summary>
            Optional tag that must be associated with the component created/used to store the tunnels created by this connection
            method.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.ConnectionPointSelector">
            <summary>
            The area connection strategy to use. Not all methods function on maps with concave areas
            -- see respective class documentation for details.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.DistanceCalc">
            <summary>
            The distance calculation that defines distance/neighbors.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.TunnelCreator">
            <summary>
            The tunnel creation strategy to use. Defaults to <see cref="T:GoRogue.MapGeneration.TunnelCreators.DirectLineTunnelCreator" /> with
            the cardinal adjacency rules.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new closest area connection step.
            </summary>
            <param name="name">>The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection" />.</param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the map view component used to store/set
            floor/wall status.  Defaults to "WallFloor".
            </param>
            <param name="areasComponentTag">
            Optional tag that must be associated with the component used to store map areas
            connected by this algorithm.  Defaults to "Areas".
            </param>
            <param name="tunnelsComponentTag">
            Optional tag that must be associated with the component created/used to store the
            tunnels created by this connection method.  Defaults to "Tunnels".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.ClosestMapAreaConnection.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.DoorFinder">
            <summary>
            Finds the locations of open walls in rectangular rooms that constitute doorways.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.DoorFinder.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the grid view used to find openings in room walls.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.DoorFinder.RoomsComponentTag">
            <summary>
            Optional tag that must be associated with the component used to store rectangular rooms that it generates
            door locations for.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.DoorFinder.DoorsListComponentTag">
            <summary>
            Optional tag that must be associated with the component created/used to record the door locations found by
            this algorithm.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.DoorFinder.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a door finder generation step.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.DoorFinder"/></param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the grid view used to find whether room walls are open.
            Defaults to "WallFloor".
            </param>
            <param name="roomsComponentTag">
            Optional tag that must be associated with the component used to store the rectangular rooms this algorithm
            finds openings for.  Defaults to "Rooms".
            </param>
            <param name="doorsListComponentTag">
            Optional tag that must be associated with the component created/used to record the door locations found
            by this algorithm.  Defaults to "Doors".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.DoorFinder.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.MazeGeneration">
            <summary>
            Generates a maze in the wall areas of a map, using crawlers that walk the map carving tunnels.
            Context Components Required:
            - None
            Context Components Added/Used:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <description>Default Tag</description>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />
                    </term>
                    <description>"Tunnels"</description>
                </item>
                <item>
                    <term><see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> where T is bool</term>
                    <description>"WallFloor"</description>
                </item>
            </list>
            In the case of both components, existing components are used if they are present; new ones are added if not.
            </summary>
            <remarks>
            This generation steps generates mazes, and adds the tunnels made to the <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />
            context component with
            the proper tag (if one is specified) on the <see cref="T:GoRogue.MapGeneration.GenerationContext" />.  If no such component exists,
            one is created.  It also sets the all locations inside the tunnels to true in the map's "WallFloor" map view context
            component.  If the
            GenerationContext has an existing "WallFloor" context component, that component is used.  If not, an
            <see cref="T:SadRogue.Primitives.GridViews.ArrayView`1" /> where T is bool is
            created and added to the map context, whose width/height match <see cref="F:GoRogue.MapGeneration.GenerationContext.Width" />/
            <see cref="F:GoRogue.MapGeneration.GenerationContext.Height" />.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.MazeGeneration.TunnelsComponentTag">
            <summary>
            Optional tag that must be associated with the component used to store tunnels generated by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.MazeGeneration.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.MazeGeneration.CrawlerChangeDirectionImprovement">
            <summary>
            Out of 100, how much to increase the chance of a crawler changing direction each step.  Once it changes direction, it
            resets to 0 and increases
            by this amount.  Defaults to 10.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.MazeGeneration.RNG">
            <summary>
            RNG to use for maze generation.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.MazeGeneration.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new maze generation step.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.MazeGeneration" />.</param>
            ///
            <param name="tunnelsComponentTag">
            Optional tag that must be associated with the component used to store tunnels/mazes
            created by the algorithm.  Defaults to "Tunnels".
            </param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the map view component used to store/set
            floor/wall status.  Defaults to "WallFloor".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.MazeGeneration.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection">
            <summary>
            Connects areas of the map by connecting each area specified to a random other area, or connecting the areas
            in a specific order specified.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.AreasComponentTag">
            <summary>
            Optional tag that must be associated with the component used to store map areas connected by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.TunnelsComponentTag">
            <summary>
            Optional tag that must be associated with the component created/used to store the tunnels created by this connection
            method.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.ConnectionPointSelector">
            <summary>
            The area connection strategy to use. Not all methods function on maps with concave areas
            -- see respective class documentation for details.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.RandomizeOrder">
            <summary>
            Whether or not to randomize the order of the areas before connecting them.  If false, the areas will
            be connected to the next area in the list specified by <see cref="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.AreasComponentTag"/>.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.TunnelCreator">
            <summary>
            The tunnel creation strategy to use. Defaults to <see cref="T:GoRogue.MapGeneration.TunnelCreators.HorizontalVerticalTunnelCreator" /> using
            <see cref="F:GoRogue.Random.GlobalRandom.DefaultRNG"/>.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.RNG">
            <summary>
            RNG to use for randomization or room order (if randomization is enabled).
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new ordered area connection step.
            </summary>
            <param name="name">>The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection" />.</param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the map view component used to store/set
            floor/wall status.  Defaults to "WallFloor".
            </param>
            <param name="areasComponentTag">
            Optional tag that must be associated with the component used to store map areas
            connected by this algorithm.  Defaults to "Areas".
            </param>
            <param name="tunnelsComponentTag">
            Optional tag that must be associated with the component created/used to store the
            tunnels created by this connection method.  Defaults to "Tunnels".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.OrderedMapAreaConnection.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.RandomViewFill">
            <summary>
            Randomly fills a boolean <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> with true/false values.  Creates a grid view
            with the given tag if none is present.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RandomViewFill.GridViewComponentTag">
            <summary>
            Optional tag that must be associated with the grid view that random values are set to.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RandomViewFill.RNG">
            <summary>
            The RNG to use for filling the view.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RandomViewFill.FillProbability">
            <summary>
            Represents the percent chance that a given cell will be a floor cell when the map is
            initially randomly filled.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RandomViewFill.ExcludePerimeterPoints">
            <summary>
            Whether or not to exclude the perimeter points from the random fill.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RandomViewFill.FillsBetweenPauses">
            <summary>
            How many squares to fill before yield returning for a pause.  Defaults to no pauses (0).
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RandomViewFill.#ctor(System.String,System.String)">
            <summary>
            Creates a new step for applying random values to a map view.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.RandomViewFill" />.</param>
            <param name="gridViewComponentTag">
            Optional tag that must be associated with the grid view that random values are set to.  Defaults to
            "WallFloor".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RandomViewFill.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.RectangleGenerator">
             <summary>
             Produces a very simple map that is entirely floor, with a single-thick outline of walls around the outside.
            
             Context Components Required:
             - None
             Context Components Added/Used:
             <list type="table">
                 <listheader>
                     <term>Component</term>
                     <description>Default Tag</description>
                 </listheader>
                 <item>
                     <term><see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> where T is bool</term>
                     <description>"WallFloor"</description>
                 </item>
             </list>
            
             An existing wall-floor component used if one is present; if not, a new one is added.
             </summary>
             <remarks>
             This generation step simply turns the map into a giant rectangular room.  It sets the interior positions to
             true, and outer-edge points to false, in the map context's map view with the given tag.  If the
             GenerationContext has an existing map view context component, that component is used.  If not, an
             <see cref="T:SadRogue.Primitives.GridViews.ArrayView`1" /> where T is bool is created and added to the map context, whose width/height
             match <see cref="F:GoRogue.MapGeneration.GenerationContext.Width" />/<see cref="F:GoRogue.MapGeneration.GenerationContext.Height" />.
             </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RectangleGenerator.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RectangleGenerator.#ctor(System.String)">
            <summary>
            Creates a new rectangle map generation step.
            </summary>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the map view component used to store/set
            floor/wall status.  Defaults to "WallFloor".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RectangleGenerator.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.RoomDoorConnection">
            <summary>
            Selects and opens walls of rectangular rooms to connect them to adjacent open spaces (typically mazes/tunnels).
            Components Required:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <description>Default Tag</description>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />
                    </term>
                    <description>"Rooms"</description>
                </item>
                <item>
                    <term><see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> where T is bool</term>
                    <description>"WallFloor"</description>
                </item>
            </list>
            Components Added/Used:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <description>Default Tag</description>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList" />
                    </term>
                    <description>"Doors"</description>
                </item>
            </list>
            In the case of the DoorsList component, an existing component is used if an appropriate one is present; a new one is
            added if not.
            </summary>
            <remarks>
            This algorithm goes through each room specified in the <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> context component, and
            selects a random number of sides
            to place connections on (within the parameters specified).  For each side, it then selects randomly from the valid
            connection points on that side, and
            carves out the selected location by setting its value to true in the "WallFloor" map view, and adding it to the list of
            doors associated with the
            appropriate room in the <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList" /> context component.  It continues to select connection points on a side
            until the <see cref="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelConnectionPlacementChance" />
            succeeds.  <see cref="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelConnectionPlacementChance" /> is increased by
            <see cref="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelConnectionPlacementChanceIncrease" /> each time a point is selected.
            The algorithm will never select two adjacent points on a side as connection points.  Similarly, it will never break
            through the edges of the map. If an existing
            <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList" /> component exists on the map context with the proper tag, that component is used to record the
            doors generated; if not, a new one is created.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.DoorsListComponentTag">
            <summary>
            Optional tag that must be associated with the component created/used to record the locations of doors created by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.RoomsComponentTag">
            <summary>
            Optional tag that must be associated with the component that contains the rooms being connected by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelConnectionPlacementChance">
            <summary>
            A chance out of 100 to cancel placing a door on a side after one has been placed (per side). Defaults to 70.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelConnectionPlacementChanceIncrease">
            <summary>
            Increase the <see cref="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelConnectionPlacementChance" /> value by this amount each time a door is placed (per side).
            Defaults to 10.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.CancelSideConnectionSelectChance">
            <summary>
            A chance out of 100 to cancel selecting sides to process (per room). Defaults to 50.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.MaxSidesToConnect">
            <summary>
            Maximum sides of each room to process. Defaults to 4.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.MinSidesToConnect">
            <summary>
            Minimum sides of each room to process.  Defaults to 1.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomDoorConnection.RNG">
            <summary>
            The RNG to use for connections.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RoomDoorConnection.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new maze generation step.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.RoomDoorConnection" />.</param>
            <param name="roomsComponentTag">
            Optional tag that must be associated with the component that contains the rooms being
            connected by this algorithm.  Defaults to "Rooms".
            </param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the component used to set wall/floor
            status of tiles changed by this algorithm.  Defaults to "WallFloor".
            </param>
            <param name="doorsListComponentTag">
            Optional tag that must be associated with the component created/used to record the
            locations of doors created by this algorithm.  Defaults to "Doors".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RoomDoorConnection.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.RoomsGeneration">
            <summary>
            Carves out non-overlapping rooms in a map.  Rooms generated will not overlap with themselves, or any existing open
            areas in the map.
            
            <b>Context Components Required:</b> None
            
            <b>Context Components Added/Used:</b>
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <term>Default Tag</term>
                    <term>Description</term>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1">ItemList&lt;Rectangle&gt;</see>
                    </term>
                    <term>"Rooms"</term>
                    <term>A list of <see cref="T:SadRogue.Primitives.Rectangle"/> instances which denote the rooms that were created.</term>
                </item>
                <item>
                    <term><see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1">ISettableGridView&lt;bool&gt;</see></term>
                    <term>"WallFloor"</term>
                    <term>A grid view of boolean values the size of the map where "true" indicates a tile is passable, and "false" indicates it is not.</term>
                </item>
            </list>
            
            In the case of both components, existing components are used if they are present; new ones are added if not.
            </summary>
            <remarks>
            This generation step generates rooms, and adds the rooms generated to the
            <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1">ItemList&lt;Rectangle&gt;</see> context component with the given tag
            in the <see cref="T:GoRogue.MapGeneration.GenerationContext" />.  If such a component does not exist, a new one is created.  It also sets the
            interior positions to true in the map context's grid view with the given tag.  If the GenerationContext has an existing grid
            view context component, with the appropriate tag, that component is used.  If not, an
            <see cref="T:SadRogue.Primitives.GridViews.ArrayView`1">ArrayView&lt;bool&gt;</see> is created and added to the map context, whose
            width/height match <see cref="F:GoRogue.MapGeneration.GenerationContext.Width" />/<see cref="F:GoRogue.MapGeneration.GenerationContext.Height" />.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.RoomsComponentTag">
            <summary>
            Optional tag that must be associated with the component used to store rooms generated by this algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.MaxCreationAttempts">
            <summary>
            The maximum times to re-generate a room that fails to place in a valid location before giving up on generating that
            room entirely.  Defaults to 10.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.MaxPlacementAttempts">
            <summary>
            The maximum times to attempt to place a room in a map without intersection, before giving up
            and re-generating that room. Defaults to 10.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.MaxRooms">
            <summary>
            Maximum amount of rooms to generate.  Defaults to 10.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.MinRooms">
            <summary>
            Minimum amount of rooms to generate.  Defaults to 4.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.RNG">
            <summary>
            RNG to use for room creation/placement.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.RoomMaxSize">
            <summary>
            The maximum size allowed for rooms.  Rounded up to an odd number.  Defaults to 7.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.RoomMinSize">
            <summary>
            The minimum size allowed for rooms.  Rounded up to an odd number.  Defaults to 3.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.RoomSizeRatioX">
            <summary>
            The ratio of the room width compared to a base generated size. Defaults to 1.0.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.RoomsGeneration.RoomSizeRatioY">
            <summary>
            The ratio of the room height to a base generated size. Defaults to 1.0.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RoomsGeneration.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new rooms generation step.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.RoomsGeneration" />.</param>
            <param name="roomsComponentTag">
            Optional tag that must be associated with the component used to store rooms.  Defaults
            to "Rooms".
            </param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the map view component used to store/set
            floor/wall status.  Defaults to "WallFloor".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.RoomsGeneration.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1">
            <summary>
            Appends an item list onto another one, optionally removing the one that was appended from the context.
            Context Components Required:
            - <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> (tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.BaseListTag" />): The base list onto which the other list is appended
            - <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> (tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.ListToAppendTag" />: The list whose items are appended onto the base
            list.  This component will be removed from the context if <see cref="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.RemoveAppendedComponent" /> is true.
            </summary>
            <typeparam name="TItem">Type of item in the lists being appended.</typeparam>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.BaseListTag">
            <summary>
            A tag that must be attached to the component that will have items from the other list appended onto it.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.ListToAppendTag">
            <summary>
            A tag that must be attached to the component that will have its items appended onto the base list.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.RemoveAppendedComponent">
            <summary>
            Whether or not to remove the component with the tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.ListToAppendTag" /> after its items have been added to
            the base list.  Defaults to false.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new generation component that appends lists.
            </summary>
            <param name="name">Name of this component.</param>
            <param name="baseListTag">
            A tag that must be attached to the component that will have items from the other list
            appended onto it.
            </param>
            <param name="listToAppendTag">
            A tag that must be attached to the component that will have its items appended onto the
            base list.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.#ctor(System.String,System.String)">
            <summary>
            Creates a new generation component that appends lists.
            </summary>
            <param name="baseListTag">
            A tag that must be attached to the component that will have items from the other list
            appended onto it.
            </param>
            <param name="listToAppendTag">
            A tag that must be attached to the component that will have its items appended onto the
            base list.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas">
            <summary>
            "Translation" step that takes as input an <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />, and transforms it into an
            <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />.
            Can optionally remove the <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> from the context.
            Context Components Required:
            - <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> (tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.RectanglesComponentTag" />): The list of rectangles to translate
            to areas
            Context Components Added/Used
            - <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> (tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.AreasComponentTag" />): The list of areas to add the areas representing
            the rectangles to.  If it does not exist, it will be created.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.AreasComponentTag">
            <summary>
            Tag that must be associated with the component used to store the resulting areas.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.RectanglesComponentTag">
            <summary>
            Tag that must be associated with the component used as input rectangles.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.RemoveSourceComponent">
            <summary>
            Whether or not to remove the input list of rectangles from the context.  Defaults to false.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new step for translation of <see cref="T:SadRogue.Primitives.Rectangle" /> lists to <see cref="T:SadRogue.Primitives.Area" /> lists.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas" />.</param>
            <param name="rectanglesComponentTag">Tag that must be associated with the component used as input rectangles.</param>
            <param name="areasComponentTag">Tag that must be associated with the component used to store the resulting areas.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.#ctor(System.String,System.String)">
            <summary>
            Creates a new step for translation of <see cref="T:SadRogue.Primitives.Rectangle" /> lists to <see cref="T:SadRogue.Primitives.Area" /> lists, with the name
            <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas" />.
            </summary>
            <param name="rectanglesComponentTag">Tag that must be associated with the component used as input rectangles.</param>
            <param name="areasComponentTag">Tag that must be associated with the component used to store the resulting areas.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints">
            <summary>
            Removes all points from an area list that are in any of the areas present in another list.
            Context Components Required:
            - <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> (tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.UnmodifiedAreaListTag" />: The list of areas that will not be
            modified, but will serve as a basis for points to remove from areas in
            the other list.
            - <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> (tag <see cref="F:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.ModifiedAreaListTag" />: The list of areas that will be modified; all
            areas in this list will have any points that also appear in
            areas in the other list removed.  If an area ends up with no remaining points, it is removed from the list.
            </summary>
            <remarks>
            This component will removes all positions from any areas in the the modified area list, that are also present in one or
            more areas in
            the unmodified area list.  If an area is modified such that it has no remaining points, it is removed from the list
            entirely.
            This ensures that the two lists do not contain any positions that overlap with each other.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.ModifiedAreaListTag">
            <summary>
            Tag that must be associated with the component used as the area list from which duplicates are removed.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.UnmodifiedAreaListTag">
            <summary>
            Tag that must be associated with the component used as the unmodified area list.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new area duplicate point remover step.
            </summary>
            <param name="name">The name of the generation step.</param>
            <param name="unmodifiedAreaListTag">Tag that must be associated with the component used as the unmodified area list.</param>
            <param name="modifiedAreaListTag">
            Tag that must be associated with the component used as the area list from which
            duplicates are removed.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.#ctor(System.String,System.String)">
            <summary>
            Creates a new area duplicate point remover step, with the name <see cref="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints" />.
            </summary>
            <param name="unmodifiedAreaListTag">Tag that must be associated with the component used as the unmodified area list.</param>
            <param name="modifiedAreaListTag">
            Tag that must be associated with the component used as the area list from which
            duplicates are removed.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming">
            <summary>
            Searches for tunnels that don't lead anywhere (eg. are surrounded by 3 walls), and removes them from the map.
            Context Components Required:
            <list type="table">
                <listheader>
                    <term>Component</term>
                    <description>Default Tag</description>
                </listheader>
                <item>
                    <term>
                        <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" />
                    </term>
                    <description>"Tunnels"</description>
                </item>
                <item>
                    <term><see cref="T:SadRogue.Primitives.GridViews.ISettableGridView`1" /> where T is bool</term>
                    <description>"WallFloor"</description>
                </item>
            </list>
            Context Components Added:
            - None
            </summary>
            <remarks>
            This algorithm iterates over all map areas in the <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1" /> context component with the given tag.
            For each area, it scans for dead ends
            (locations that, according to the "WallFloor" component given, are surrounded by 3 walls).  For each dead end, if that
            dead end is not currently
            and hasn't previously been selected as "saved", based on percentage checks, it proceeds to fill it in.  It will remove
            the dead end location, from the appropriate
            area, and set the location in the "WallFloor" map to true.
            It proceeds in this manner until either no more (non-saved) dead ends are found, or the given maximum iterations is
            reached, then proceeds to the next area in the ItemList
            until it has processed all of the areas.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.TunnelsComponentTag">
            <summary>
            Optional tag that must be associated with the component used to record areas representing tunnels that this algorithm
            will trim dead ends from.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.WallFloorComponentTag">
            <summary>
            Optional tag that must be associated with the component used to set wall/floor status of tiles changed by this
            algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.MaxTrimIterations">
            <summary>
            Maximum number of passes to make looking for dead ends per area.  Defaults to infinity.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.RNG">
            <summary>
            RNG to use for percentage checks.  Defaults to <see cref="F:GoRogue.Random.GlobalRandom.DefaultRNG" />.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.SaveDeadEndChance">
            <summary>
            The chance out of 100 that a dead end is left alone.  Defaults to 40.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new dead end trimming generation step.
            </summary>
            <param name="name">The name of the generation step.  Defaults to <see cref="T:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming" />.</param>
            <param name="wallFloorComponentTag">
            Optional tag that must be associated with the component used to set wall/floor
            status of tiles changed by this algorithm.  Defaults to "WallFloor".
            </param>
            <param name="tunnelsComponentTag">
            Optional tag that must be associated with the component used to record areas
            representing tunnels that this algorithm will trim dead ends from.  Defaults to "Tunnels".
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Steps.TunnelDeadEndTrimming.OnPerform(GoRogue.MapGeneration.GenerationContext)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.TunnelCreators.DirectLineTunnelCreator">
            <summary>
            Implements a tunnel creation algorithm that sets as walkable a direct line between the two
            points. In the case that <see cref="F:SadRogue.Primitives.Distance.Manhattan" /> is being used, the line is calculated via the
            <see cref="F:SadRogue.Primitives.Lines.Algorithm.Orthogonal" /> algorithm.  Otherwise, the line is calculated using
            <see cref="F:SadRogue.Primitives.Lines.Algorithm.Bresenham" />.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.DirectLineTunnelCreator.#ctor(SadRogue.Primitives.AdjacencyRule,System.Boolean)">
            <summary>
            Constructor. Takes the distance calculation to use, which determines whether <see cref="F:SadRogue.Primitives.Lines.Algorithm.Orthogonal" />
            or <see cref="F:SadRogue.Primitives.Lines.Algorithm.Bresenham" /> is used to create the tunnel.
            </summary>
            <param name="adjacencyRule">
            Method of adjacency to respect when creating tunnels. Cannot be diagonal.
            </param>
            <param name="doubleWideVertical">Whether or not to create vertical tunnels as 2-wide.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.DirectLineTunnelCreator.CreateTunnel(SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean},SadRogue.Primitives.Point,SadRogue.Primitives.Point)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.DirectLineTunnelCreator.CreateTunnel(SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.TunnelCreators.HorizontalVerticalTunnelCreator">
            <summary>
            Implements a tunnel creation algorithm that creates a tunnel that performs all needed
            vertical movement before horizontal movement, or vice versa (depending on rng).
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.HorizontalVerticalTunnelCreator.#ctor(ShaiRandom.Generators.IEnhancedRandom)">
            <summary>
            Creates a new tunnel creator.
            </summary>
            <param name="rng">RNG to use for movement selection.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.HorizontalVerticalTunnelCreator.CreateTunnel(SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean},SadRogue.Primitives.Point,SadRogue.Primitives.Point)">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.HorizontalVerticalTunnelCreator.CreateTunnel(SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:GoRogue.MapGeneration.TunnelCreators.ITunnelCreator">
            <summary>
            Interface for implementing an algorithm for creating a tunnel between two positions on a
            walkability map.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.ITunnelCreator.CreateTunnel(SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean},SadRogue.Primitives.Point,SadRogue.Primitives.Point)">
            <summary>
            Implements the algorithm, creating the tunnel between the two points (ensuring there is a
            path of positions set to true between those two points).
            </summary>
            <param name="map">_grid to create the tunnel on.</param>
            <param name="tunnelStart">Start position to connect.</param>
            <param name="tunnelEnd">End position to connect.</param>
            <returns>An area containing all points that are part of the tunnel.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.TunnelCreators.ITunnelCreator.CreateTunnel(SadRogue.Primitives.GridViews.ISettableGridView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel between the two points (ensuring there is a
            path of positions set to true between those two points).
            </summary>
            <param name="map">_grid to create the tunnel on.</param>
            <param name="startX">X-value of the start position to connect.</param>
            <param name="startY">Y-value of the start position to connect.</param>
            <param name="endX">X-value of the end position to connect.</param>
            <param name="endY">Y-value of the end position to connect.</param>
            <returns>An area containing all points that are part of the tunnel.</returns>
        </member>
        <member name="T:GoRogue.MathHelpers">
            <summary>
            Static class consisting of mathematical "helper" functions and constants -- things like angle
            unit conversions, and other helpful functions.
            </summary>
        </member>
        <member name="M:GoRogue.MathHelpers.RoundToMultiple(System.Int32,System.Int32)">
            <summary>
            Rounds the given number up (toward highest number), to the nearest multiple of the
            specified value.
            </summary>
            <param name="number">Number to round.</param>
            <param name="toMultipleOf">Number given is rounded up to nearest multiple of this number.</param>
            <returns>The number parameter, rounded up to the nearest multiple of <paramref name="toMultipleOf" />.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.WrapAround(System.Int32,System.Int32)">
            <summary>
            A modified modulo operator, which practically differs from <paramref name="num" /> % <paramref name="wrapTo" />
            in that it wraps from 0 to <paramref name="wrapTo" /> - 1, as well as from <paramref name="wrapTo" /> - 1 to 0.
            </summary>
            <remarks>
            A modified modulo operator. Returns the result of  the formula
            (<paramref name="num" /> % <paramref name="wrapTo" /> + <paramref name="wrapTo" />) % <paramref name="wrapTo" />.
            Practically it differs from regular modulo in that the values it returns when negative values for
            <paramref name="num" />
            are wrapped around like one would want an array index to (if wrapTo is list.length, -1 wraps to list.length - 1). For
            example,
            0 % 3 = 0, -1 % 3 = -1, -2 % 3 = -2, -3 % 3 = 0, and so forth, but WrapTo(0, 3) = 0,
            WrapTo(-1, 3) = 2, WrapTo(-2, 3) = 1, WrapTo(-3, 3) = 0, and so forth. This can be useful if you're
            trying to "wrap" a number around at both ends, for example wrap to 3, such that 3 wraps
            to 0, and -1 wraps to 2. This is common if you are wrapping around an array index to the
            length of the array and need to ensure that positive numbers greater than or equal to the
            length of the array wrap to the beginning of the array (index 0), AND that negative
            numbers (under 0) wrap around to the end of the array (Length - 1).
            </remarks>
            <param name="num">The number to wrap.</param>
            <param name="wrapTo">
            The number to wrap to -- the result of the function is as outlined in function
            description, and guaranteed to be between [0, wrapTo - 1], inclusive.
            </param>
            <returns>
            The wrapped result, as outlined in function description. Guaranteed to lie in range [0,
            wrapTo - 1], inclusive.
            </returns>
        </member>
        <member name="M:GoRogue.MathHelpers.WrapAround(System.Double,System.Double)">
            <summary>
            Same effect as <see cref="M:GoRogue.MathHelpers.WrapAround(System.Int32,System.Int32)"/>, but for doubles.
            </summary>
            <param name="num">The number to wrap.</param>
            <param name="wrapTo">The number to wrap to.</param>
            <returns>The wrapped result.  Guaranteed to lie in range [0,
            wrapTo).</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.ScaledAtan2Approx(System.Double,System.Double)">
            <summary>
            Approximation of the Atan2 function that scales the returned value to the range [0.0, 1.0], in order to remain
            agnostic of units (radius vs degrees).  It will never return a negative number, so is also useful to avoid
            floating-point
            modulus.  Credit to the SquidLib java RL library and
            <a href="https://math.stackexchange.com/a/1105038">
            this suggestion
            from user njuffa
            </a>
            for this math.
            </summary>
            <param name="y">Y-component of point to find angle towards.</param>
            <param name="x">X-component of point to find angle towards.</param>
            <returns>A value representing the angle to the given point, scaled to range [0.0, 1.0].</returns>
        </member>
        <member name="T:GoRogue.Messaging.ISubscriber`1">
             <summary>
             Interface representing subscribers to messages sent over a <see cref="T:GoRogue.Messaging.MessageBus" />.  Classes wishing to respond to
             one or more message types as they are sent across the bus should implement this interface.
             </summary>
             <remarks>
             It is possible to have one class handle two different event types, by having it implement multiple ISubscriber types;
             however in this situation, you must either use the <see cref="M:GoRogue.Messaging.MessageBus.RegisterAllSubscribers``1(``0)"/> method (or its "Try" variant)
             to register the subscriber, or call the <see cref="M:GoRogue.Messaging.MessageBus.RegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})"/> method once for each type of message the subscriber
             subscribes to (specifying the TMessage type manually each time).  Although RegisterAllSubscribers will work for most use cases, when you want the fastest
             performance, you will want to prefer the RegisterSubscriber method, since RegisterAllSubscribers uses reflection.
            
             <example>
             In this example, MultipleSubscriber wants to respond to messages of both type string and string[], without using any
             component classes or any such method of splitting up the implementations.  Thus, we implement the appropriate ISubscriber interfaces,
             and call the message bus's <see cref="M:GoRogue.Messaging.MessageBus.RegisterAllSubscribers``1(``0)" /> function to register the subscriber.
            
             <code>
              class MultipleSubscriber : ISubscriber&lt;string&gt;, ISubscriber&lt;string[]&gt;
              {
             		/* Explicit interface definitions are not required but are recommend for code clarity
             		void ISubscriber&lt;string&gt;.Handle(string message) => Console.WriteLine(message);
             		void ISubscriber&lt;string[]&gt;.Handle(string[] message) => Console.WriteLine(message.ExtendToString());
              }
              
              /* Later, when we add the subscriber to our message bus, we simply use the RegisterAllSubscribers method to ensure the subscriber is registered to both types. */
              var messageBus = new MessageBus();
              
              var multiSubber = new MultipleSubscriber();
              messageBus.RegisterAllSubscribers(multiSubber);
              </code>
            
             Alternatively, we can use the RegisterSubscriber method to register the subscriber to each type individually.
             
             <code>
              /* Here, when we add the subscriber to our message bus, we add each subscriber interface separately */
              var messageBus = new MessageBus();
              
              var multiSubber = new MultipleSubscriber();
              messageBus.RegisterSubscriber&lt;string&gt;(multiSubber);
              messageBus.RegisterSubscriber&lt;string[]&gt;(multiSubber);
              </code>
             </example>
             </remarks>
             <typeparam name="TMessage">
             The type of message that the subscriber wants to handle.  Any and all messages sent over the event bus you subscribe to
             that can cast to this type will be passed the <see cref="M:GoRogue.Messaging.ISubscriber`1.Handle(`0)" /> function when they are sent.
             </typeparam>
        </member>
        <member name="M:GoRogue.Messaging.ISubscriber`1.Handle(`0)">
            <summary>
            Function that should handle the specified type of message in whatever manner it needs to.  Called automatically any
            time a message of the appropriate type is sent over an event bus this subscriber has been registered on.
            </summary>
            <param name="message">Message that was sent.</param>
        </member>
        <member name="T:GoRogue.Messaging.MessageBus">
            <summary>
            A messaging system that can have subscribers added to it, and send messages.  When messages are sent, it will call any
            handlers that requested to handle messages of the proper types, based on the type-tree/interface-tree of the messages.
            </summary>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:GoRogue.Messaging.MessageBus.SubscriberCount">
            <summary>
            Number of subscribers currently listening on this message bus.
            </summary>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.RegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})">
            <summary>
            Adds the given subscriber to the message bus's handlers list, so its Handle function will be called when any messages
            that can cast to <typeparamref name="TMessage" /> are sent via the <see cref="M:GoRogue.Messaging.MessageBus.Send``1(``0)" /> function.
            Particularly when a handler is intended to have a shorter lifespan than the message bus, they MUST be unregistered via
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" /> or another Unregister function when they are disposed
            of, to avoid the bus preventing the handler from being garbage collected.
            </summary>
            <remarks>
            Particularly if your handling class subscribes to multiple message types, you may want to consider using <see cref="M:GoRogue.Messaging.MessageBus.RegisterAllSubscribers``1(``0)"/>
            instead; however that function uses reflection so will be slower than just calling this function once per implementation of ISubscriber.
            </remarks>
            <typeparam name="TMessage">
            Type of message the subscriber is handling.  This can typically be inferred by the compiler,
            barring the case detailed in the <see cref="T:GoRogue.Messaging.ISubscriber`1" /> remarks where one class subscribes to multiple
            message types.
            </typeparam>
            <param name="subscriber">Subscriber to add.</param>
            <returns>
            The subscriber that was added, in case a reference is needed to later call
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" />.
            </returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.RegisterAllSubscribers``1(``0)">
            <summary>
            Adds the given subscriber to the message bus's handlers list, so its Handle function will be called when any messages of a type that
            the subscriber is subscribed to are sent via the <see cref="M:GoRogue.Messaging.MessageBus.Send``1(``0)" /> function.
            Particularly when a handler is intended to have a shorter lifespan than the message bus, they MUST be unregistered via
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterAllSubscribers``1(``0)" /> or another Unregister function when they are disposed
            of, to avoid the bus preventing the handler from being garbage collected.
            </summary>
            <remarks>
            This is typically a good (safe) registration method to use by default.  However, if you know that your subscriber types will only implement one
            variation of ISubscriber, or you need registration to happen as quickly as possible, then you should instead consider calling
            <see cref="M:GoRogue.Messaging.MessageBus.RegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" /> once for each variation of ISubscriber your subscriber implements.  This function
            uses reflection to figure out what versions of ISubscriber the parameter implements, so can be somewhat slow compared to RegisterSubscriber.
            </remarks>
            <typeparam name="T">
            Type of the subscriber.  This is typically inferred by the compiler, and really only affects the returned type (for chaining).
            </typeparam>
            <param name="subscriber">Subscriber to add.</param>
            <returns>
            The subscriber that was added, in case a reference is needed to later call
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterAllSubscribers``1(``0)" />.
            </returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.TryRegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})">
            <summary>
            Tries to add the given subscriber to the message bus's handlers list, so its Handle function will be called when any messages
            that can cast to <typeparamref name="TMessage" /> are sent via the <see cref="M:GoRogue.Messaging.MessageBus.Send``1(``0)" /> function.
            Particularly when a handler is intended to have a shorter lifespan than the message bus, they MUST be unregistered via
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" /> or another Unregister function when they are disposed of,
            to avoid the bus preventing the handler from being garbage collected.
            </summary>
            <remarks>
            Particularly if your handling class subscribes to multiple message types, you may want to consider using <see cref="M:GoRogue.Messaging.MessageBus.TryRegisterAllSubscribers``1(``0)"/>
            instead; however that function uses reflection so will be slower than just calling this function once per implementation of ISubscriber.
            </remarks>
            <typeparam name="TMessage">
            Type of message the subscriber is handling.  This can typically be inferred by the compiler,
            barring the case detailed in the <see cref="T:GoRogue.Messaging.ISubscriber`1" /> remarks where one class subscribes to multiple
            message types.
            </typeparam>
            <param name="subscriber">Subscriber to add.</param>
            <returns>
            True if the subscriber was added; false if it was already identically registered.
            </returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.TryRegisterAllSubscribers``1(``0)">
            <summary>
            Tries to add the given subscriber to the message bus's handlers list, so its Handle function will be called when any messages of a type that
            the subscriber is subscribed to are sent via the <see cref="M:GoRogue.Messaging.MessageBus.Send``1(``0)" /> function.
            Particularly when a handler is intended to have a shorter lifespan than the message bus, they MUST be unregistered via
            <see cref="M:GoRogue.Messaging.MessageBus.UnregisterAllSubscribers``1(``0)" /> or another Unregister function when they are disposed
            of, to avoid the bus preventing the handler from being garbage collected.
            </summary>
            <remarks>
            This is typically a good (safe) registration method to use by default.  However, if you know that your subscriber types will only implement one
            variation of ISubscriber, or you need registration to happen as quickly as possible, then you should instead consider calling
            <see cref="M:GoRogue.Messaging.MessageBus.TryRegisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" /> once for each variation of ISubscriber your subscriber implements.  This function
            uses reflection to figure out what versions of ISubscriber the parameter implements, so can be somewhat slow compared to TryRegisterSubscriber.
            </remarks>
            <typeparam name="T">
            Type of the subscriber.  This is typically inferred by the compiler, and really only affects the returned type (for chaining).
            </typeparam>
            <param name="subscriber">Subscriber to add.</param>
            <returns>
            True if the subscriber was added; false if it was already identically registered.
            </returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})">
            <summary>
            Removes the given subscriber from the message bus's handlers list.  Particularly when a subscriber is intended to have
            a shorter lifetime than the
            MessageBus object it subscribed with, handlers MUST be removed when disposed of so they can be garbage collected -- an
            object cannot be garbage-collected
            so long as it is registered as a subscriber to a message bus (unless the bus is also being garbage-collected).
            </summary>
            <typeparam name="TMessage">
            Type of message the subscriber is handling.  This can typically be inferred by the compiler,
            barring the case detailed in the <see cref="T:GoRogue.Messaging.ISubscriber`1" /> remarks where one class subscribes to multiple
            message types.
            </typeparam>
            <param name="subscriber">Subscriber to remove.</param>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.UnregisterAllSubscribers``1(``0)">
             <summary>
             Removes the given subscriber from the message bus's handlers list.  Particularly when a subscriber is intended to have
             a shorter lifetime than the
             MessageBus object it subscribed with, handlers MUST be removed when disposed of so they can be garbage collected -- an
             object cannot be garbage-collected so long as it is registered as a subscriber to a message bus (unless the bus is also being
             garbage-collected).
             </summary>
             <remarks>
             This is typically a good (safe) registration method to use by default.  However, if you know that your subscriber types will only implement one
             variation of ISubscriber, or you need unregistration to happen as quickly as possible, then you should instead consider calling
             <see cref="M:GoRogue.Messaging.MessageBus.UnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" /> once for each variation of ISubscriber your subscriber implements.  This
             function uses reflection to figure out what versions of ISubscriber the parameter implements, so can be somewhat slow compared to UnregisterSubscriber.
            
             You may call this function even if some of the subscriber's implementations of ISubscriber are not registered with the bus; it will simply
             unregister the ones that _have_ been registered.  An exception will be thrown if no implementations of ISubscriber were registered, however.
             </remarks>
            <typeparam name="T">
             Type of the subscriber.  This is typically inferred by the compiler, and really only affects the returned type (for chaining).
             </typeparam>
             <param name="subscriber">Subscriber to remove.</param>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.TryUnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})">
            <summary>
            Tries to remove the given subscriber from the message bus's handlers list.  Particularly when a subscriber is intended to have
            a shorter lifetime than the
            MessageBus object it subscribed with, handlers MUST be removed when disposed of so they can be garbage collected -- an
            object cannot be garbage-collected
            so long as it is registered as a subscriber to a message bus (unless the bus is also being garbage-collected).
            </summary>
            <typeparam name="TMessage">
            Type of message the subscriber is handling.  This can typically be inferred by the compiler,
            barring the case detailed in the <see cref="T:GoRogue.Messaging.ISubscriber`1" /> remarks where one class subscribes to multiple
            message types.
            </typeparam>
            <param name="subscriber">Subscriber to remove.</param>
            <returns>True if the subscriber was successfully removed; false if it was never registered.</returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.TryUnregisterAllSubscribers``1(``0)">
             <summary>
             Removes the given subscriber from the message bus's handlers list.  Particularly when a subscriber is intended to have
             a shorter lifetime than the
             MessageBus object it subscribed with, handlers MUST be removed when disposed of so they can be garbage collected -- an
             object cannot be garbage-collected so long as it is registered as a subscriber to a message bus (unless the bus is also being
             garbage-collected).
             </summary>
             <remarks>
             This is typically a good (safe) registration method to use by default.  However, if you know that your subscriber types will only implement one
             variation of ISubscriber, or you need unregistration to happen as quickly as possible, then you should instead consider calling
             <see cref="M:GoRogue.Messaging.MessageBus.TryUnregisterSubscriber``1(GoRogue.Messaging.ISubscriber{``0})" /> once for each variation of ISubscriber your subscriber implements.
             This function uses reflection to figure out what versions of ISubscriber the parameter implements, so can be somewhat slow compared to
             TryUnregisterSubscriber.
            
             You may call this function even if some of the subscriber's implementations of ISubscriber are not registered with the bus; it will simply
             unregister the ones that _have_ been registered; and similarly the function will still return true, as long as at least one subscriber was removed.
             False will only be returned if no ISubscriber implementations were unregistered.
             </remarks>
            <typeparam name="T">
             Type of the subscriber.  This is typically inferred by the compiler, and really only affects the returned type (for chaining).
             </typeparam>
             <param name="subscriber">Subscriber to remove.</param>
             <returns>True if at least one ISubscriber variation implemented by the type passed in was unregistered; false if none of its subscriber types were registered.</returns>
        </member>
        <member name="M:GoRogue.Messaging.MessageBus.Send``1(``0)">
            <summary>
            Sends the specified message on the message bus, automatically calling any appropriate registered handlers.
            </summary>
            <typeparam name="TMessage"></typeparam>
            <param name="message"></param>
        </member>
        <member name="T:GoRogue.Pathing.AStar">
            <summary>
            Implements an optimized AStar pathfinding algorithm. Optionally supports custom heuristics, and custom weights for each
            tile.
            </summary>
            <remarks>
            Like most GoRogue algorithms, AStar takes as a construction parameter an IGridView representing the map.
            Specifically, it takes an <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" />, where true indicates that a tile should be
            considered walkable, and false indicates that a tile should be considered impassable.
            For details on the map view system in general, see <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" />.  As well, there is an article
            explaining the map view system at the GoRogue documentation page
            <a href="https://chris3606.github.io/GoRogue/articles">here</a>
            If truly shortest paths are not strictly necessary, you may want to consider <see cref="T:GoRogue.Pathing.FastAStar" /> instead.
            </remarks>
        </member>
        <member name="F:GoRogue.Pathing.AStar.MinimumWeight">
            <summary>
            The minimum value that is allowed to occur in the <see cref="P:GoRogue.Pathing.AStar.Weights" /> map view.  This value is only used with the
            default heuristic
            for AStar and <see cref="T:GoRogue.Pathing.FastAStar" />, so if a custom heuristic is used, the value is also ignored.  Must be greater
            than 0.0 and less
            than or equal to the minimum value in the <see cref="P:GoRogue.Pathing.AStar.Weights" /> map view.  Defaults to 1.0 in cases where the default
            heuristic is used.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.Distance)">
            <summary>
            Constructor.  Uses a default heuristic corresponding to the distance calculation given, along with a safe/efficient
            tie-breaking/smoothing element which will produce guaranteed shortest paths.
            </summary>
            <param name="walkabilityView">
            Map view used to determine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.
            </param>
            <param name="distanceMeasurement">
            Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.
            </param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.Distance,System.Func{SadRogue.Primitives.Point,SadRogue.Primitives.Point,System.Double})">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityView">
            Map view used to determine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.
            </param>
            <param name="distanceMeasurement">
            Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.
            </param>
            <param name="heuristic">Function used to estimate the distance between two given points.</param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.Distance,SadRogue.Primitives.GridViews.IGridView{System.Double},System.Double)">
            <summary>
            Constructor.  Uses a default heuristic corresponding to the distance calculation given, along with a safe/efficient
            tie-breaking/smoothing element which will produce guaranteed shortest paths, provided <paramref name="minimumWeight" />
            is correct.
            </summary>
            <param name="walkabilityView">
            Map view used to determine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.
            </param>
            <param name="distanceMeasurement">
            Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.
            </param>
            <param name="weights">A map view indicating the weights of each location (see <see cref="P:GoRogue.Pathing.AStar.Weights" />.</param>
            <param name="minimumWeight">
            The minimum value that will be present in <paramref name="weights" />.  It must be greater than 0.0 and
            must be less than or equal to the minimum value present in the weights view -- the algorithm may not produce truly
            shortest paths if
            this condition is not met.  If this minimum changes after construction, it may be updated via the
            <see cref="F:GoRogue.Pathing.AStar.MinimumWeight" /> property.
            </param>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.Distance,System.Func{SadRogue.Primitives.Point,SadRogue.Primitives.Point,System.Double},SadRogue.Primitives.GridViews.IGridView{System.Double})">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityView">
            Map view used to determine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.
            </param>
            <param name="distanceMeasurement">
            Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.
            </param>
            <param name="heuristic">Function used to estimate the distance between two given points.</param>
            <param name="weights">A map view indicating the weights of each location (see <see cref="P:GoRogue.Pathing.AStar.Weights" />.</param>
        </member>
        <member name="P:GoRogue.Pathing.AStar.DistanceMeasurement">
            <summary>
            The distance calculation being used to determine distance between points. <see cref="F:SadRogue.Primitives.Distance.Manhattan" />
            implies 4-way connectivity, while <see cref="F:SadRogue.Primitives.Distance.Chebyshev" /> or <see cref="F:SadRogue.Primitives.Distance.Euclidean" /> imply
            8-way connectivity for the purpose of determining adjacent coordinates.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.WalkabilityView">
            <summary>
            The map view being used to determine whether or not each tile is walkable.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.Heuristic">
            <summary>
            The heuristic used to estimate distance from nodes to the end point.  If unspecified or specified as null,
            it defaults to using the distance calculation specified by <see cref="P:GoRogue.Pathing.AStar.DistanceMeasurement" />, with a safe/efficient
            tie-breaking multiplier added on.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.Weights">
            <summary>
            Weights given to each tile.  The weight is multiplied by the cost of a tile, so a tile with weight 2 is twice as hard
            to
            enter as a tile with weight 1.  If unspecified or specified as null, all tiles have weight 1.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.MaxEuclideanMultiplier">
            <summary>
            Multiplier that is used in the tie-breaking/smoothing element of the default heuristic. This value is based on the
            maximum possible <see cref="M:SadRogue.Primitives.Point.EuclideanDistanceMagnitude(SadRogue.Primitives.Point,SadRogue.Primitives.Point)" /> between two points on the map.
            Typically you don't need this value unless you're creating a custom heuristic an introducing the same
            tie-breaking/smoothing element as the default heuristic.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.AStar.ShortestPath(SadRogue.Primitives.Point,SadRogue.Primitives.Point,System.Boolean)">
            <summary>
            Finds the shortest path between the two specified points.
            </summary>
            <remarks>
            Returns <see langword="null" /> if there is no path between the specified points. Will still return an
            appropriate path object if the start point is equal to the end point.
            </remarks>
            <param name="start">The starting point of the path.</param>
            <param name="end">The ending point of the path.</param>
            <param name="assumeEndpointsWalkable">
            Whether or not to assume the start and end points are walkable, regardless of what the
            <see cref="P:GoRogue.Pathing.AStar.WalkabilityView" /> reports. Defaults to <see langword="true" />.
            </param>
            <returns>The shortest path between the two points, or <see langword="null" /> if no valid path exists.</returns>
        </member>
        <member name="M:GoRogue.Pathing.AStar.ShortestPath(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Finds the shortest path between the two specified points.
            </summary>
            <remarks>
            Returns <see langword="null" /> if there is no path between the specified points. Will still return an
            appropriate path object if the start point is equal to the end point.
            </remarks>
            <param name="startX">The x-coordinate of the starting point of the path.</param>
            <param name="startY">The y-coordinate of the starting point of the path.</param>
            <param name="endX">The x-coordinate of the ending point of the path.</param>
            <param name="endY">The y-coordinate of the ending point of the path.</param>
            <param name="assumeEndpointsWalkable">
            Whether or not to assume the start and end points are walkable, regardless of what the
            <see cref="P:GoRogue.Pathing.AStar.WalkabilityView" /> reports. Defaults to <see langword="true" />.
            </param>
            <returns>The shortest path between the two points, or <see langword="null" /> if no valid path exists.</returns>
        </member>
        <member name="T:GoRogue.Pathing.Path">
            <summary>
            Encapsulates a path as returned by pathfinding algorithms like AStar.
            </summary>
            <remarks>
            Provides various functions to iterate through/access steps of the path, as well as
            constant-time reversing functionality.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.Path.#ctor(GoRogue.Pathing.Path,System.Boolean)">
            <summary>
            Creates a copy of the path, optionally reversing the path as it does so.
            </summary>
            <remarks>Reversing is an O(1) operation, since it does not modify the list.</remarks>
            <param name="pathToCopy">The path to copy.</param>
            <param name="reverse">Whether or not to reverse the path. Defaults to <see langword="false" />.</param>
        </member>
        <member name="P:GoRogue.Pathing.Path.End">
            <summary>
            Ending point of the path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Length">
            <summary>
            The length of the path, NOT including the starting point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.LengthWithStart">
            <summary>
            The length of the path, INCLUDING the starting point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Start">
            <summary>
            Starting point of the path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Steps">
            <summary>
            The coordinates that constitute the path (in order), NOT including the starting point.
            These are the coordinates something might walk along to follow a path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.StepsWithStart">
            <summary>
            The coordinates that constitute the path (in order), INCLUDING the starting point.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.Path.GetStep(System.Int32)">
            <summary>
            Gets the nth step along the path, where 0 is the step AFTER the starting point.
            </summary>
            <param name="stepNum">The (array-like index) of the step to get.</param>
            <returns>The coordinate constituting the step specified.</returns>
        </member>
        <member name="M:GoRogue.Pathing.Path.GetStepWithStart(System.Int32)">
            <summary>
            Gets the nth step along the path, where 0 IS the starting point.
            </summary>
            <param name="stepNum">The (array-like index) of the step to get.</param>
            <returns>The coordinate constituting the step specified.</returns>
        </member>
        <member name="M:GoRogue.Pathing.Path.Reverse">
            <summary>
            Reverses the path, in constant time.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.Path.ToString">
            <summary>
            Returns a string representation of all the steps in the path, including the start point,
            eg. [(1, 2), (3, 4), (5, 6)].
            </summary>
            <returns>A string representation of all steps in the path, including the start.</returns>
        </member>
        <member name="T:GoRogue.Pathing.FastAStar">
            <summary>
            A version of <see cref="T:GoRogue.Pathing.AStar" /> that may perform significantly faster, in exchange for not being guaranteed to always
            produce a shortest path.  A
            valid path will still be produced, but it is not guaranteed to be the shortest possible.
            </summary>
            <remarks>
            This class is exactly like a regular <see cref="T:GoRogue.Pathing.AStar" /> instance, but sets the heuristic by default to the
            <see cref="F:SadRogue.Primitives.Distance.Manhattan" />
            calculate function (with the same tie-breaking/smoothing element as regular AStar. In the case that euclidean or
            chebyshev distance is used, this
            heuristic is over-estimating -- that is, it may in some cases produce a value that is greater than the actual shortest
            path between two points.
            As such, this means that, while the algorithm will still produce valid paths, the algorithm is no longer guaranteed to
            produce fully shortest paths.
            In exchange, however, the algorithm may perform significantly faster than an AStar instance with its default heuristic.
            In practice, however, it is worth noting that the paths are often (though not always) the shortest path regardless, and
            when they are not, the deviation
            in length between the path that the algorithm returns and the actual shortest path is often very small (less than 5%).
            As such, it may be viable for use
            in most cases.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.FastAStar.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.Distance)">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityView">
            Map view used to determine whether or not each location can be traversed -- true indicates a tile can be traversed,
            and false indicates it cannot.
            </param>
            <param name="distanceMeasurement">
            Distance calculation used to determine whether 4-way or 8-way connectivity is used, and to determine
            how to calculate the distance between points.
            </param>
        </member>
        <member name="M:GoRogue.Pathing.FastAStar.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Boolean},SadRogue.Primitives.Distance,SadRogue.Primitives.GridViews.IGridView{System.Double},System.Double)">
            <summary>
            </summary>
            <param name="walkabilityView"></param>
            <param name="distanceMeasurement"></param>
            <param name="weights">A map view indicating the weights of each location (see <see cref="P:GoRogue.Pathing.AStar.Weights" />.</param>
            <param name="minimumWeight">
            The minimum value that will be present in <paramref name="weights" />.  It must be greater than 0.0 and
            must be less than or equal to the minimum value present in the weights view -- the algorithm may not produce truly
            shortest paths if
            this condition is not met.  If this minimum changes after construction, it may be updated via the
            <see cref="F:GoRogue.Pathing.AStar.MinimumWeight" /> property.
            </param>
        </member>
        <member name="T:GoRogue.Pathing.FleeMap">
            <summary>
            Implements the concept of a "safety map", also known as "flee map", as described in the
            <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">this article</a>.
            </summary>
            <remarks>
            Takes a goal map, wherein any goals are treated as "threats" to be avoided. Automatically
            recalculated when the underlying goal map is recalculated. Implements IDisposable, so ensure
            that it is disposed of properly after use.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.#ctor(GoRogue.Pathing.GoalMap,System.Double)">
            <summary>
            Constructor. Takes a goal map where in all goals are treated as threats to be avoided,
            and a magnitude to use (defaulting to 1.2).
            </summary>
            <param name="baseMap">The underlying goal map to use.</param>
            <param name="magnitude">Magnitude to multiply by during calculation.</param>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Magnitude">
            <summary>
            The degree to which entities following this flee-map will prefer global safety to local
            safety. Higher values will make entities try to move past an approaching "threat" from
            farther away.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Height">
            <summary>
            Height of the flee map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Width">
            <summary>
            Width of the flee map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Item(SadRogue.Primitives.Point)">
            <summary>
            Returns the flee-map value for the given position.
            </summary>
            <param name="pos">The position to return the value for.</param>
            <returns>The flee-map value for the given location.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.GetDirectionOfMinValue(SadRogue.Primitives.Point)">
            <summary>
            Gets the direction of the neighbor with the minimum flee-map value from the given position.
            </summary>
            <param name="position">The position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="F:SadRogue.Primitives.Direction.None" /> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.GetDirectionOfMinValue(System.Int32,System.Int32)">
            <summary>
            Gets the direction of the neighbor with the minimum flee-map value from the given position.
            </summary>
            <param name="positionX">The x-value of the position to get the minimum value for.</param>
            <param name="positionY">The y-value of the position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="F:SadRogue.Primitives.Direction.None" /> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString">
            <summary>
            Returns the flee-map values represented as a 2D grid-style string.
            </summary>
            <returns>A string representing the flee map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.String)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, where any value that
            isn't null is formatted as per the specified format string.
            </summary>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.Int32)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, with the given field size.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.Int32,System.String)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, with the given field
            size, and any non-null values formatted using the given format string.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.Finalize">
            <summary>
            Destructor for IDisposable implementation.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.Dispose">
            <summary>
            Function called to dispose of the class, automatically un-linking it from its goal map.
            </summary>
        </member>
        <member name="T:GoRogue.Pathing.GoalMap">
            <summary>
            Implementation of a goal map system, also known as Dijkstra maps,
            based on <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">this article</a>
            </summary>
            <remarks>
            This class encapsulates the work of building a goal map from your map level. You provide the
            constructor with a map view representing the map as <see cref="T:GoRogue.Pathing.GoalState" /> values, and
            GoalMap will compute the goal map for the level. When the underlying circumstances of the
            level change, the GoalMap instance will need to be updated. Call <see cref="M:GoRogue.Pathing.GoalMap.Update" /> if obstacles
            have changed, or <see cref="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly" /> if the goals have changed but not the obstacles.
            This class exposes the resulting goal map to you via indexers -- GoalMap implements
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" />, where <see langword="null" /> indicates a square is an obstacle,
            and any other value indicates distance from the nearest goal.  Thus, a value of 0 indicates a tile
            contains a goal.
            For items following the GoalMap, they can simply call <see cref="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(SadRogue.Primitives.Point)" />
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.#ctor(SadRogue.Primitives.GridViews.IGridView{GoRogue.Pathing.GoalState},SadRogue.Primitives.Distance)">
            <summary>
            Constructor. Takes a base map and a distance measurement to use for calculation.
            </summary>
            <param name="baseMap">
            A map view that represents the map as an
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" /> of <see cref="T:GoRogue.Pathing.GoalState"/>.  Must not change
            width/height after the goal map has been constructed.
            </param>
            <param name="distanceMeasurement">
            The distance measurement (and implicitly the <see cref="T:SadRogue.Primitives.AdjacencyRule" />) to use for calculation.
            </param>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.BaseMap">
            <summary>
            The map view of the underlying map used to determine where obstacles/goals are.  Must not change width or
            height after the <see cref="T:GoRogue.Pathing.GoalMap"/> has been constructed.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalMap.DistanceMeasurement">
            <summary>
            The distance measurement the GoalMap is using to calculate distance.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Height">
            <summary>
            Height of the goal map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Width">
            <summary>
            Width of the goal map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Item(SadRogue.Primitives.Point)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="pos">The position to return the goal-map value for.</param>
            <returns>The goal-map value for the given position.</returns>
        </member>
        <member name="E:GoRogue.Pathing.GoalMap.Updated">
            <summary>
            Triggers when the GoalMap is updated.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(SadRogue.Primitives.Point)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="position">The position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="F:SadRogue.Primitives.Direction.None" /> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(System.Int32,System.Int32)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="positionX">The x-value of the position to get the minimum value for.</param>
            <param name="positionY">The y-value of the position to get the minimum value for.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="F:SadRogue.Primitives.Direction.None" /> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString">
            <summary>
            Returns the goal-map values represented as a 2D grid-style string.
            </summary>
            <returns>A string representing the goal map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.String)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, where any value that
            isn't null is formatted as per the specified format string.
            </summary>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.Int32)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, with the given field size.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.Int32,System.String)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, with the given field
            size, and any non-null values formatted using the given format string.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.Update">
            <summary>
            Re-evaluates the entire goal map. Should be called when obstacles change. If the
            obstacles have not changed but the goals have, call <see cref="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly" /> for better efficiency.
            </summary>
            <returns>False if no goals were produced by the evaluator, true otherwise</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly">
            <summary>
            Re-evaluates the walkable portion of the goal map. Should be called anytime the goals change
            but the obstacles haven't.  If the obstacles have also changed, call <see cref="M:GoRogue.Pathing.GoalMap.Update" /> instead.
            </summary>
            <returns>False if no goals were produced by the evaluator, true otherwise</returns>
        </member>
        <member name="T:GoRogue.Pathing.GoalMapExtensions">
            <summary>
            Contains extensions for <see cref="T:SadRogue.Primitives.GridViews.IGridView`1" />, that pertain generally to goal maps.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapExtensions.GetDirectionOfMinValue(SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}},SadRogue.Primitives.Point,SadRogue.Primitives.AdjacencyRule)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="goalMap" />
            <param name="position">The position to get the minimum value for.</param>
            <param name="adjacencyRule">The adjacency rule to use to determine neighbors.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="F:SadRogue.Primitives.Direction.None" /> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapExtensions.GetDirectionOfMinValue(SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}},System.Int32,System.Int32,SadRogue.Primitives.AdjacencyRule)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="goalMap" />
            <param name="positionX">The x-value of the position to get the minimum value for.</param>
            <param name="positionY">The y-value of the position to get the minimum value for.</param>
            <param name="adjacencyRule">The adjacency rule to use to determine neighbors.</param>
            <returns>
            The direction that has the minimum value in the goal-map, or <see cref="F:SadRogue.Primitives.Direction.None" /> if the
            neighbors are all obstacles.
            </returns>
        </member>
        <member name="T:GoRogue.Pathing.GoalMapWeightPair">
            <summary>
            A goal map paired with a weight, designed to be used with <see cref="T:GoRogue.Pathing.WeightedGoalMap"/>.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalMapWeightPair.GoalMap">
            <summary>
            The goal map.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalMapWeightPair.Weight">
            <summary>
            The weight of the specified goal map.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}},System.Double)">
            <summary>
            Constructor.
            </summary>
            <param name="goalMap">The goal map.</param>
            <param name="weight">Weight for the specified goal map.</param>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.Deconstruct(SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}}@,System.Double@)">
            <summary>
            Supports C# Deconstruction syntax.
            </summary>
            <param name="goalMap"/>
            <param name="weight"/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.op_Implicit(GoRogue.Pathing.GoalMapWeightPair)~System.ValueTuple{SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}},System.Double}">
            <summary>
            Implicitly converts a GoalMapWeightPair to an equivalent tuple.
            </summary>
            <param name="pair"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.op_Implicit(System.ValueTuple{SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}},System.Double})~GoRogue.Pathing.GoalMapWeightPair">
            <summary>
            Implicitly converts a tuple to its equivalent GoalMapWeightPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.ToTuple">
            <summary>
            Converts the pair to an equivalent tuple.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.FromTuple(System.ValueTuple{SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}},System.Double})">
            <summary>
            Converts the tuple to an equivalent ComponentTypeTagPair.
            </summary>
            <param name="tuple"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.Equals(GoRogue.Pathing.GoalMapWeightPair)">
            <summary>
            True if the given pair has the same component type and tag; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.Matches(GoRogue.Pathing.GoalMapWeightPair)">
            <summary>
            True if the given pair has the same goal map and weight; false otherwise.
            </summary>
            <param name="other"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.Equals(System.Object)">
            <summary>
            True if the given object is a GoalMapWeightPair and has the same goal map and weight; false otherwise.
            </summary>
            <param name="obj"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.GetHashCode">
            <summary>
            Returns a hash code based on all of the pair's field's.
            </summary>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.op_Equality(GoRogue.Pathing.GoalMapWeightPair,GoRogue.Pathing.GoalMapWeightPair)">
            <summary>
            True if the given pairs have the same goal map and weight; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapWeightPair.op_Inequality(GoRogue.Pathing.GoalMapWeightPair,GoRogue.Pathing.GoalMapWeightPair)">
            <summary>
            True if the given pairs have different goal maps and/or weights; false otherwise.
            </summary>
            <param name="left"/>
            <param name="right"/>
            <returns/>
        </member>
        <member name="T:GoRogue.Pathing.GoalState">
            <summary>
            Used to determine the status of a tile for goal-mapping purposes.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Obstacle">
            <summary>
            A tile that can't be entered and has to be routed around
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Clear">
            <summary>
            A tile that can be entered
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Goal">
            <summary>
            A destination on the goal map.
            </summary>
        </member>
        <member name="T:GoRogue.Pathing.WeightedGoalMap">
             <summary>
             Implementation of the second half of the goal map system described in
             <a href="http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps">this article</a> --
             the ability to combine multiple goal maps with different weights.
             </summary>
             <remarks>
             This class encapsulates the work of building one overall goal map out of multiple existing
             maps. It holds references to one or more maps, each with its own "weight". The higher the
             weight value, the more strongly an AI will attempt to pursue this goal. A negative weight
             inverts the map, turning its goal into something to avoid.  Inverting the weight does not
             create a "safety map" as described in the article, as the resulting goal map will show no
             concept of global vs. local avoidance.  For that functionality, see <see cref="T:GoRogue.Pathing.FleeMap" />.
            
             Note that all the grid views held by this class must have the same width and height.  If their width and height
             change after they are added such that this is not the case, unexpected behavior will occur.
             </remarks>
        </member>
        <member name="F:GoRogue.Pathing.WeightedGoalMap.Weights">
            <summary>
            The list of weighted goal maps. Can be used to add or remove goal maps, or change their weights.
            </summary>
            <remarks>
            When adding a new goal map, its <see cref="P:SadRogue.Primitives.GridViews.IGridView`1.Width" /> and <see cref="P:SadRogue.Primitives.GridViews.IGridView`1.Height" />
            should be identical to the WeightedGoalMap's <see cref="P:GoRogue.Pathing.WeightedGoalMap.Width" /> and
            <see cref="P:GoRogue.Pathing.WeightedGoalMap.Height" />.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}})">
            <summary>
            Constructor. Takes a single goal map and assigns it a weight of 1.0.
            </summary>
            <param name="map">The goal map.</param>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(System.Collections.Generic.IEnumerable{SadRogue.Primitives.GridViews.IGridView{System.Nullable{System.Double}}})">
            <summary>
            Constructor. Takes a sequence of goal maps and assigns each one a weight of 1.0.
            </summary>
            <param name="maps">The goal maps. Each one must be of the same size.</param>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(System.Collections.Generic.IEnumerable{GoRogue.Pathing.GoalMapWeightPair})">
            <summary>
            Constructor. Takes an existing goal map dictionary and copies it.
            </summary>
            <param name="maps">
            The goal maps. Each one must be of the same size, and all weights should have a nonzero value.
            </param>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Height">
            <summary>
            The height of the goal map, and the goal maps that compose it.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Width">
            <summary>
            The width of the goal map, and the goal maps that compose it.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Item(SadRogue.Primitives.Point)">
            <summary>
            Returns the value of the combined goal maps at any given point.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.Combine">
            <summary>
            Computes the entire aggregate goal map and returns it, effectively caching the result.
            This may be useful in situations where the goals are shared between many characters and do not change frequently.
            </summary>
        </member>
        <member name="T:GoRogue.Random.GlobalRandom">
            <summary>
            Static class that contains 1 variable, which is a an RNG instance that is used as the default
            rng by other features (dice, etc) wherever needed, and can also be used if you need a random
            number generator for your own code.
            </summary>
        </member>
        <member name="F:GoRogue.Random.GlobalRandom.DefaultRNG">
            <summary>
            Settable field that specifies what <see cref="T:ShaiRandom.Generators.IEnhancedRandom" /> instance should be considered the default
            RNG. Defaults to an <see cref="T:ShaiRandom.Generators.MizuchiRandom" />, with a random state.
            </summary>
        </member>
        <member name="T:GoRogue.ReflectionAddons">
            <summary>
            Contains a series of functions that complement the reflection capabilities of C#, to conveniently allow for things like
            iterating over all types that a given type can be cast to.
            </summary>
        </member>
        <member name="M:GoRogue.ReflectionAddons.GetRuntimeTypeTree(System.Object)">
            <summary>
            Gets the entire inheritanc/interface tree for the actual run-time type of the object passed in.  This will include
            a type representing the actual run-time type of the object, as well as a type representing each superclass
            of that runtime type, and each interface that runtime type or one of its superclasses implement.
            </summary>
            <param name="instance">Object to return type tree for.</param>
            <returns>
            The complete inheritance/interface tree for the runtime-type of the object passed in, including the runtime type
            itself,
            and all superclasses of that type, as well as Type objects for each interface that runtime type or its superclasses
            implement.
            </returns>
        </member>
        <member name="M:GoRogue.ReflectionAddons.GetTypeTree``1">
            <summary>
            Gets the entire inheritance/interface tree for type T.  This will include a Type that represents type T, as well
            as a Type representing each superclass of T, and each interface that T or its superclasses implement.
            </summary>
            <remarks>
            This function may be somewhat expensive to compute, so if you plan to use it frequently it is recommended to cache
            the results.
            </remarks>
            <typeparam name="T">Type to get inheritance/interface tree for.</typeparam>
            <returns>
            The complete interface/inheritance tree of T, including T, all superclasses, and all interfaces T or its
            superclasses implement.
            </returns>
        </member>
        <member name="M:GoRogue.ReflectionAddons.GetTypeTree(System.Type)">
            <summary>
            Gets the entire inheritance/interface tree for the type specified.  This will include the <paramref name="type" />
            itself,
            as well as a Type representing each superclass of the type represented by <paramref name="type" />, and each
            interface that <paramref name="type" /> or its superclasses implement.
            </summary>
            <remarks>
            This function may be somewhat expensive to compute, so if you plan to use it frequently it is recommended to cache
            the results.
            </remarks>
            <returns>
            The complete interface/inheritance for the type represented by <paramref name="type" />, including
            <paramref name="type" />,
            all superclasses, and all interfaces T or its superclasses implement.
            </returns>
        </member>
        <member name="T:GoRogue.SenseMapping.IReadOnlySenseMap">
            <summary>
            Read-only interface of an <see cref="T:GoRogue.SenseMapping.ISenseMap" />.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.CurrentSenseMap">
            <summary>
            IEnumerable of only positions currently "in" the sense map, eg. all positions that have a
            value other than 0.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.NewlyInSenseMap">
            <summary>
            IEnumerable of positions that DO have a non-zero value in the sense map as of the most
            current Calculate call, but DID NOT have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.NewlyOutOfSenseMap">
            <summary>
            IEnumerable of positions that DO NOT have a non-zero value in the sense map as of the
            most current Calculate call, but DID have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.SenseSources">
            <summary>
            Read-only list of all sources currently considered part of the sense map. Some may have their
            <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Enabled" /> flag set to false, so all of these may or may not be counted
            when Calculate is called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.ResistanceView">
            <summary>
            The resistance map used to perform calculations.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.ResultView">
            <summary>
            A view of the sense map's calculation results.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.IReadOnlySenseMap.AsReadOnly">
            <summary>
            Returns a read-only representation of the sensory map.
            </summary>
            <returns>This sensory map object as <see cref="T:GoRogue.SenseMapping.IReadOnlySenseMap" />.</returns>
        </member>
        <member name="T:GoRogue.SenseMapping.ISenseMap">
             <summary>
             Interface for calculating a map representing senses (sound, light, etc), or generally anything
             that can be modeled as sources propagating through a map that has degrees of resistance to spread.
             </summary>
             <remarks>
             If you're looking for an existing implementation of this interface to use, see <see cref="T:GoRogue.SenseMapping.SenseMap"/>.  If you instead want
             to implement your own, you may want to consider using <see cref="T:GoRogue.SenseMapping.SenseMapBase"/> as your base class, as it simplifies the
             implementation considerably.
             
             This interface functions on the concept of having one or more <see cref="T:GoRogue.SenseMapping.Sources.ISenseSource"/> instances, which are capable
             of using some algorithm to propagate the source through a map.  The map, and therefore each source, uses a grid view
             of doubles as its map representation, where each double represents the "resistance" that location has to the passing of
             source values through it. The values must be >= 0.0, where 0.0 means that a location has no resistance to spreading of
             source values, and greater values represent greater resistance.  The scale of this resistance is arbitrary, and is
             related to the <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Intensity" /> of your sources.
            
             Other than the constraint that 0.0 means a cell has no resistance, the interfaces/APIs themselves impose no strict limitations
             on the definition of the intensity and resistance values.  The default implementations of these interfaces in GoRogue treat
             the resistance view value as a value which is subtracted from source's remaining intensity as they propagate through that cell;
             so as a source spreads through a given location, a value equal to the resistance value of that location is subtracted from the
             source's value (plus the normal fall-of for distance).  However, if some other method is needed, a custom <see cref="T:GoRogue.SenseMapping.Sources.ISenseSource"/>
             can be implemented; see that interface's documentation for details.
            
             Generally, usage involves performing and aggregating calculations for all sense sources by calling the <see cref="M:GoRogue.SenseMapping.ISenseMap.Calculate" />
             function, then accessing the results via <see cref="P:GoRogue.SenseMapping.IReadOnlySenseMap.ResultView"/>.  These values will be 0.0 if no source spread to that
             location, and greater than 0.0 to indicate the strength of the combined sources which spread there.
             </remarks>
        </member>
        <member name="E:GoRogue.SenseMapping.ISenseMap.Recalculated">
            <summary>
            Fired whenever the SenseMap is recalculated.
            </summary>
        </member>
        <member name="E:GoRogue.SenseMapping.ISenseMap.SenseMapReset">
            <summary>
            Fired when the existing SenseMap is reset prior to calculating a new one.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.ISenseMap.AddSenseSource(GoRogue.SenseMapping.Sources.ISenseSource)">
            <summary>
            Adds the given source to the list of sources. If the source has its
            <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Enabled" /> flag set when <see cref="M:GoRogue.SenseMapping.ISenseMap.Calculate" /> is next called, then
            it will be counted as a source.
            </summary>
            <param name="senseSource">The source to add.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.ISenseMap.RemoveSenseSource(GoRogue.SenseMapping.Sources.ISenseSource)">
            <summary>
            Removes the given source from the list of sources. Generally, use this if a source is permanently removed
            from a map. For temporary disabling, you should generally use the <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Enabled" /> flag.
            </summary>
            <remarks>
            The source values that this sense source was responsible for are NOT removed from the sensory output values
            until <see cref="M:GoRogue.SenseMapping.ISenseMap.Calculate" /> is next called.
            </remarks>
            <param name="senseSource">The source to remove.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.ISenseMap.Calculate">
            <summary>
            Calculates the map.  For each enabled source in the source list, it calculates
            the source's spreading, and puts them all together in the sense map's output.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.ISenseMap.Reset">
            <summary>
            Resets the given sense map by erasing the current recorded result values.
            </summary>
            <remarks>
            After this function is called, any value in <see cref="P:GoRogue.SenseMapping.IReadOnlySenseMap.ResultView"/> will be 0.
            Additionally,<see cref="P:GoRogue.SenseMapping.IReadOnlySenseMap.CurrentSenseMap"/> will be blank.
            </remarks>
        </member>
        <member name="T:GoRogue.SenseMapping.SenseMap">
             <summary>
             Implementation of <see cref="T:GoRogue.SenseMapping.ISenseMap"/> that implements the required fields/methods in a way applicable to many typical use cases.
             </summary>
             <remarks>
             This implementation of <see cref="T:GoRogue.SenseMapping.ISenseMap"/> implements the enumerables by using a pair of hash maps to keep track of the positions
             which are non-0 in the current (and previous) calculate calls.  This provides relatively efficient implementations that should be applicable
             to a variety of use cases.
            
             The calculation, by default, is performed by first calling the <see cref="M:GoRogue.SenseMapping.Sources.ISenseSource.CalculateLight"/> function of all sources.  This is performed
             in parallel via a Parallel.ForEach loop, if there is more than one source and the <see cref="P:GoRogue.SenseMapping.SenseMap.ParallelCalculate"/> property is set to true. Generally, even at
             2 sense sources there is notable benefit to parallelizing the calculation; however feel free to use this flag to tweak this to your use case.
            
             After all calculations are complete, the <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/> implementation then takes the result view of each source and copies it to the appropriate
             section of the <see cref="P:GoRogue.SenseMapping.IReadOnlySenseMap.ResultView"/> property.  This is done sequentially, in order to avoid any problems with overlapping sources.
             Values are aggregated by simply adding the current value and the new value together.
            
             If you want to customize the way values are aggregated together, you may customize the <see cref="M:GoRogue.SenseMapping.SenseMap.ApplySenseSourceToResult(GoRogue.SenseMapping.Sources.ISenseSource)"/> function.  This function is
             used to apply the result view of the specified sense source onto the result view.  If you simply want to change the aggregation method, then you can copy-paste
             the function and change the line that performs the aggregation; the aggregation method itself is not provided as a separate function for performance reasons.
             You may also override this function to customize the order/method of performing the aggregation.
            
             Most other customization would require overriding the <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/> function.
            
             You may also simply create your own implementation of <see cref="T:GoRogue.SenseMapping.Sources.ISenseSource"/>, either by directly implementing that interface or inheriting from
             <see cref="T:GoRogue.SenseMapping.SenseMapBase"/>.  This may be the best option if, for example, you want to avoid the use of a hash set in the enumerable implementation. 
             </remarks>
        </member>
        <member name="F:GoRogue.SenseMapping.SenseMap.CurrentSenseMapBacking">
             <summary>
             A hash set which contains the positions which have non-0 values in the most current calculation result.
             </summary>
             <remarks>
             This hash set is the backing structure for <see cref="P:GoRogue.SenseMapping.SenseMap.NewlyInSenseMap"/> and <see cref="P:GoRogue.SenseMapping.SenseMap.NewlyOutOfSenseMap"/>,
             as well as <see cref="P:GoRogue.SenseMapping.SenseMap.CurrentSenseMap"/>. During <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/>, this value is cleared before
             the new calculations are performed.
            
             Typically you will only need to interact with this if you are overriding <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/>; in this case, if
             you do not call this class's implementation, you will need to perform this clearing yourself.
            
             In order to preserve the use of whatever hasher was passed to the class at startup, it is recommended that you do _not_
             re-allocate this structure entirely.  See <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/> for a way to manage both this and <see cref="F:GoRogue.SenseMapping.SenseMap.PreviousSenseMapBacking"/>
             that does not involve re-allocating.
             </remarks>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.CurrentSenseMap">
            <inheritdoc />
        </member>
        <member name="F:GoRogue.SenseMapping.SenseMap.PreviousSenseMapBacking">
             <summary>
             A hash set which contains the positions which had non-0 values in the previous calculation result.
             </summary>
             <remarks>
             This hash set is the backing structure for <see cref="P:GoRogue.SenseMapping.SenseMap.NewlyInSenseMap"/> and <see cref="P:GoRogue.SenseMapping.SenseMap.NewlyOutOfSenseMap"/>.
             
             Typically you will only need to interact with this if you are overriding <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/>; in this case, if
             you do not call this class's implementation, you will need to ensure this is set as appropriate before the new calculation is performed.
            
             In order to preserve the use of whatever hasher was passed to the class at startup, it is recommended that you do _not_
             re-allocate this structure entirely.  See <see cref="M:GoRogue.SenseMapping.SenseMap.OnCalculate"/> for a way to manage both this and <see cref="F:GoRogue.SenseMapping.SenseMap.CurrentSenseMapBacking"/>
             that does not involve re-allocating.
             </remarks>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.ParallelCalculate">
             <summary>
             Whether or not to calculate each sense source's spread algorithm in parallel.  Has no effect if there is only one source added.
             </summary>
             <remarks>
             When this is set to true, calling of <see cref="M:GoRogue.SenseMapping.Sources.ISenseSource.CalculateLight"/> will happen in parallel via multiple threads.  A
             Parallel.ForEach will be used, which will enable the use of a thread pool.
            
             In either case, the default implementation of sense sources always have their own result views on which they perform their calculations,
             so there is no concern with overlapping sources.  This does NOT affect the copying of sense source's values from its local result view
             to the sense map's one, which in the default implementation is always sequential.
             </remarks>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Double},System.Nullable{GoRogue.SenseMapping.CustomResultViewWithResize},System.Boolean,System.Collections.Generic.IEqualityComparer{SadRogue.Primitives.Point})">
             <summary>
             Constructor.
             </summary>
             <param name="resistanceView">The resistance view to use for calculations.</param>
             <param name="resultViewAndResizer">
             The view in which the sense map calculation results are stored, along with a method to use to resize it as needed.
            
             If unspecified or null, an ArrayView will be used for the result view, and the resize function will allocate a new
             ArrayView of the appropriate size as needed.  This should be sufficient for most use cases.
            
             The resizer function must return a view with all of its values set to 0.0, which has the given width and height.
             </param>
             <param name="parallelCalculate">Whether or not to calculate the sense sources in parallel using Parallel.ForEach.  Has no effect if there is only one source added.</param>
             <param name="hasher">The hashing algorithm to use for points in hash sets.  Defaults to the default hash algorithm for Points.</param>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.NewlyInSenseMap">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.NewlyOutOfSenseMap">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.Reset">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.OnCalculate">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ApplySenseSourceToResult(GoRogue.SenseMapping.Sources.ISenseSource)">
            <summary>
            Takes the given source and applies its values to the appropriate sub-area of <see cref="F:GoRogue.SenseMapping.SenseMapBase.ResultViewBacking"/>.  Adds any locations that
            end up with non-0 values to the <see cref="F:GoRogue.SenseMapping.SenseMap.CurrentSenseMapBacking"/> hash set.
            </summary>
            <remarks>
            Override this if you need to control the aggregation function (eg. do something other than add values together), or if you want to apply results
            of sense source calculations to the sense map in a different way.
            </remarks>
            <param name="source">The source to apply.</param>
        </member>
        <member name="T:GoRogue.SenseMapping.CustomResultViewWithResize">
             <summary>
             A structure containing a grid view and a custom resize function to use in order to resize that grid view to a new size.
             </summary>
             <remarks>
             <see cref="F:GoRogue.SenseMapping.CustomResultViewWithResize.Resizer"/> takes in the new width/height required and the old grid view; and must return a new grid view of the appropriate
             size.  It can return a new object or an existing one; the result in either case will be assigned to the result view of the sense map
             when the resize takes place.  The resize function must also ensure that, when the new grid view is returned, it must have all values
             set to 0.0.  This allows a clear operation to be avoided if underlying data structures were re-allocated and thus cells are implicitly
             cleared.
            
             This structure also provides a <see cref="M:GoRogue.SenseMapping.CustomResultViewWithResize.ArrayViewResizer(System.Int32,System.Int32,SadRogue.Primitives.GridViews.ISettableGridView{System.Double})"/>, which is an efficient resizer to use if the <see cref="F:GoRogue.SenseMapping.CustomResultViewWithResize.ResultView"/> is an
             ArrayView.
             </remarks>
        </member>
        <member name="F:GoRogue.SenseMapping.CustomResultViewWithResize.ResultView">
            <summary>
            The initial result view to use.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.CustomResultViewWithResize.Resizer">
            <summary>
            The resizer function to use.  See the <see cref="T:GoRogue.SenseMapping.CustomResultViewWithResize"/> class description for constraints on this function.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.CustomResultViewWithResize.#ctor(SadRogue.Primitives.GridViews.ISettableGridView{System.Double},System.Func{System.Int32,System.Int32,SadRogue.Primitives.GridViews.ISettableGridView{System.Double},SadRogue.Primitives.GridViews.ISettableGridView{System.Double}})">
            <summary>
            Constructor.
            </summary>
            <param name="resultView">Result view to initially use.</param>
            <param name="resizer">Resizer function which must clear, resize, and return the result view.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.CustomResultViewWithResize.ArrayViewResizer(System.Int32,System.Int32,SadRogue.Primitives.GridViews.ISettableGridView{System.Double})">
            <summary>
            An array resize function appropriate for use as a <see cref="F:GoRogue.SenseMapping.CustomResultViewWithResize.Resizer"/> when the grid view
            being used is an ArrayView.
            </summary>
            <param name="width"/>
            <param name="height"/>
            <param name="currentView"/>
            <returns>An array view re-allocated/cleared as appropriate.</returns>
        </member>
        <member name="T:GoRogue.SenseMapping.SenseMapBase">
             <summary>
             Base class that is convenient for creating custom implementations of the <see cref="T:GoRogue.SenseMapping.ISenseMap"/> interface.
             </summary>
             <remarks>
             This class implements much of the boilerplate code required to implement <see cref="T:GoRogue.SenseMapping.ISenseMap"/> properly, making
             sure that the implementer has to implement only the minimal subset of functions and properties.
            
             An implementer should implement <see cref="M:GoRogue.SenseMapping.SenseMapBase.OnCalculate"/> to perform the spread calculation for all sense sources
             and aggregate it into <see cref="P:GoRogue.SenseMapping.SenseMapBase.ResultView"/>.  Notably, the implementer SHOULD NOT call <see cref="M:GoRogue.SenseMapping.SenseMapBase.Reset"/> nor perform
             any equivalent functionality, and SHOULD NOT fire the <see cref="E:GoRogue.SenseMapping.SenseMapBase.Recalculated"/> or <see cref="E:GoRogue.SenseMapping.SenseMapBase.SenseMapReset"/> events.
             All of this is taken care of the the <see cref="M:GoRogue.SenseMapping.SenseMapBase.Calculate"/> function, which calls OnCalculate.
            
             Implementers may specify a custom grid view to use a a result, and must also supply a resizing function in the constructor.
             This allows the sense map to resize the result view if the transparency view changes sizes.  Typically, an array view along with
             a <see cref="M:GoRogue.SenseMapping.CustomResultViewWithResize.ArrayViewResizer(System.Int32,System.Int32,SadRogue.Primitives.GridViews.ISettableGridView{System.Double})"/> as the resizer is sufficient.
            
             Finally, the implementer must implement the <see cref="P:GoRogue.SenseMapping.SenseMapBase.CurrentSenseMap"/>, <see cref="P:GoRogue.SenseMapping.SenseMapBase.NewlyInSenseMap"/>, and <see cref="P:GoRogue.SenseMapping.SenseMapBase.NewlyOutOfSenseMap"/>
             enumerables.  This allows the implementer to control the method of tracking it.
             </remarks>
        </member>
        <member name="F:GoRogue.SenseMapping.SenseMapBase.ResultViewBacking">
            <summary>
            The actual grid view which is used to record results.  Exposed publicly in a read-only fashion via
            <see cref="P:GoRogue.SenseMapping.SenseMapBase.ResultView"/>.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SenseMapBase.ResultViewResizer">
             <summary>
             The function to use to resize the ResultView if the resistance view changes sizes between calculate calls.
             The function should perform any necessary operations and return a grid view which is of the appropriate size.
            
             The function must return a view with all values set to 0.0, which has the width and height given.
             </summary>
        </member>
        <member name="E:GoRogue.SenseMapping.SenseMapBase.Recalculated">
            <inheritdoc/>
        </member>
        <member name="E:GoRogue.SenseMapping.SenseMapBase.SenseMapReset">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMapBase.ResistanceView">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMapBase.ResultView">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMapBase.SenseSources">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMapBase.CurrentSenseMap">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMapBase.NewlyInSenseMap">
            <inheritdoc />
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMapBase.NewlyOutOfSenseMap">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.#ctor(SadRogue.Primitives.GridViews.IGridView{System.Double},System.Nullable{GoRogue.SenseMapping.CustomResultViewWithResize})">
             <summary>
             Constructor.
             </summary>
             <param name="resistanceView">The resistance map to use for calculations.</param>
             <param name="resultViewAndResizer">
             The view in which SenseMap calculation results are stored, along with a method to use to resize it as needed.
            
             If unspecified, an ArrayView will be used for the result view, and the resize function will allocate a new
             ArrayView of the appropriate size as needed.  This should be sufficient for most use cases.
            
             This function must return a view with all of its values set to 0.0, which has the given width and height.
             </param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.AsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.AddSenseSource(GoRogue.SenseMapping.Sources.ISenseSource)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.RemoveSenseSource(GoRogue.SenseMapping.Sources.ISenseSource)">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.Calculate">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.Reset">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.OnCalculate">
            <summary>
            Performs <see cref="M:GoRogue.SenseMapping.Sources.ISenseSource.CalculateLight"/> on all sources, and aggregates their results into <see cref="F:GoRogue.SenseMapping.SenseMapBase.ResultViewBacking"/>.
            </summary>
            <remarks>
            Custom implementations should implement this function to perform their calculation; the Calculate function
            calls reset first, then calls this, automatically firing relevant events.
            </remarks>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.ToString(System.Char,System.Char,System.Char)">
            <summary>
            ToString that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in the SenseMap.</param>
            <param name="center">
            The character used for any location that is the center-point of a source.
            </param>
            <param name="sourceValue">
            The character used for any location that is in range of a source, but not a center point.
            </param>
            <returns>The string representation of the SenseMap, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.ToString">
            <summary>
            Returns a string representation of the map, where any location not in the SenseMap is
            represented by a '-' character, any position that is the center of some source is
            represented by a 'C' character, and any position that has a non-zero value but is not a
            center is represented by an 'S'.
            </summary>
            <returns>A (multi-line) string representation of the SenseMap.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMapBase.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the SenseMap,
            rounded to the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>
            A string representation of the map, rounded to the given number of decimal places.
            </returns>
        </member>
        <member name="T:GoRogue.SenseMapping.Sources.ISenseSource">
            <summary>
            Interfaces representing sources which can be used by sense maps.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.ResultView">
            <summary>
            A grid view representing the result of a sense map calculation.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Position">
            <summary>
            The position on a map that the source is located at.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Radius">
            <summary>
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed. Changing this will trigger
            resizing (re-allocation) of the underlying arrays.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Decay">
            <summary>
            The amount of decrease in sense source value per unit of distance.  Calculated automatically as a product of
            <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Intensity"/> and <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Radius"/>.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Enabled">
            <summary>
            Whether or not this source is enabled. If a source is disabled when <see cref="M:GoRogue.SenseMapping.ISenseMap.Calculate" />
            is called, the source does not calculate values and is effectively assumed to be "off".
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.IsAngleRestricted">
            <summary>
            Whether or not the spreading of values from this source is restricted to an angle and span.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Intensity">
            <summary>
            The starting value of the source to spread.  Defaults to 1.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Angle">
            <summary>
            If <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.IsAngleRestricted" /> is true, the angle in degrees that represents a line from the source's start to
            the outermost center point of the cone formed by the source's calculated values.  0 degrees points up, and
            increases in angle move clockwise (like a compass).
            Otherwise, this will be 0.0 degrees.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.Span">
            <summary>
            If <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.IsAngleRestricted" /> is true, the angle in degrees that represents the full arc of the cone formed by
            the source's calculated values.  Otherwise, it will be 360 degrees.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.ISenseSource.ResistanceView">
            <summary>
            The resistance map used to perform calculations.
            </summary>
            <remarks>
            Sense map implementations will set this to the sense map's resistance map prior to calculating.  This can be set via
            <see cref="M:GoRogue.SenseMapping.Sources.ISenseSource.SetResistanceMap(SadRogue.Primitives.GridViews.IGridView{System.Double})"/>, but you shouldn't do this unless you're creating a custom sense map implementation.
            </remarks>
        </member>
        <member name="E:GoRogue.SenseMapping.Sources.ISenseSource.RadiusChanged">
            <summary>
            Fired when the radius of the source changes.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.ISenseSource.CalculateLight">
            <summary>
            Perform the lighting calculations if the source is enabled, by first clearing results of the existing calculation, then re-calculating it
            by calling <see cref="M:GoRogue.SenseMapping.Sources.ISenseSource.OnCalculate"/>.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.ISenseSource.OnCalculate">
            <summary>
            Performs the actual spreading calculation.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.ISenseSource.SetResistanceMap(SadRogue.Primitives.GridViews.IGridView{System.Double})">
            <summary>
            Should ONLY be called from SenseMap or equivalent implementations.  Sets the resistance map used by the source for calculations.
            </summary>
            <param name="resMap"></param>
        </member>
        <member name="T:GoRogue.SenseMapping.Sources.RecursiveShadowcastingSenseSource">
             <summary>
             A sense source which performs its spreading calculations by using a recursive shadowcasting algorithm.
             </summary>
             <remarks>
             Any location on the resistance map which is not _fully_ blocking (eg. has a value less than the source's
             <see cref="P:GoRogue.SenseMapping.Sources.ISenseSource.Intensity"/>) is considered to be fully transparent, because this implementation of
             shadow-casting is an on-off algorithm.
            
             This calculation is faster but obviously doesn't offer support for partial resistance.  It may be useful when you only
             want a rough light approximation, or where your resistance map is on-off anyway.
             </remarks>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RecursiveShadowcastingSenseSource.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double)">
            <summary>
            Creates a source which spreads outwards in all directions.
            </summary>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RecursiveShadowcastingSenseSource.#ctor(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double)">
            <summary>
            Creates a source which spreads outwards in all directions.
            </summary>
            <param name="positionX">
            The X-value of the position on a map that the source is located at.
            </param>
            <param name="positionY">
            The Y-value of the position on a map that the source is located at.
            </param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RecursiveShadowcastingSenseSource.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source which spreads only in a cone defined by the given angle and span.
            </summary>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RecursiveShadowcastingSenseSource.#ctor(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source which spreads only in a cone defined by the given angle and span.
            </summary>
            <param name="positionX">The x-value for the position on a map that the source is located at.</param>
            <param name="positionY">The y-value for the position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RecursiveShadowcastingSenseSource.OnCalculate">
            <summary>
            Performs the spread calculations via recursive shadowcasting.
            </summary>
        </member>
        <member name="T:GoRogue.SenseMapping.Sources.RippleType">
            <summary>
            Different types of Ripple algorithms for how source values spread from their source's location.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.RippleType.Regular">
            <summary>
            Performs calculation by pushing values out from the source location. Source values spread
            around corners a bit.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.RippleType.Loose">
            <summary>
            Similar to <see cref="F:GoRogue.SenseMapping.Sources.RippleType.Regular" /> but with different spread mechanics. Values spread around edges like
            smoke or water, but maintains a tendency to curl towards the start position as it goes around edges.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.RippleType.Tight">
            <summary>
            Similar to <see cref="F:GoRogue.SenseMapping.Sources.RippleType.Regular" />, but values spread around corners only very slightly.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.RippleType.VeryLoose">
            <summary>
            Similar to <see cref="F:GoRogue.SenseMapping.Sources.RippleType.Regular" />, but values spread around corners a lot.
            </summary>
        </member>
        <member name="T:GoRogue.SenseMapping.Sources.RippleSenseSource">
             <summary>
             A sense source which performs its spreading calculations by using a "ripple" algorithm.
             </summary>
             <remarks>
             Values spread out from the center, decreasing with distance and in accordance with the resistance for each cell they encounter.
            
             There are several variations of the algorithm provided, which produce slightly different spreading tendencies.  See the <see cref="P:GoRogue.SenseMapping.Sources.RippleSenseSource.RippleType"/>
             value documentation for details.
             </remarks>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.RippleSenseSource.RippleType">
            <summary>
            The variation of the ripple algorithm being used.  See the <see cref="T:GoRogue.SenseMapping.Sources.RippleType"/> value documentation for descriptions of each.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RippleSenseSource.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,GoRogue.SenseMapping.Sources.RippleType,System.Double)">
            <summary>
            Creates a source which spreads outwards in all directions.
            </summary>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="rippleType">The variation of the ripple algorithm to use.  See the <see cref="T:GoRogue.SenseMapping.Sources.RippleType"/> value documentation for descriptions of each.</param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RippleSenseSource.#ctor(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,GoRogue.SenseMapping.Sources.RippleType,System.Double)">
            <summary>
            Creates a source which spreads outwards in all directions.
            </summary>
            <param name="positionX">
            The X-value of the position on a map that the source is located at.
            </param>
            <param name="positionY">
            The Y-value of the position on a map that the source is located at.
            </param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="rippleType">The variation of the ripple algorithm to use.  See the <see cref="T:GoRogue.SenseMapping.Sources.RippleType"/> value documentation for descriptions of each.</param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RippleSenseSource.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double,GoRogue.SenseMapping.Sources.RippleType,System.Double)">
            <summary>
            Constructor.  Creates a source which spreads only in a cone defined by the given angle and span.
            </summary>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="rippleType">The variation of the ripple algorithm to use.  See the <see cref="T:GoRogue.SenseMapping.Sources.RippleType"/> value documentation for descriptions of each.</param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RippleSenseSource.#ctor(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double,GoRogue.SenseMapping.Sources.RippleType,System.Double)">
            <summary>
            Constructor.  Creates a source which spreads only in a cone defined by the given angle and span.
            </summary>
            <param name="positionX">The x-value for the position on a map that the source is located at.</param>
            <param name="positionY">The y-value for the position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="rippleType">The variation of the ripple algorithm to use.  See the <see cref="T:GoRogue.SenseMapping.Sources.RippleType"/> value documentation for descriptions of each.</param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RippleSenseSource.OnCalculate">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.RippleSenseSource.Reset">
            <inheritdoc/>
        </member>
        <member name="T:GoRogue.SenseMapping.Sources.SenseSourceBase">
            <summary>
            A base class for creating <see cref="T:GoRogue.SenseMapping.Sources.ISenseSource"/> implementations that boils an implementation down to primarily implementing the <see cref="M:GoRogue.SenseMapping.Sources.SenseSourceBase.OnCalculate"/>
            function.
            </summary>
            <remarks>
            This class uses an ArrayView as the <see cref="P:GoRogue.SenseMapping.Sources.SenseSourceBase.ResultView"/>, in order to enable common functions efficiently.  Use cases for a custom view here should be
            relatively limited, as the view must be settable and resizable; if a custom implementation is needed, you may implement <see cref="T:GoRogue.SenseMapping.Sources.ISenseSource"/> directly.
            </remarks>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.SenseSourceBase.Size">
            <summary>
            The size of the result view (eg. it's width and height); cached for efficiency and convenience.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.SenseSourceBase.Center">
            <summary>
            The coordinate which will be the center point of the result view, ie. the center is (Center, Center).
            </summary>
            <remarks>
            This is equivalent to Size / 2; however is cached for performance and convenience since this calculation is performed frequently.
            </remarks>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.SenseSourceBase.ResultViewBacking">
            <summary>
            The result view used to record results.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.ResultView">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Decay">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Position">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Radius">
            <inheritdoc/>
        </member>
        <member name="E:GoRogue.SenseMapping.Sources.SenseSourceBase.RadiusChanged">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.DistanceCalc">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Enabled">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.IsAngleRestricted">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Intensity">
            <inheritdoc/>
        </member>
        <member name="F:GoRogue.SenseMapping.Sources.SenseSourceBase.AngleInternal">
            <summary>
            The <see cref="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Angle"/> value, but offset 90 degrees clockwise; ie, 0 points right instead of up.  This value typically
            works better for actual light calculations (as the definition more closely matches the unit circle).
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Angle">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.Span">
            <inheritdoc/>
        </member>
        <member name="P:GoRogue.SenseMapping.Sources.SenseSourceBase.ResistanceView">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double)">
            <summary>
            Creates a source which spreads outwards in all directions.
            </summary>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.#ctor(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double)">
            <summary>
            Creates a source which spreads outwards in all directions.
            </summary>
            <param name="positionX">
            The X-value of the position on a map that the source is located at.
            </param>
            <param name="positionY">
            The Y-value of the position on a map that the source is located at.
            </param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.#ctor(SadRogue.Primitives.Point,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source which spreads only in a cone defined by the given angle and span.
            </summary>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.#ctor(System.Int32,System.Int32,System.Double,SadRogue.Primitives.Distance,System.Double,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source which spreads only in a cone defined by the given angle and span.
            </summary>
            <param name="positionX">The x-value for the position on a map that the source is located at.</param>
            <param name="positionY">The y-value for the position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to <see cref="T:SadRogue.Primitives.Distance" />, such as <see cref="T:SadRogue.Primitives.Radius" />).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            <paramref name="angle" /> / 2 degrees are included on either side of the cone's center line.
            </param>
            <param name="intensity">The starting intensity value of the source. Defaults to 1.0.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.Reset">
            <summary>
            Resets calculation state so a new set of calculations can begin.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.CalculateLight">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.OnCalculate">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.SetResistanceMap(SadRogue.Primitives.GridViews.IGridView{System.Double})">
            <inheritdoc/>
        </member>
        <member name="M:GoRogue.SenseMapping.Sources.SenseSourceBase.ToString">
            <summary>
            Returns a string representation of the configuration of this SenseSource.
            </summary>
            <returns>A string representation of the configuration of this SenseSource.</returns>
        </member>
        <member name="T:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.Components.ComponentCollection"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized.Components">
            <summary>
            List of components in the collection.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized.op_Implicit(GoRogue.Components.ComponentCollection)~GoRogue.SerializedTypes.Components.ComponentCollectionSerialized">
            <summary>
            Converts <see cref="T:GoRogue.Components.ComponentCollection"/> to <see cref="T:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized"/>.
            </summary>
            <param name="collection"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized.op_Implicit(GoRogue.SerializedTypes.Components.ComponentCollectionSerialized)~GoRogue.Components.ComponentCollection">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized"/> to <see cref="T:GoRogue.Components.ComponentCollection"/>.
            </summary>
            <param name="collection"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized.FromComponentCollection(GoRogue.Components.ComponentCollection)">
            <summary>
            Converts <see cref="T:GoRogue.Components.ComponentCollection"/> to <see cref="T:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized"/>.
            </summary>
            <param name="collection"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized.ToComponentCollection">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.Components.ComponentCollectionSerialized"/> to <see cref="T:GoRogue.Components.ComponentCollection"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.DiceNotation.DiceExpression"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized.Expression">
            <summary>
            Expression in dice notation representing the expression.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized.op_Implicit(GoRogue.DiceNotation.DiceExpression)~GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized">
            <summary>
            Converts <see cref="T:GoRogue.DiceNotation.DiceExpression"/> to <see cref="T:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized"/>.
            </summary>
            <param name="expression"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized.op_Implicit(GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized)~GoRogue.DiceNotation.DiceExpression">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized"/> to <see cref="T:GoRogue.DiceNotation.DiceExpression"/>.
            </summary>
            <param name="expression"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized.FromDiceExpression(GoRogue.DiceNotation.DiceExpression)">
            <summary>
            Converts <see cref="T:GoRogue.DiceNotation.DiceExpression"/> to <see cref="T:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized"/>.
            </summary>
            <param name="expression"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized.ToDiceExpression">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.DiceNotation.DiceExpressionSerialized"/> to <see cref="T:GoRogue.DiceNotation.DiceExpression"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.Factories.AdvancedFactory`3"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3.Blueprints">
            <summary>
            Blueprints in the factory.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3.op_Implicit(GoRogue.Factories.AdvancedFactory{`0,`1,`2})~GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized{`0,`1,`2}">
            <summary>
            Converts <see cref="T:GoRogue.Factories.AdvancedFactory`3"/> to
            <see cref="T:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3"/>.
            </summary>
            <param name="factory"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3.op_Implicit(GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized{`0,`1,`2})~GoRogue.Factories.AdvancedFactory{`0,`1,`2}">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3"/> to
            <see cref="T:GoRogue.Factories.AdvancedFactory`3"/>.
            </summary>
            <param name="factory"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3.FromAdvancedFactory(GoRogue.Factories.AdvancedFactory{`0,`1,`2})">
            <summary>
            Converts <see cref="T:GoRogue.Factories.AdvancedFactory`3"/> to
            <see cref="T:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3"/>.
            </summary>
            <param name="factory"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3.ToAdvancedFactory">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.Factories.AdvancedFactorySerialized`3"/> to
            <see cref="T:GoRogue.Factories.AdvancedFactory`3"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.Factories.FactorySerialized`2">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.Factories.Factory`2"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.Factories.FactorySerialized`2.Blueprints">
            <summary>
            Blueprints in the factory.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.FactorySerialized`2.op_Implicit(GoRogue.Factories.Factory{`0,`1})~GoRogue.SerializedTypes.Factories.FactorySerialized{`0,`1}">
            <summary>
            Converts <see cref="T:GoRogue.Factories.Factory`2"/> to <see cref="T:GoRogue.SerializedTypes.Factories.FactorySerialized`2"/>.
            </summary>
            <param name="factory"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.FactorySerialized`2.op_Implicit(GoRogue.SerializedTypes.Factories.FactorySerialized{`0,`1})~GoRogue.Factories.Factory{`0,`1}">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.Factories.FactorySerialized`2"/> to <see cref="T:GoRogue.Factories.Factory`2"/>.
            </summary>
            <param name="factory"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.FactorySerialized`2.FromFactory(GoRogue.Factories.Factory{`0,`1})">
            <summary>
            Converts <see cref="T:GoRogue.Factories.Factory`2"/> to <see cref="T:GoRogue.SerializedTypes.Factories.FactorySerialized`2"/>.
            </summary>
            <param name="factory"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.Factories.FactorySerialized`2.ToFactory">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.Factories.FactorySerialized`2"/> to <see cref="T:GoRogue.Factories.Factory`2"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList"/> instance.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized.RoomsAndDoors">
            <summary>
            List of recorded rooms and associated doors.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized.op_Implicit(GoRogue.MapGeneration.ContextComponents.DoorList)~GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized"/>.
            </summary>
            <param name="doorsList"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized.op_Implicit(GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized)~GoRogue.MapGeneration.ContextComponents.DoorList">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized"/> to <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList"/>.
            </summary>
            <param name="doorsList"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized.FromDoorList(GoRogue.MapGeneration.ContextComponents.DoorList)">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized"/>.
            </summary>
            <param name="doorsList"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized.ToDoorList">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.DoorListSerialized"/> to <see cref="T:GoRogue.MapGeneration.ContextComponents.DoorList"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1.Items">
            <summary>
            Items added paired with the name of the step that added them.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1.op_Implicit(GoRogue.MapGeneration.ContextComponents.ItemList{`0})~GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized{`0}">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1"/>.
            </summary>
            <param name="list"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1.op_Implicit(GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized{`0})~GoRogue.MapGeneration.ContextComponents.ItemList{`0}">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1"/> to <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1"/>.
            </summary>
            <param name="list"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1.FromItemList(GoRogue.MapGeneration.ContextComponents.ItemList{`0})">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1"/>.
            </summary>
            <param name="list"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1.ToItemList">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.ItemListSerialized`1"/> to <see cref="T:GoRogue.MapGeneration.ContextComponents.ItemList`1"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.ContextComponents.RoomDoors"/> instance.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized.Room">
            <summary>
            The room whose doors are being stored.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized.Doors">
            <summary>
            Positions of doors.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized.op_Implicit(GoRogue.MapGeneration.ContextComponents.RoomDoors)~GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.ContextComponents.RoomDoors"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized"/>.
            </summary>
            <param name="doorsList"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized.op_Implicit(GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized)~GoRogue.MapGeneration.ContextComponents.RoomDoors">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized"/> to <see cref="T:GoRogue.MapGeneration.ContextComponents.RoomDoors"/>.
            </summary>
            <param name="doorsList"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized.FromRoomDoors(GoRogue.MapGeneration.ContextComponents.RoomDoors)">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.ContextComponents.RoomDoors"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized"/>.
            </summary>
            <param name="doorsList"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized.ToRoomDoors">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.ContextComponents.RoomDoorsSerialized"/> to <see cref="T:GoRogue.MapGeneration.ContextComponents.RoomDoors"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.RectangleEdgePositionsList"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized.Rectangle">
            <summary>
            The rectangle whose edge positions are being stored.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized.Positions">
            <summary>
            Positions being stored.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized.op_Implicit(GoRogue.MapGeneration.RectangleEdgePositionsList)~GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.RectangleEdgePositionsList"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized"/>.
            </summary>
            <param name="list"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized.op_Implicit(GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized)~GoRogue.MapGeneration.RectangleEdgePositionsList">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized"/> to <see cref="T:GoRogue.MapGeneration.RectangleEdgePositionsList"/>.
            </summary>
            <param name="list"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized.FromRectangleEdgePositionsList(GoRogue.MapGeneration.RectangleEdgePositionsList)">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.RectangleEdgePositionsList"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized"/>.
            </summary>
            <param name="list"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized.ToRectangleEdgePositionsList">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.RectangleEdgePositionsListSerialized"/> to <see cref="T:GoRogue.MapGeneration.RectangleEdgePositionsList"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.Name">
            <summary>
            Name of the generation step.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.BaseListTag">
            <summary>
            A tag that must be attached to the component that will have items from the other list appended onto it.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.ListToAppendTag">
            <summary>
            A tag that must be attached to the component that will have its items appended onto the base list.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.RemoveAppendedComponent">
            <summary>
            Whether or not to remove the component with the tag <see cref="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.ListToAppendTag" /> after its items have been
            added to the base list.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.op_Implicit(GoRogue.MapGeneration.Steps.Translation.AppendItemLists{`0})~GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized{`0}">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.op_Implicit(GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized{`0})~GoRogue.MapGeneration.Steps.Translation.AppendItemLists{`0}">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1"/> to <see cref="T:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.FromAppendItemLists(GoRogue.MapGeneration.Steps.Translation.AppendItemLists{`0})">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1.ToAppendItemLists">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.AppendItemListsSerialized`1"/> to <see cref="T:GoRogue.MapGeneration.Steps.Translation.AppendItemLists`1"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.Name">
            <summary>
            Name of the generation step.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.AreasComponentTag">
            <summary>
            Tag that must be associated with the component used to store the resulting areas.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.RectanglesComponentTag">
            <summary>
            Tag that must be associated with the component used as input rectangles.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.RemoveSourceComponent">
            <summary>
            Whether or not to remove the input list of rectangles from the context.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.op_Implicit(GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas)~GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.op_Implicit(GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized)~GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized"/> to <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.FromRectanglesToAreas(GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas)">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized.ToRectanglesToAreas">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RectanglesToAreasSerialized"/> to <see cref="T:GoRogue.MapGeneration.Steps.Translation.RectanglesToAreas"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized">
            <summary>
            Serializable (pure-data) object representing a <see cref="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints"/>
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.Name">
            <summary>
            Name of the generation step.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.ModifiedAreaListTag">
            <summary>
            Tag that must be associated with the component used as the area list from which duplicates are removed.
            </summary>
        </member>
        <member name="F:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.UnmodifiedAreaListTag">
            <summary>
            Tag that must be associated with the component used as the unmodified area list.
            </summary>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.op_Implicit(GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints)~GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.op_Implicit(GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized)~GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized"/> to <see cref="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.FromRemoveDuplicatePoints(GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints)">
            <summary>
            Converts <see cref="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints"/> to <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized"/>.
            </summary>
            <param name="step"/>
            <returns/>
        </member>
        <member name="M:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized.ToRemoveDuplicatePoints">
            <summary>
            Converts <see cref="T:GoRogue.SerializedTypes.MapGeneration.Steps.Translation.RemoveDuplicatePointsSerialized"/> to <see cref="T:GoRogue.MapGeneration.Steps.Translation.RemoveDuplicatePoints"/>.
            </summary>
            <returns/>
        </member>
        <member name="T:GoRogue.Utility">
            <summary>
            Static class containing extension helper methods for various built-in C# classes, as well as a
            static helper method for "swapping" references.
            </summary>
        </member>
        <member name="M:GoRogue.Utility.AsReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Adds an AsReadOnly method to <see cref="T:System.Collections.Generic.IDictionary`2" />, similar to the AsReadOnly method of
            <see cref="T:System.Collections.Generic.IList`1" />, that returns a read-only reference to the dictionary.
            </summary>
            <typeparam name="TKey">Type of keys of the dictionary.</typeparam>
            <typeparam name="TValue">Type of values of the dictionary.</typeparam>
            <param name="dictionary" />
            <returns>A ReadOnlyDictionary instance for the specified dictionary.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.String,System.String)">
            <summary>
            Extension method for <see cref="T:System.Collections.Generic.IEnumerable`1" /> that allows retrieving a string
            representing the contents.
            </summary>
            <remarks>
            Built-in C# data structures like <see cref="T:System.Collections.Generic.List`1" /> implement <see cref="T:System.Collections.Generic.IEnumerable`1" />,
            and as such this method can be used to stringify the contents of C# built-in data structures.
            When no customization parameters are specified, it defaults to a representation looking something
            like [elem1, elem2, elem3].
            </remarks>
            <typeparam name="T" />
            <param name="enumerable" />
            <param name="begin">Character(s) that should precede the string representation of the IEnumerable's elements.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each element. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="separator">Characters to separate the IEnumerable's elements by.</param>
            <param name="end">Character(s) that should follow the string representation of the IEnumerable's elements.</param>
            <returns>A string representation of the IEnumerable.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(System.Collections.Generic.ISet{``0},System.String,System.Func{``0,System.String},System.String,System.String)">
            <summary>
            Extension method for <see cref="T:System.Collections.Generic.ISet`1" /> that allows retrieving a string representing the
            contents.
            </summary>
            <remarks>
            Built-in C# data structures like <see cref="T:System.Collections.Generic.HashSet`1" /> implement <see cref="T:System.Collections.Generic.ISet`1" />,
            and as such this method can be used to stringify the contents of C# built-in set structures.
            When no customization parameters are specified, it defaults to a representation looking something
            like set(elem1, elem2, elem3).
            </remarks>
            <typeparam name="T" />
            <param name="set" />
            <param name="begin">Character(s) that should precede the string representation of the set's elements.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each element. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="separator">Characters to separate the set's items by.</param>
            <param name="end">Character(s) that should follow the string representation of the set's elements.</param>
            <returns>A string representation of the ISet.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``2(System.Collections.Generic.IDictionary{``0,``1},System.String,System.Func{``0,System.String},System.Func{``1,System.String},System.String,System.String,System.String)">
            <summary>
            Extension method for dictionaries that allows retrieving a string representing the dictionary's contents.
            </summary>
            <remarks>
            Built-in C# data structures like <see cref="T:System.Collections.Generic.Dictionary`2" /> implement <see cref="T:System.Collections.Generic.IDictionary`2" />,
            and as such this method can be used to stringify the contents of C# built-in dictionary structures.
            When no customization parameters are specified, it defaults to a representation looking something
            like {key1 : value, key2 : value}.
            </remarks>
            <typeparam name="TKey" />
            <typeparam name="TValue" />
            <param name="dictionary" />
            <param name="begin">Character(s) that should precede the string representation of the dictionary's elements.</param>
            <param name="keyStringifier">
            Function to use to get the string representation of each key. Specifying null uses the ToString
            function of type K.
            </param>
            <param name="valueStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type V.
            </param>
            <param name="kvSeparator">Characters used to separate each value from its key.</param>
            <param name="pairSeparator">Characters used to separate each key-value pair from the next.</param>
            <param name="end">Character(s) that should follow the string representation of the dictionary's elements.</param>
            <returns>A string representation of the IDictionary.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays that allows retrieving a string representing the contents.
            </summary>
            <typeparam name="T" />
            <param name="array" />
            <param name="begin">Character(s) that should precede the string representation of the 2D array.</param>
            <param name="beginRow">Character(s) that should precede the string representation of each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) used to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) used to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow the string representation of each row.</param>
            <param name="end">Character(s) that should follow the string representation of the 2D array.</param>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToStringGrid``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays that allows retrieving a string representing the contents,
            formatted as if the 2D array represents a coordinate plane/grid.
            </summary>
            <remarks>
            This differs from
            <see cref="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)" />
            in that this method prints the array
            such that array[x+1, y] is printed to the RIGHT of array[x, y], rather than BELOW it.
            Effectively it assumes the indexes being used are grid/coordinate plane coordinates.
            </remarks>
            <typeparam name="T" />
            <param name="array" />
            <param name="begin">Character(s) that should precede the string representation of the 2D array.</param>
            <param name="beginRow">Character(s) that should precede the string representation of each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) used to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) used to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow the string representation of each row.</param>
            <param name="end">Character(s) that should follow the string representation of the 2D array.</param>
            <returns>
            A string representation of the 2D array, formatted as if the array represents a 2D coordinate plane/grid map.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToStringGrid``1(``0[0:,0:],System.Int32,System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays that allows retrieving a string representing the contents,
            formatted as if the 2D array represents a coordinate plane/grid.
            </summary>
            <remarks>
            This differs from
            <see cref="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)" />
            in that this method prints the array such that array[x+1, y] is printed to the RIGHT of array[x, y], rather than BELOW
            it.
            Effectively it assumes the indexes being used are grid/coordinate plane coordinates.
            </remarks>
            <typeparam name="T" />
            <param name="array" />
            <param name="fieldSize">
            The amount of space each element should take up in characters. A positive number aligns
            the text to the right of the space, while a negative number aligns the text to the left.
            </param>
            <param name="begin">Character(s) that should precede the string representation of the 2D array.</param>
            <param name="beginRow">Character(s) that should precede the string representation of each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Specifying null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) used to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) used to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow the string representation of each row.</param>
            <param name="end">Character(s) that should follow the string representation of the 2D array.</param>
            <returns>
            A string representation of the 2D array, formatted as if the array represents a 2D coordinate plane/grid map.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.Multiply(System.String,System.Int32)">
            <summary>
            "Multiplies", aka repeats, a string the given number of times.
            </summary>
            <param name="str" />
            <param name="numTimes">The number of times to repeat the string.</param>
            <returns>The current string repeated <paramref name="numTimes" /> times.</returns>
        </member>
        <member name="M:GoRogue.Utility.Swap``1(``0@,``0@)">
            <summary>
            Swaps the values pointed to by <paramref name="lhs" /> and <paramref name="rhs" />.
            </summary>
            <typeparam name="T" />
            <param name="lhs" />
            <param name="rhs" />
        </member>
        <member name="M:GoRogue.Utility.Yield``1(``0)">
            <summary>
            Convenience function that yields the given item as a single-item IEnumerable.
            </summary>
            <typeparam name="T" />
            <param name="item" />
            <returns>An IEnumerable containing only the item the function is called on.</returns>
        </member>
        <member name="M:GoRogue.Utility.Yield``1(``0[])">
            <summary>
            Takes multiple parameters and converts them to an IEnumerable.
            </summary>
            <typeparam name="T" />
            <param name="values">Parameters (specified as multiple parameters to the function).</param>
            <returns>
            An IEnumerable of all of the given items, in the order they were given to the function.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.Flatten``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Takes multiple enumerables of items, and flattens them into a single IEnumerable.
            </summary>
            <typeparam name="T" />
            <param name="lists">Lists to "flatten".</param>
            <returns>An IEnumerable containing the items of all the enumerables passed in.</returns>
        </member>
        <member name="T:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions">
            <summary>
            Class containing some extension methods for <see cref="T:ShaiRandom.Generators.IEnhancedRandom" /> instances.
            </summary>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.PercentageCheck(ShaiRandom.Generators.IEnhancedRandom,System.Single)">
            <summary>
            Performs a percentage check that has the specified chance to succeed.  The percentage should be in range
            [0, 100] (inclusive).
            </summary>
            <param name="rng" />
            <param name="percentage">Percentage chance (out of 100) that this check will succeed.  Must be in range [0, 100].</param>
            <returns></returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomIndex(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Extension method that selects and returns a random valid index of a position in a (non-empty) Area.
            </summary>
            <exception cref="T:System.ArgumentException">An empty Area was provided.</exception>
            <param name="rng"/>
            <param name="area">The area to select from.  Must be non-empty.</param>
            <returns>The index selected.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomIndex(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea,System.Func{System.Int32,System.Boolean})">
            <summary>
            Extension method that selects and returns a random valid index for some position in the (non-empty)
            <see cref="T:SadRogue.Primitives.IReadOnlyArea"/> for which the selector function given returns true, using the rng specified.
            Indices are repeatedly selected until a qualifying index is found.
            </summary>
            <remarks>
            This function will never return if no indices in the area return true for the given selector, and could take
            a very long time to execute if the area is large and the selector returns true for very few of those indices.
            For a more reliable termination, use the overload taking a maxTries parameter instead:
            <see cref="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomIndex(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea,System.Func{System.Int32,System.Boolean},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">An empty Area was provided.</exception>
            <param name="rng" />
            <param name="area">The area to select from.  Must be non-empty.</param>
            <param name="selector">Function that should return true if the given index is valid selection, false otherwise.</param>
            <returns>Index selected.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomIndex(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea,System.Func{System.Int32,System.Boolean},System.Int32)">
            <summary>
            Extension method that selects and returns a random valid index for some position in the (non-empty)
            <see cref="T:SadRogue.Primitives.IReadOnlyArea"/> for which the selector function given returns true, using the rng specified.
            Indices are repeatedly selected until a qualifying index is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty Area was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selections returned true from <paramref name="selector"/></exception>
            <param name="rng" />
            <param name="area">The area to select from.  Must be non-empty.</param>
            <param name="selector">Function that should return true if the given index is valid selection, false otherwise.</param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>Index selected.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea)">
            <summary>
            Extension method that selects and returns a random position from the Area, using the rng
            specified. An exception is thrown if the area is empty.
            </summary>
            <exception cref="T:System.ArgumentException">An empty Area was provided.</exception>
            <param name="rng" />
            <param name="area">The area to select from.  Must be non-empty.</param>
            <returns>Item selected.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea,System.Func{SadRogue.Primitives.Point,System.Boolean})">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.IReadOnlyArea"/> for which the selector function given returns true, using the rng specified.
            Items are repeatedly selected until a qualifying index is found.
            </summary>
            <remarks>
            This function will never return if no positions in the area return true for the given selector, and could take
            a very long time to execute if the area is large and the selector returns true for very few of its positions.
            For a more reliable termination, use the overload taking a maxTries parameter instead:
            <see cref="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea,System.Func{SadRogue.Primitives.Point,System.Boolean},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">An empty Area was provided.</exception>
            <param name="rng" />
            <param name="area">The area to select from.  Must be non-empty.</param>
            <param name="selector">Function that should return true if the given index is valid selection, false otherwise.</param>
            <returns>Item selected.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.IReadOnlyArea,System.Func{SadRogue.Primitives.Point,System.Boolean},System.Int32)">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.IReadOnlyArea"/> for which the selector function given returns true, using the rng specified.
            Items are repeatedly selected until a qualifying index is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty Area was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selections returned true from <paramref name="selector"/></exception>
            <param name="rng" />
            <param name="area">The area to select from.  Must be non-empty.</param>
            <param name="selector">Function that should return true if the given index is valid selection, false otherwise.</param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>Position selected.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0})">
            <summary>
            Gets the value at a random position in the IGridView, using the rng given.
            </summary>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">The grid view to select from.</param>
            <returns>The item at a random position in the IGridView.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,System.Boolean})">
            <summary>
            Extension method that selects and returns a random item from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> for which the selector function given returns true, using the rng specified.
            Items are repeatedly selected until a qualifying value is found.
            </summary>
            <remarks>
            This function will never return if no positions in the view return true for the given selector, and could take
            a very long time to execute if the view is large and the selector returns true for very few of its positions.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">The grid view to select from.</param>
            <param name="selector">
            Function that takes a position, and the value at that position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <returns>
            The item at the first random position in the IGridView selected for which the selector returns true.
            </returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomElement``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,System.Boolean},System.Int32)">
            <summary>
            Extension method that selects and returns a random item from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> for which the selector function given returns true, using the rng specified.
            Items are repeatedly selected until a qualifying value is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selections returned true from <paramref name="selector"/></exception>
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="selector">
            Function that takes a position, and the value at that position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>
            The item at the first random position in the IGridView selected for which the selector returns true.
            </returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},``0)">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is the one that is specified.
            Positions are repeatedly selected until one with the specified value is found.
            </summary>
            <remarks>
            This function will never return if no positions in the view have the value given, and could take
            a very long time to execute if the view is large and very few of its positions have the specified value.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">The grid view to select from.</param>
            <param name="validValue">
            A value to look for in the IGridView to determine whether or not a generated position is valid.
            </param>
            <returns>A random position whose value in the current IGridView is equal to the one specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},``0,System.Int32)">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is the one that is specified.
            Positions are repeatedly selected until one with the specified value is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selected positions had a value of <paramref name="validValue"/>.</exception>
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="validValue">
            A value to look for in the IGridView to determine whether or not a generated position is valid.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>A random position whose value in the current IGridView is equal to the one specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is is one of the ones specified.
            Random positions are repeatedly selected until one that has one of the
            specified values is found.
            </summary>
            <remarks>
            This function will never return if no positions in the view have one of the values given, and could take
            a very long time to execute if the view is large and very few of its positions have one of the specified values.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">The grid view to select from.</param>
            <param name="validValues">
            A set of values to look for in the IGridView to determine whether or not a generated position
            is valid.
            </param>
            <returns>A random position whose value in this IGridView is equal to one of the values specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is is one of the ones specified.
            Positions are repeatedly selected until one that has one of the specified values is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selected positions had one of the given values.</exception>
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="validValues">
            A set of values to look for in the IGridView to determine whether or not a generated position
            is valid.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>A random position whose value in this IGridView is equal to one of the values specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is is one of the ones in the specified hash set.
            Random positions are repeatedly selected until one that has one of the
            specified values is found.
            </summary>
            <remarks>
            This function will never return if no positions in the view have one of the values given, and could take
            a very long time to execute if the view is large and very few of its positions have one of the specified values.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">The grid view to select from.</param>
            <param name="validValues">
            A set of values to look for in the IGridView to determine whether or not a generated position
            is valid.
            </param>
            <returns>A random position whose value in this IGridView is equal to one of the values specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Collections.Generic.HashSet{``0},System.Int32)">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is is one of the ones in the specified hash set.
            Positions are repeatedly selected until one that has one of the specified values is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selected positions had one of the given values.</exception>
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="validValues">
            A set of values to look for in the IGridView to determine whether or not a generated position
            is valid.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>A random position whose value in this IGridView is equal to one of the values specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},``0[])">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is is one of the ones specified.
            Random positions are repeatedly selected until one that has one of the
            specified values is found.
            </summary>
            <remarks>
            This function will never return if no positions in the view have one of the values given, and could take
            a very long time to execute if the view is large and very few of its positions have one of the specified values.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">The grid view to select from.</param>
            <param name="validValues">
            A set of values to look for in the IGridView to determine whether or not a generated position
            is valid.
            </param>
            <returns>A random position whose value in this IGridView is equal to one of the values specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Int32,``0[])">
            <summary>
            Extension method that selects and returns a random position from the given (non-empty)
            <see cref="T:SadRogue.Primitives.GridViews.IGridView`1"/> whose value in that grid view is is one of the ones specified.
            Positions are repeatedly selected until one that has one of the specified values is found, or the specified <paramref name="maxTries"/>
            value is reached.
            </summary>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selected positions had one of the given values.</exception>
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="validValues">
            A set of values to look for in the IGridView to determine whether or not a generated position
            is valid.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>A random position whose value in this IGridView is equal to one of the values specified.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,System.Boolean})">
            <summary>
            Gets a random position in the grid view, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found.
            </summary>
            <remarks>
            This function will never return if no positions in the view return true for the given selector, and could take
            a very long time to execute if the view is large and the selector returns true for very few of its positions.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty grid view was given.</exception>
            <typeparam name="T" />
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="selector">
            Function that takes a position and the value at that position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <returns>A random position in the IGridView for which the selector returns true.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0},System.Func{SadRogue.Primitives.Point,``0,System.Boolean},System.Int32)">
            <summary>
            Gets a random position in the grid view, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found, or <paramref name="maxTries"/>
            selections occur.
            </summary>
            <exception cref="T:System.ArgumentException">An empty grid view was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selected positions returned true from <paramref name="selector"/>.</exception>
            <typeparam name="T" />
            <param name="rng" />
            <param name="gridView">The grid view to select from.</param>
            <param name="selector">
            Function that takes a position and the value at that position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>A random position in the IGridView for which the selector returns true.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition``1(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.GridViews.IGridView{``0})">
            <summary>
            Randomly selects a position within the IGridView.
            </summary>
            <typeparam name="T" />
            <param name="rng"/>
            <param name="gridView">Grid view to select a position from.</param>
            <returns>A random position within the IGridView.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.Rectangle)">
            <summary>
            Randomly selects a position within the Rectangle.
            </summary>
            <param name="rng"/>
            <param name="rect">Rectangle to select a position from.</param>
            <returns>A random position within the Rectangle.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.Rectangle,System.Func{SadRogue.Primitives.Point,System.Boolean})">
            <summary>
            Gets a random position in the rectangle, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found.
            </summary>
            <remarks>
            This function will never return if no positions in the rectangle return true for the given selector, and could take
            a very long time to execute if the rectangle is large and the selector returns true for very few of its positions.
            For a more reliable termination, use the overload taking a maxTries parameter instead.
            </remarks>
            <exception cref="T:System.ArgumentException">An empty rectangle was given.</exception>
            <param name="rng" />
            <param name="rect">The Rectangle to select from.</param>
            <param name="selector">
            Function that takes a position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <returns>A random position in the Rectangle for which the selector returns true.</returns>
        </member>
        <member name="M:ShaiRandom.Generators.GoRogueEnhancedRandomExtensions.RandomPosition(ShaiRandom.Generators.IEnhancedRandom,SadRogue.Primitives.Rectangle,System.Func{SadRogue.Primitives.Point,System.Boolean},System.Int32)">
            <summary>
            Gets a random position in the rectangle, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found, or <paramref name="maxTries"/>
            selections occur.
            </summary>
            <exception cref="T:System.ArgumentException">An empty rectangle was provided.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A <paramref name="maxTries"/> value that was less than or equal to 0 was provided.</exception>
            <exception cref="T:ShaiRandom.Generators.MaxAttemptsReachedException">A value was selected <paramref name="maxTries"/> times, and none of the selected positions returned true from <paramref name="selector"/>.</exception>
            <param name="rng" />
            <param name="rect">The Rectangle to select from.</param>
            <param name="selector">
            Function that takes a position, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="maxTries">Maximum number of selections to make before giving up and throwing an exception.</param>
            <returns>A random position in the Rectangle for which the selector returns true.</returns>
        </member>
    </members>
</doc>
